<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>GWAN IT Blog</title>
  
  <subtitle>GWAN IT Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gwanhyeon.github.io/"/>
  <updated>2021-02-11T17:35:39.942Z</updated>
  <id>http://gwanhyeon.github.io/</id>
  
  <author>
    <name>gwanhyeon Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02 마이크로서비스 아키텍처</title>
    <link href="http://gwanhyeon.github.io/MSA-20210212-02-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"/>
    <id>http://gwanhyeon.github.io/MSA-20210212-02-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</id>
    <published>2021-02-11T14:59:08.000Z</published>
    <updated>2021-02-11T17:35:39.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maikeuroseobiseu-akitegceo"><a href="#maikeuroseobiseu-akitegceo" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#마이크로서비스-아키텍처"></a> 마이크로서비스 아키텍처</h1><h2 id="maikeuroseobiseu-akitegceoyi-gaenyeom"><a href="#maikeuroseobiseu-akitegceoyi-gaenyeom" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#마이크로서비스-아키텍처의-개념"></a> 마이크로서비스 아키텍처의 개념</h2><p>마이크로서비스 아키텍처(microservice architecture)는 마이크로서비스가 실행 될 수 있는 아키텍처를 뜻합니다. 마이크로서비스, 즉 아주 작은 단위로 동작하는 서비스가 구동되도록 시스템 및 소프트웨어의 구성과 구성 요소간의 관계를 정의한 아키텍처입니다.</p><p>마이크로서비스 아키텍처의 구성 요소는 서비스와 이를 실행할 수 있게하는 여러 기술적 환경입니다. 마이크로서비스 아키텍처를 다시 한번 정리해보면, 아주 작은 단위의 서비스들을 실행할 수 있도록 구성하기 위한 서비스 중심의 아키텍처입니다.</p><h2 id="monolriseu-akitegceowayi-caijeom"><a href="#monolriseu-akitegceowayi-caijeom" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#모놀리스-아키텍처와의-차이점"></a> 모놀리스 아키텍처와의 차이점</h2><p>모놀리스 아키텍처 구조에서는 하나의 애플리케이션에 데이터가 연결된 구성이 일반적으로 되어있고, 애플리케이션의 크기가 클 경우 변경과 배포가 쉽지 않은 구조를 띄고 있습니다.</p><p>이에반해, 마이크로서비스 아키텍처는 서비스와 데이터가 분할되어 작은 서비스들이 여러 독립된 형태로 서비스를 제공하여 필요에 따라 서로 참고하여 사용됩니다.</p><p>즉, 모놀리스 아키텍처와의 차이점은 하나의 애플리케이션 형태가 아닌 분할된 다수의 서비스라는점입니다. 애플리케이션 기능뿐만 아니라 데이터까지 분리하여 격리된 독립된 환경으로 구성되는것이 가장 큰 차이점이 됩니다.</p><p>단일 애플리케이션 형태인 모놀리스 아키텍처로 구성된 시스템에서는 클라이언트 요청에 대한 처리 반응 속도가 아주 중요한 요소인데, 데이터 조회에 대한 부하나 이를 처리하는 애플리케이션이 문제가 생긴다면 시스템이 동작하지 않는 결과를 초래합니다.</p><p>이것들을 대응하기 위해서는 <code>로드밸런서, 2중화,3중화, 백업 및 복구방안</code>이 아주 중요한 아키텍처 결정 사항이고 환경 구성을 위하여 많은 시스템 리소스(resource)를 투자합니다.</p><blockquote><p>온프로미스 아키텍처</p></blockquote><p>시스템이 받을 부하를 사전에 분석예측하는 하드웨어 스케일업 과정과 애플리케이션의 빠른 대응과 데이터 조회의 성닝 개선을 위한 튜닝(tuning) 활동등이 아키텍트의 주요한 관심사였습니다.</p><blockquote><p>마이크로서비스 아키텍처</p></blockquote><p>서비스의 수평적 확장에 유연성과 탄력성을 높여 성능적 이슈에 대해서 유연하게 대처할 수 있는 구조를 가집니다. 당연히 단일 애플리케이션 구조에서 보다 많은 서비스를 관리하는 문제로 서비스들을 관리하고 제어하기 위한 에코시스템(eco-system)들의 역할이 아주 중요하고, 자동화 시각화가 잘 고려되지않으면 오히려 운영 측면의 위험성은 증가하게 됩니다.</p><h2 id="seobiseu-jihyang-akitegceo"><a href="#seobiseu-jihyang-akitegceo" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#서비스-지향-아키텍처"></a> 서비스 지향 아키텍처</h2><p>대규모 시스템 환경에서 업무처리 단위를 각가의 서비스로 반영하여 데이터 중심이 아닌 전체 시스템을 서비스 중심으로 설계하는 아키텍처 스타일입니다.</p><p>마이크로 서비스가 주목받기 이전부터 기업환경에서 중복되는 프로세스나 업무들을 하나의 서비스단위로 개발하여 각 서비스는 호출 가능한 상태로 개발하자는 노력이 계속되어 왔습니다.</p><blockquote><p>서비스 지향 아키텍처의 특징</p></blockquote><ol><li>서비스 계약</li></ol><p>서비스와 서비스소비자와의 계약을 뜻합니다.<br>서비스는 약속한 기능을 수행해야하고 서비스 소비자는 서비스를 사용하기 위한 계약 규칙을 준수해야합니다. 서비스계약은 때에 따라서는 서비스 자체에 문제가 발생할 수도 있고, 서비스가 개선될 수도 있습니다. 버전1 -&gt; 버전2로 기능업그레이드가 가능할 수 있습니다.</p><ol start="2"><li>서비스의 가용성</li></ol><p>서비스지향 아키텍처에서 서비스들의 가용성을 보장하기 위한 소프트웨어 방법으로 타임아웃 기능 구현을 제안합니다.</p><p>일정 시간동안 서비스 요청에 대한 반응이 없으면 기존 요청경로를 차단하고, 다른 경로로 요청 경로를 변경하는 기능을 가동하여 서비스가 정상적으로 수행되도록 합니다.<br>정상적으로 동작하던 서비스가 문제가 발생하여 서비스 요청에 대한 응답 지연이 발생하면 정상적인 다른 서비스로 요청 경로를 변경하는 기능이 작동합니다.<br>즉, 서비스 가용성을 유지하기 위한 방법을 서비스 라우팅이라고 하며 라우팅 기능을 L4/L7은 하드 웨어 장비를 이용하여 구현할 수도 있고, 서킷 브레이커(circuit breaker) 같은 소프트웨어 기능으로 구현할 수 있습니다.</p><ol start="3"><li>보안</li></ol><p>하나의 서비스가 다른 서비스를 호출할 경우 별도의 인증 및 권한 확인 없이 바로 호출할 수 있는 구조가 되면 자칫 보안상 문제가 될 수 있습니다. 권한에 관한 제어권을 서비스 자체에 넘기게 되면 이러한 문제는 다소해결 될 수 있습니다.</p><ol start="4"><li>트랜잭션(transaction)</li></ol><p>서비스가 분할되고 서비스에서 발생하는 트랜잭션들에 대한 일관성 유지입니다. 일반적으로 서비스 지향 아키텍처에서는 성능상의 문제로 데이터베이스 읽기 전용 데이터 저장소와 데이터베이스 쓰기, 데이터 저장소를 분리 구성하도록 권고합니다. 하지만, 쓰인 데이터를 읽기 위해서는 데이터의 이동이 필요하고 이 부분에서 데이터의 일관성과 실시간 동기화 이슈가 발생학세 됩니다.</p><blockquote><p>BASE(Basically Available Soft State Eventual Consistency)트랜잭션</p></blockquote><p>basically available의 대표적인 기술 메커니즘은 Optional Locking, Queue이고 soft state는 외부전달 데이터로 인해 상태가 갱신되는것 입니다.</p><p>즉, 두 개의 노드가 있으면 한쪽에서 전달된 데이터로 인해 다른 한쪽 노드가 갱신된다는 사앙이며 eventual consistency는 두 노드의 데이터가 일시적으로 불일치한 시점이 있고, 일관성이 없는 상태이지만 결국에는 두 노드의 데이터가 같아진다는 개념dl ehlqslek.</p><ol start="5"><li>서비스 관리</li></ol><p>서비스들의 수가 많아지면 이들간의 관계를 관리해야합니다. 상황에 따라서 서비스가 동적으로 증가하여 과부하나 오류 상황에서도 지속적으로 가능한 서비스가 가능하도록 관리됩니다.</p><p>특정 서비스의 오류가 발생하면 자연스럽게 다른 정상적인 서비스로 요청 흐름의 변경도 가능하고 실시간으로 관리되고 시각화하여 모니터링이 진행되어야합니다.</p><h2 id="soawa-maikeuroseobiseu-akitegceoneun-mueosi-dareulggayo"><a href="#soawa-maikeuroseobiseu-akitegceoneun-mueosi-dareulggayo" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#soa와-마이크로서비스-아키텍처는-무엇이-다를까요"></a> SOA와 마이크로서비스 아키텍처는 무엇이 다를까요?</h2><p>비즈니스 변화 대응을 위한 서비스 중심의 아키텍처라는 점에서는 공통점이 있지만 서비스 상대적 크기와 관심사, 오너십(ownership) 기술구조에서 차이가 있습니다.</p><p>비즈니스 -&gt; SOA, 마이크로서비스 아키텍처</p><p>SOA와 마이크로 서비스 아키텍처의 공통점은 소프트웨어를 설계할 때 서비스 중심의 설계를 지향하는것이며 기능 중심의 모듈 재사용보다는 상위 수준의 서비스 수준에 재사용성에 초점을 맞추게됩니다. 다만 SOA는 비즈니스측면에서의 서비스 재사용성을 강조하는 반면에 마이크로서비스는 한가지 작은 서비스에 집중하기를 강조합니다.</p><p>SOA는 되도록 많은 서비스의 공유를 위해 ESB(Enterprise Service Bus)라는 서비스 채널을 이용하여 서비스를 공유하고 재사용하는데 초점을 맞춘다면, 마이크로서비스는 되도록 서비스를 공유하지않고 독립되어 실행하는것을 지향합니다. 즉, 시스템의 탄력성을 높입니다.</p><blockquote><p>SOA 마이크로서비스 차이점</p></blockquote><ol><li>서비스 상대적 크기와 관심사의 차이점<br>마이크로서비스아키텍처는 서비스는 작고 한가지 일에 집중하는 반면, SOA서비스는 비즈니스에 집중합니다.</li></ol><p>CRM(Customer Relationship Management) 통합 구축 프젝트에서는 고객정보 관리라는 큰 서비스가 있으면 마이크로서비스 관점에서는 고객빌링관리 등의 업무를 더 세분화 시킵니다.</p><p>예를 들면, 청구 조회,등록,수정,삭제 서비스, 신용 정보 조회, 등록, 수정, 삭제 등 더 작게 세분화 시킬 수 있습니다.</p><ol start="2"><li>서비스 오너십 측면에서 마이크로서비스는 하나의 작은 팀에서 관리합니다.</li></ol><p>서비스의 개발에서 운영까지 오너십과 권한을 가지는 독립된 단위의 서비스이며 조직 구성과도 관련이 있는 부분입니다. 마이크로서비스는 하나의 독립된 팀에서 개발하고 관리하고 반면의 SOA의 서비스는 비즈니스 프로세스의 흐름과 관련된 서비스를 공유하기 위해서 중앙의 인프라 미들웨어에 탑재하고 필요에 따라 연결 및 조합하여 새로운 서비스를 만들어내게 됩니다.</p><p>이 과정에서 업무팀, 공통 기능 개발팀, 개발팀의 상호협업이 반드시 필요하게 됩니다.</p><ol start="3"><li>서비스 공유 정도의 차이</li></ol><p>마이크로서비스는 서비스 공유의 최소화를 지향하는 반면에 SOA는 되도록 많은 서비스의 공유를 지향합니다.</p><p>마이크로 서비스 아키텍처는 서비스 간의 결합도를 낮추어 변화에 능동적으로 대응하기 위한 민첩성에 초점을 두지만, SOA는 재사용을 높여 비용을 절감하고 품질을 높이는데 초점을 두게 됩니다.</p><ol start="4"><li>기술 방식의 차이</li></ol><p>SOA가 공통 서비스를 ESB라는 공통된 채널에 모아 사업 측면에서 공통 서비스 형식으로 서비스를 제공하였다면 마이크로 서비스는 각각의 독립된 서비스가 필요에 따라 노출된 REST API(Application Programming Interface)를 사용합니다.</p><p>SOA는 흩어져 있던 같은 역할을 하는 서비스들을 통합하여 ESB에 담아서 필요할때마다 사용할 수 있는 기술 구조이고 마이크로 서비스 아키텍처는 흩어져있는 서비스들의 통합없이 각각의 서비스가 노출한 RESTful API정보를 보고 필요할때 호출하여 사용하는것 입니다. 결국 SOA는 통합과 공유 마이크로 서비스 아키텍처는 분산과 독립이라는 개념으로 구분할 수 있습니다.</p><blockquote><p>서비스 메커니즘</p></blockquote><p>SOA는 통합된 서비스들을 UDDI(Universal Description Discovery and Integration)라는 서비스 저장소에 등록하고 WSDL(Web Service Description Langauge)라는 서비스 저장소에 등록하고 WSDL에는 UDDI에 공유한 서비스의 명세가 담겨있고, 이 명세를 참고하여 서비스를 사용하는 클라이언트는 'stub’이라는 클래스를 생성하여 서버와 SOAP(Simple Object Access Protocol)을 이용하여 통신하게 됩니다. 만약 WSDL의 명세가 바뀌면 이를 참조하는 모든 클라이언트 프로그램들을 바꿔야하고 변경이나 장애에 대한 결합도가 아주 높아지게 됩니다.</p><p>이해 반해, 마이크로 서비스 아키텍처는 클라이언트에서 서비스 제공자가 노출해놓은 RESTful API를 보고 호출하여 받는 결과값만 활용하므로 구현이 쉽고, 서비스 제공자가 제공하는 서비스의 인터페이스에 대한 변경 영향은 발생하지 않습니다. 서비스 제공자가 제공하는 결과값이 다소 바뀔 수 있어도 그로 인한 영향도는 SOA만큼이나 결합도가 높지 않습니다. 마이크로 서비스 아키텍처와 SOA는 아키텍처의 기술 구조와 다른 아키텍처 스타일이지만, 비즈니스에 민첩한 대응을 위한 아키텍처구조와 아키텍처의 모습이 서비스를 지향해야하고 이를 민첩하게 반응하기 위하여 기술 메커니즘에서는 같은 사상을 가지게 됩니다.</p><blockquote><p>마이크로서비스 아키텍처와 SOA 특징 비교</p></blockquote><table><thead><tr><th>구분</th><th>마이크로서비스 아키텍처</th><th>SOA</th></tr></thead><tbody><tr><td>사상</td><td>서비스지향</td><td>서비스 지향</td></tr><tr><td>서비스 오너십</td><td>조직(팀)단위 자율성 부여</td><td>조직간 협업</td></tr><tr><td>서비스 크기</td><td>SOA 대비 작음</td><td>마이크로서비스아키텍처 대비 큼</td></tr><tr><td>서비스 공유 정보</td><td>서비스간 독립</td><td>서비스 공유</td></tr><tr><td>서비스 공유 방식</td><td>API</td><td>서비스공유를 위한 미들웨어</td></tr><tr><td>서비스 통신 방식</td><td>RESTful API</td><td>SOAP, WSDL, UDDI, ESB</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;maikeuroseobiseu-akitegceo&quot;&gt;&lt;a href=&quot;#maikeuroseobiseu-akitegceo&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#마
      
    
    </summary>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/categories/msa/"/>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/tags/msa/"/>
    
  </entry>
  
  <entry>
    <title>02 마이크로서비스 아키텍처</title>
    <link href="http://gwanhyeon.github.io/MSA-20210211-msa-02-%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3-%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/"/>
    <id>http://gwanhyeon.github.io/MSA-20210211-msa-02-%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3-%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/</id>
    <published>2021-02-11T14:59:08.000Z</published>
    <updated>2021-02-11T15:43:19.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maikeuroseobiseu-akitegceo"><a href="#maikeuroseobiseu-akitegceo" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#마이크로서비스-아키텍처"></a> 마이크로서비스 아키텍처</h1><h2 id="maikeuroseobiseu-akitegceoyi-gaenyeom"><a href="#maikeuroseobiseu-akitegceoyi-gaenyeom" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#마이크로서비스-아키텍처의-개념"></a> 마이크로서비스 아키텍처의 개념</h2><p>마이크로서비스 아키텍처(microservice architecture)는 마이크로서비스가 실행 될 수 있는 아키텍처를 뜻합니다. 마이크로서비스, 즉 아주 작은 단위로 동작하는 서비스가 구동되도록 시스템 및 소프트웨어의 구성과 구성 요소간의 관계를 정의한 아키텍처입니다.</p><p>마이크로서비스 아키텍처의 구성 요소는 서비스와 이를 실행할 수 있게하는 여러 기술적 환경입니다. 마이크로서비스 아키텍처를 다시 한번 정리해보면, 아주 작은 단위의 서비스들을 실행할 수 있도록 구성하기 위한 서비스 중심의 아키텍처입니다.</p><h2 id="monolriseu-akitegceowayi-caijeom"><a href="#monolriseu-akitegceowayi-caijeom" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#모놀리스-아키텍처와의-차이점"></a> 모놀리스 아키텍처와의 차이점</h2><p>모놀리스 아키텍처 구조에서는 하나의 애플리케이션에 데이터가 연결된 구성이 일반적으로 되어있고, 애플리케이션의 크기가 클 경우 변경과 배포가 쉽지 않은 구조를 띄고 있습니다.</p><p>이에반해, 마이크로서비스 아키텍처는 서비스와 데이터가 분할되어 작은 서비스들이 여러 독립된 형태로 서비스를 제공하여 필요에 따라 서로 참고하여 사용됩니다.</p><p>즉, 모놀리스 아키텍처와의 차이점은 하나의 애플리케이션 형태가 아닌 분할된 다수의 서비스라는점입니다. 애플리케이션 기능뿐만 아니라 데이터까지 분리하여 격리된 독립된 환경으로 구성되는것이 가장 큰 차이점이 됩니다.</p><p>단일 애플리케이션 형태인 모놀리스 아키텍처로 구성된 시스템에서는 클라이언트 요청에 대한 처리 반응 속도가 아주 중요한 요소인데, 데이터 조회에 대한 부하나 이를 처리하는 애플리케이션이 문제가 생긴다면 시스템이 동작하지 않는 결과를 초래합니다.</p><p>이것들을 대응하기 위해서는 <code>로드밸런서, 2중화,3중화, 백업 및 복구방안</code>이 아주 중요한 아키텍처 결정 사항이고 환경 구성을 위하여 많은 시스템 리소스(resource)를 투자합니다.</p><blockquote><p>온프로미스 아키텍처</p></blockquote><p>시스템이 받을 부하를 사전에 분석예측하는 하드웨어 스케일업 과정과 애플리케이션의 빠른 대응과 데이터 조회의 성닝 개선을 위한 튜닝(tuning) 활동등이 아키텍트의 주요한 관심사였습니다.</p><blockquote><p>마이크로서비스 아키텍처</p></blockquote><p>서비스의 수평적 확장에 유연성과 탄력성을 높여 성능적 이슈에 대해서 유연하게 대처할 수 있는 구조를 가집니다. 당연히 단일 애플리케이션 구조에서 보다 많은 서비스를 관리하는 문제로 서비스들을 관리하고 제어하기 위한 에코시스템(eco-system)들의 역할이 아주 중요하고, 자동화 시각화가 잘 고려되지않으면 오히려 운영 측면의 위험성은 증가하게 됩니다.</p><h2 id="seobiseu-jihyang-akitegceo"><a href="#seobiseu-jihyang-akitegceo" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#서비스-지향-아키텍처"></a> 서비스 지향 아키텍처</h2><p>대규모 시스템 환경에서 업무처리 단위를 각가의 서비스로 반영하여 데이터 중심이 아닌 전체 시스템을 서비스 중심으로 설계하는 아키텍처 스타일입니다.</p><p>마이크로 서비스가 주목받기 이전부터 기업환경에서 중복되는 프로세스나 업무들을 하나의 서비스단위로 개발하여 각 서비스는 호출 가능한 상태로 개발하자는 노력이 계속되어 왔습니다.</p><blockquote><p>서비스 지향 아키텍처의 특징</p></blockquote><ol><li>서비스 계약</li></ol><p>서비스와 서비스소비자와의 계약을 뜻합니다.<br>서비스는 약속한 기능을 수행해야하고 서비스 소비자는 서비스를 사용하기 위한 계약 규칙을 준수해야합니다. 서비스계약은 때에 따라서는 서비스 자체에 문제가 발생할 수도 있고, 서비스가 개선될 수도 있습니다. 버전1 -&gt; 버전2로 기능업그레이드가 가능할 수 있습니다.</p><ol start="2"><li>서비스의 가용성</li></ol><p>서비스지향 아키텍처에서 서비스들의 가용성을 보장하기 위한 소프트웨어 방법으로 타임아웃 기능 구현을 제안합니다.</p><p>일정 시간동안 서비스 요청에 대한 반응이 없으면 기존 요청경로를 차단하고, 다른 경로로 요청 경로를 변경하는 기능을 가동하여 서비스가 정상적으로 수행되도록 합니다.<br>정상적으로 동작하던 서비스가 문제가 발생하여 서비스 요청에 대한 응답 지연이 발생하면 정상적인 다른 서비스로 요청 경로를 변경하는 기능이 작동합니다.<br>즉, 서비스 가용성을 유지하기 위한 방법을 서비스 라우팅이라고 하며 라우팅 기능을 L4/L7은 하드 웨어 장비를 이용하여 구현할 수도 있고, 서킷 브레이커(circuit breaker) 같은 소프트웨어 기능으로 구현할 수 있습니다.</p><ol start="3"><li>보안</li></ol><p>하나의 서비스가 다른 서비스를 호출할 경우 별도의 인증 및 권한 확인 없이 바로 호출할 수 있는 구조가 되면 자칫 보안상 문제가 될 수 있습니다. 권한에 관한 제어권을 서비스 자체에 넘기게 되면 이러한 문제는 다소해결 될 수 있습니다.</p><ol start="4"><li>트랜잭션(transaction)</li></ol><p>서비스가 분할되고 서비스에서 발생하는 트랜잭션들에 대한 일관성 유지입니다. 일반적으로 서비스 지향 아키텍처에서는 성능상의 문제로 데이터베이스 읽기 전용 데이터 저장소와 데이터베이스 쓰기, 데이터 저장소를 분리 구성하도록 권고합니다. 하지만, 쓰인 데이터를 읽기 위해서는 데이터의 이동이 필요하고 이 부분에서 데이터의 일관성과 실시간 동기화 이슈가 발생학세 됩니다.</p><blockquote><p>BASE(Basically Available Soft State Eventual Consistency)트랜잭션</p></blockquote><p>basically available의 대표적인 기술 메커니즘은 Optional Locking, Queue이고 soft state는 외부전달 데이터로 인해 상태가 갱신되는것 입니다.</p><p>즉, 두 개의 노드가 있으면 한쪽에서 전달된 데이터로 인해 다른 한쪽 노드가 갱신된다는 사앙이며 eventual consistency는 두 노드의 데이터가 일시적으로 불일치한 시점이 있고, 일관성이 없는 상태이지만 결국에는 두 노드의 데이터가 같아진다는 개념dl ehlqslek.</p><ol start="5"><li>서비스 관리</li></ol><p>서비스들의 수가 많아지면 이들간의 관계를 관리해야합니다. 상황에 따라서 서비스가 동적으로 증가하여 과부하나 오류 상황에서도 지속적으로 가능한 서비스가 가능하도록 관리됩니다.</p><p>특정 서비스의 오류가 발생하면 자연스럽게 다른 정상적인 서비스로 요청 흐름의 변경도 가능하고 실시간으로 관리되고 시각화하여 모니터링이 진행되어야합니다.</p><h2 id="soawa-maikeuroseobiseu-akitegceoneun-mueosi-dareulggayo"><a href="#soawa-maikeuroseobiseu-akitegceoneun-mueosi-dareulggayo" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#soa와-마이크로서비스-아키텍처는-무엇이-다를까요"></a> SOA와 마이크로서비스 아키텍처는 무엇이 다를까요?</h2><p>비즈니스 변화 대응을 위한 서비스 중심의 아키텍처라는 점에서는 공통점이 있지만 서비스 상대적 크기와 관심사, 오너십(ownership) 기술구조에서 차이가 있습니다.</p><p>비즈니스 -&gt; SOA, 마이크로서비스 아키텍처</p><p>SOA와 마이크로 서비스 아키텍처의 공통점은 소프트웨어를 설계할 때 서비스 중심의 설계를 지향하는것이며 기능 중심의 모듈 재사용보다는 상위 수준의 서비스 수준에 재사용성에 초점을 맞추게됩니다. 다만 SOA는 비즈니스측면에서의 서비스 재사용성을 강조하는 반면에 마이크로서비스는 한가지 작은 서비스에 집중하기를 강조합니다.</p><p>SOA는 되도록 많은 서비스의 공유를 위해 ESB(Enterprise Service Bus)라는 서비스 채널을 이용하여 서비스를 공유하고 재사용하는데 초점을 맞춘다면, 마이크로서비스는 되도록 서비스를 공유하지않고 독립되어 실행하는것을 지향합니다. 즉, 시스템의 탄력성을 높입니다.</p><blockquote><p>SOA 마이크로서비스 차이점</p></blockquote><ol><li>서비스 상대적 크기와 관심사의 차이점<br>마이크로서비스아키텍처는 서비스는 작고 한가지 일에 집중하는 반면, SOA서비스는 비즈니스에 집중합니다.</li></ol><p>CRM(Customer Relationship Management) 통합 구축 프젝트에서는 고객정보 관리라는 큰 서비스가 있으면 마이크로서비스 관점에서는 고객빌링관리 등의 업무를 더 세분화 시킵니다.</p><p>예를 들면, 청구 조회,등록,수정,삭제 서비스, 신용 정보 조회, 등록, 수정, 삭제 등 더 작게 세분화 시킬 수 있습니다.</p><ol start="2"><li>서비스 오너십 측면에서 마이크로서비스는 하나의 작은 팀에서 관리합니다.</li></ol><p>서비스의 개발에서 운영까지 오너십과 권한을 가지는 독립된 단위의 서비스이며 조직 구성과도 관련이 있는 부분입니다. 마이크로서비스는 하나의 독립된 팀에서 개발하고 관리하고 반면의 SOA의 서비스는 비즈니스 프로세스의 흐름과 관련된 서비스를 공유하기 위해서 중앙의 인프라 미들웨어에 탑재하고 필요에 따라 연결 및 조합하여 새로운 서비스를 만들어내게 됩니다.</p><p>이 과정에서 업무팀, 공통 기능 개발팀, 개발팀의 상호협업이 반드시 필요하게 됩니다.</p><ol start="3"><li>서비스 공유 정도의 차이</li></ol><p>마이크로서비스는 서비스 공유의 최소화를 지향하는 반면에 SOA는 되도록 많은 서비스의 공유를 지향합니다.</p><p>마이크로 서비스 아키텍처는 서비스 간의 결합도를 낮추어 변화에 능동적으로 대응하기 위한 민첩성에 초점을 두지만, SOA는 재사용을 높여 비용을 절감하고 품질을 높이는데 초점을 두게 됩니다.</p><ol start="4"><li>기술 방식의 차이</li></ol><p>SOA가 공통 서비스를 ESB라는 공통된 채널에 모아 사업 측면에서 공통 서비스 형식으로 서비스를 제공하였다면 마이크로 서비스는 각각의 독립된 서비스가 필요에 따라 노출된 REST API(Application Programming Interface)를 사용합니다.</p><p>SOA는 흩어져 있던 같은 역할을 하는 서비스들을 통합하여 ESB에 담아서 필요할때마다 사용할 수 있는 기술 구조이고 마이크로 서비스 아키텍처는 흩어져있는 서비스들의 통합없이 각각의 서비스가 노출한 RESTful API정보를 보고 필요할때 호출하여 사용하는것 입니다. 결국 SOA는 통합과 공유 마이크로 서비스 아키텍처는 분산과 독립이라는 개념으로 구분할 수 있습니다.</p><blockquote><p>서비스 메커니즘</p></blockquote><p>SOA는 통합된 서비스들을 UDDI(Universal Description Discovery and Integration)라는 서비스 저장소에 등록하고 WSDL(Web Service Description Langauge)라는 서비스 저장소에 등록하고 WSDL에는 UDDI에 공유한 서비스의 명세가 담겨있고, 이 명세를 참고하여 서비스를 사용하는 클라이언트는 'stub’이라는 클래스를 생성하여 서버와 SOAP(Simple Object Access Protocol)을 이용하여 통신하게 됩니다. 만약 WSDL의 명세가 바뀌면 이를 참조하는 모든 클라이언트 프로그램들을 바꿔야하고 변경이나 장애에 대한 결합도가 아주 높아지게 됩니다.</p><p>이해 반해, 마이크로 서비스 아키텍처는 클라이언트에서 서비스 제공자가 노출해놓은 RESTful API를 보고 호출하여 받는 결과값만 활용하므로 구현이 쉽고, 서비스 제공자가 제공하는 서비스의 인터페이스에 대한 변경 영향은 발생하지 않습니다. 서비스 제공자가 제공하는 결과값이 다소 바뀔 수 있어도 그로 인한 영향도는 SOA만큼이나 결합도가 높지 않습니다. 마이크로 서비스 아키텍처와 SOA는 아키텍처의 기술 구조와 다른 아키텍처 스타일이지만, 비즈니스에 민첩한 대응을 위한 아키텍처구조와 아키텍처의 모습이 서비스를 지향해야하고 이를 민첩하게 반응하기 위하여 기술 메커니즘에서는 같은 사상을 가지게 됩니다.</p><blockquote><p>마이크로서비스 아키텍처와 SOA 특징 비교</p></blockquote><table><thead><tr><th>구분</th><th>마이크로서비스 아키텍처</th><th>SOA</th></tr></thead><tbody><tr><td>사상</td><td>서비스지향</td><td>서비스 지향</td></tr><tr><td>서비스 오너십</td><td>조직(팀)단위 자율성 부여</td><td>조직간 협업</td></tr><tr><td>서비스 크기</td><td>SOA 대비 작음</td><td>마이크로서비스아키텍처 대비 큼</td></tr><tr><td>서비스 공유 정보</td><td>서비스간 독립</td><td>서비스 공유</td></tr><tr><td>서비스 공유 방식</td><td>API</td><td>서비스공유를 위한 미들웨어</td></tr><tr><td>서비스 통신 방식</td><td>RESTful API</td><td>SOAP, WSDL, UDDI, ESB</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;maikeuroseobiseu-akitegceo&quot;&gt;&lt;a href=&quot;#maikeuroseobiseu-akitegceo&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#마
      
    
    </summary>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/categories/msa/"/>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/tags/msa/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 합승택시요금</title>
    <link href="http://gwanhyeon.github.io/programmers-%ED%95%A9%EC%8A%B9%ED%83%9D%EC%8B%9C%EC%9A%94%EA%B8%88/"/>
    <id>http://gwanhyeon.github.io/programmers-%ED%95%A9%EC%8A%B9%ED%83%9D%EC%8B%9C%EC%9A%94%EA%B8%88/</id>
    <published>2021-02-08T11:19:28.000Z</published>
    <updated>2021-02-08T11:21:51.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="peurogeuraemeoseu-habseungtaegsiyogeum"><a href="#peurogeuraemeoseu-habseungtaegsiyogeum" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#프로그래머스-합승택시요금"></a> <a href="https://developmentspace.tistory.com/98?category=737181" target="_blank" rel="noopener">프로그래머스 합승택시요금 </a></h1><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><blockquote><p>플로이드워셜알고리즘을 이용한 최단경로 문제</p></blockquote><ul><li>(1) 모든 맵에 지점의 개수 * 택시비용의 최댓값인 (100 * 200000)으로 값을 초기화해줍니다.</li><li>(2) 자기자신을 바라보는것들은 0으로 초기화합니다</li><li>(3) 배열값을 복사하여 배열들의 값을 재 세팅을 해줍니다.</li><li>(4) 플로이드워셜알고리즘의 점화식을 도출해냅니다. graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j])</li><li>(5) 점화식으로 도출해낸 모든 비용의 배열에서 출발지점 -&gt; (모든지점을 탐색의 비용 + 모든지점의 탐색 -&gt; A의 도착의 비용 + 모든지점의 탐색 -&gt; B의 도착의 비용)의 최솟값을 구해줍니다.</li><li>(6) 결국, 시작점에서 출발하여 거쳐간 지점중에 + A도착점 + B도착점의 최솟값을 탐색을 하게 되면 모든 최단 경로의 비용을 구할 수 있게 됩니다.</li><li>(7) 시간복잡도 O(N^3)</li></ul><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">programmers_</span>합승택시요금<span class="title">_kgh</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] graph;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">200</span> * <span class="number">100000</span>;      <span class="comment">// 지점의 개수 * 택시비용 최댓</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        solution(<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">24</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">41</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">24</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">50</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">66</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">22</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">25</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 노드의 개수</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 출발지점</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a A 도착지점</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b B 도착 지점</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fares</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>[][] fares)</span></span>&#123;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">int</span> answer = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 무한으로 초기화</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">201</span>; i++)&#123;</span><br><span class="line">            Arrays.fill(graph[i], INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 자기 자신 0 초기화</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    graph[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.배열값 복사</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;fares.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = fares[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = fares[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w = fares[i][<span class="number">2</span>];</span><br><span class="line">            graph[x][y] = w;</span><br><span class="line">            graph[y][x] = w;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 플로이드 워셜: 모든 경우에서 거쳐가는경로의 최소비용을 구합니다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">                    graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 거쳐가는 경로를 모두 합한값의 최솟값을 구해줍니다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            answer = Math.min(answer,graph[s][i] + graph[i][a] + graph[i][b]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;peurogeuraemeoseu-habseungtaegsiyogeum&quot;&gt;&lt;a href=&quot;#peurogeuraemeoseu-habseungtaegsiyogeum&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;mar
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="플로이드워셜알고리즘" scheme="http://gwanhyeon.github.io/tags/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%9B%8C%EC%85%9C%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="프로그래머스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>JPA 엔티티(Entity)</title>
    <link href="http://gwanhyeon.github.io/JPA-20210205-jpa-03-%EC%97%94%ED%8B%B0%ED%8B%B0/"/>
    <id>http://gwanhyeon.github.io/JPA-20210205-jpa-03-%EC%97%94%ED%8B%B0%ED%8B%B0/</id>
    <published>2021-02-05T06:15:32.000Z</published>
    <updated>2021-02-05T09:06:20.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="entity-maeping-eonoteisyeon"><a href="#entity-maeping-eonoteisyeon" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#entity-매핑-어노테이션"></a> Entity 매핑 어노테이션</h1><ul><li><p>객체, 테이블 매핑<br>@Entity, @table</p></li><li><p>필드와 컬럼 매핑<br>@Column</p></li><li><p>기본 키 매핑<br>@Id</p></li><li><p>연관관계 매핑<br>@ManyToOne, @JoinColumn</p></li></ul><blockquote><p>Entity 의미</p></blockquote><p>@Entity가 붙은 클래스는 JPA가 관리하고 하는 엔티티라고 하며 JPA에서 사용하는 테이블과 매핑할 클래스는 @Entity는 필수로 사용되어지고 있습니다.<br>여기서 가장 중요한것은 기본 생성자는 필수로 있어야하며, final, enum, interface, inner 클래스는 사용할 수없습니다. 즉, 해당것들을 매핑이 불가능하게 됩니다. 그리고 저장할 필드에서는 final을 사용하면 안됩니다.</p><blockquote><p>Entity 속성</p></blockquote><p>name속성 같은경우는 사용할 엔티티 이름을 지정합니다. 기본값은 현재 클래스의 이름을 그대로 사용하고 같은 클래스 이름이 없으면 가급적으로 기본값을 사용하는것이 가장 좋습니다.</p><h1 id="teibeul-maeping-eonoteisyeon"><a href="#teibeul-maeping-eonoteisyeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#테이블-매핑-어노테이션"></a> 테이블 매핑 어노테이션</h1><p>@Table 어노테이션은 엔티티와 매핑할 테이블일 지정합니다. 테이블 매핑 어노테이션은 여러가지 속성들을 가지고 있는데 대표적인것들이 4가지로 나눌 수 있습니다.</p><ol><li>name: 매핑할 테이블 이름</li><li>catalog: 데이터베이스 catalog 매핑</li><li>schema: 데이터베이스 schema 매핑</li><li>uniqueConstraints DDL 생성 시에 유니크 제약 조건 생성</li></ol><h1 id="deiteo-beiseu-ddl-seukima"><a href="#deiteo-beiseu-ddl-seukima" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#데이터-베이스-ddl-스키마"></a> 데이터 베이스 DDL 스키마</h1><p>데이터베이스에서 스키마가 자동생성은 DDL을 애플리케이션 생성 시점에 자동 생성이 됩니다. 이것은 테이블 중심에서 객체중심으로 옮겨간 패러다임이라고 할 수 있으며 데이터베이스마다 방언(dialect) Mysql, Oracle 등 데이터베이스에 맞는 적절한 DDL을 생성시킬 수 있습니다. 이것은 데이터베이스에서 사용되는것이 아니라 현재 개발중인 DDL에서만 적용되게 됩니다.</p><h2 id="deiteobeiseu-seukima-jadong-saengseong-sogseong"><a href="#deiteobeiseu-seukima-jadong-saengseong-sogseong" class="header-anchor">3.1. </a><a class="markdownIt-Anchor" href="#데이터베이스-스키마-자동-생성속성"></a> 데이터베이스 스키마 자동 생성(속성)</h2><ol><li>craete: 기존테이블 삭제 후 다시 생성합니다.(drop + create)</li><li>create-drop: create와 같지만 종료시점에 테이블을 다시 drop시켜버립니다.</li><li>update: 변경된 부분만 반영하고 운영쪽에서는 사용하면 위험합니다.</li><li>validate: 엔티티와 테이블이 정상 매핑되었는지만 확인합니다.</li><li>none: 사용하지 않는 속성</li></ol><h3 id="kodeu-yeje"><a href="#kodeu-yeje" class="header-anchor">3.1.1. </a><a class="markdownIt-Anchor" href="#코드-예제"></a> 코드 예제</h3><p>DB Dialect 를 설정 할 수 있으며 javax로 시작하는것은 여러가지를 가지고 있는데 하이버네이트 라이브러리나 또 다른 구현체 라이브러리를 써도 사용할 수 있다. 즉, 하이버네이트 전용 옵션이라고 할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=<span class="string">"hibernate.dialect"</span> value=<span class="string">"org.hibernate.dialect.H2Dialect"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"hibernate.dialect"</span> value=<span class="string">"org.hibernate.dialect.MySQL5Dialect"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"hibernate.dialect"</span> value=<span class="string">"org.hibernate.dialect.Oracle10gDialect"</span>/&gt;</span><br></pre></td></tr></table></figure><p>차이점이라고 하면 예를 들어 오라클같은경우는 varchar2, Mysql은 varchar과 같은 예를 들 수 있습니다. 여기서 가장 중요한점은 운영하는 서버에서는 craete, create-drop, update를 사용하면 절대 안됩니다.</p><p>개발 초기단계에는 create 또는 update를 사용하고 테스트 서버에서는 update 또는 validate를 처리할 수 있습니다. 스테이징과 운영서버는 validate 또는 none으로 처리하여 진행하면 됩니다.</p><h2 id="ddl-saengseong-gineung"><a href="#ddl-saengseong-gineung" class="header-anchor">3.2. </a><a class="markdownIt-Anchor" href="#ddl-생성-기능"></a> DDL 생성 기능</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column</span>(nullable == <span class="keyword">false</span>, length = <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>다음과 같은 컬럼 어노테이션 속성이 있다고 가정하면 해당 컬럼은 null값이 올 수 없으며 10자를 초과할 수 없다라는 의미가 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(uniqueConstraints = &#123;UniqueConstraint(name = <span class="string">"NAME"</span>, columnNames=&#123;<span class="string">"NAME"</span>. <span class="string">"AGE"</span>&#125;)&#125;)</span><br></pre></td></tr></table></figure><p>다음과 같은 유니크 테이블 제약조건을 처리할 수도 있습니다.</p><p>즉, DDL 생성 기능은 DDL을 자동 생성할때만 사용되고 JPA실행 로직에는 영향을 주지 않는다는점을 알고 있어야합니다.</p><h1 id="pildeu-mic-keolreom-maeping"><a href="#pildeu-mic-keolreom-maeping" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#필드-및-컬럼-매핑"></a> 필드 및 컬럼 매핑</h1><blockquote><p>매핑 어노테이션 hibernate.hbm2ddl.auto</p></blockquote><ul><li>@Column: 컬럼 매핑</li><li>@Temporal: 날짜 타입 매핑</li><li>@Enumerated: enum 타입 매핑</li><li>@Lob: BLOB, CLOB 매핑(varchar 범위 넘어설때)</li><li>@Transient: 특정 필드를 매핑하지 않음.(무시)</li></ul><blockquote><p>@Column 속성</p></blockquote><ul><li>name: 필드와 매핑할 테이블의 칼럼 이름</li><li>insertable, updatable: 등록,변경 가능여부</li><li>nullable(DDL): null값의 허용 여부를 설정하고 false로 설정하면 DDL 생성시에 not null 제약조건을 붙입니다.</li><li>unique(DDL): @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸때 사용됩니다.</li><li>columnDefinition(DDL): 데이터베이스 컬럼 정보를 직접 줄 수 있습니다. (varchar(100) default ‘EMPTY’)</li><li>length(DDL): 문자 길이 제약조건, String 타입에만 사용한다.</li><li>precision, scale(DDL): BigDecimal 타입에서 사용하고 precision은 소수점을 포함한 전체 자릿수며 scale은 소수의 자릿수입니다. (double, float 타입에는 적용 X)</li></ul><blockquote><p>@Enumerated</p></blockquote><p>Java Enum타입을 매핑할때 사용하며 ORDINAL 속성은 사용하지 않는게 좋다. 왜냐하면 DB에서 값이 변경되면 누락된 값이 들어갈 수 있기 때문이다.<br>즉, String을 사용하여야한다.</p><ul><li>value 속성: EnumType.ORDINAL enum순서를 DB 저장, EnumType.STRING enum 이름을 DB 저장 (기본값은 ORDINAL)</li></ul><blockquote><p>@Temporal</p></blockquote><p>날짜 타입을 매핑할때 사용합니다. LocalDate, LocalDateTime을 사용할시에는 생략이 가능합니다.(java8문법)</p><ul><li>value 속성:</li></ul><ol><li>TemporalType.DATE: 날짜 타입과 매핑 (2021-01-01 yyyy-mm-dd)</li><li>TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑 (24:00:00 hh-mm-ss)</li><li>TemporalType.TIMESTAMP: 날짜와 시간, timestamp와 매핑(2021-01-01 24:00:00 yyyy-mm-dd hh-mm-ss)</li></ol><blockquote><p>@Lob</p></blockquote><p>데이터베이스 BLOB, CLOB 타입과 매핑</p><ul><li>@Lob에는 지정할 수 있는 속성이 없습니다.</li><li>매핑하는 필드타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑</li></ul><p>CLOB: String, char[], java.sql.CLOB<br>BLOB: byte[], java.sql.BLOB</p><blockquote><p>@Transient</p></blockquote><ul><li>필드 매핑을 하지 않습니다.</li><li>데이터베이스에 저장 및 조회를 진행하지 않습니다.</li><li>주로 메모리상에서만 임시로 어떤값을 보관하고 싶을때 사용합니다.</li></ul><h1 id="gibonki-maeping"><a href="#gibonki-maeping" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#기본키-매핑"></a> 기본키 매핑</h1><h2 id="gibon-ki-maeping-eonoteisyeon"><a href="#gibon-ki-maeping-eonoteisyeon" class="header-anchor">5.1. </a><a class="markdownIt-Anchor" href="#기본-키-매핑-어노테이션"></a> 기본 키 매핑 어노테이션</h2><p>@Id, @GeneratedValue의 두가지 어노테이션을 가지고 있습니다.</p><blockquote><p>기본키 매핑 방법</p></blockquote><p>직접 할당은 @Id를 사용하여 할당하고 자동생성을 진행하기 위해서는 @GeneratedValue을 사용합니다.</p><ul><li>IDENTITY: 데이터베이스에 위임, MYSQL</li><li>SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용 Oracle, @SequenceGenerator</li><li>Table: 키 생성용 테이블 사용하고 모든 데이터베이스에서 사용될 수 있습니다. @TableGenerator</li><li>AUTO: 방언에 따라 자동 지정하고 기본값으로 세팅됩니다.</li></ul><blockquote><p>IDENTITY 전략</p></blockquote><p>기본키 생성을 데이터베이스에 위임하고 주로 Mysql, PostgreSQL, SQL Server, DB2에서 사용됩니다. (AUTO_INCREMENT)<br>그리고 JPA는 주로 트랜잭션 커밋 시점에 INSERT SQL을 실행합니다. AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID값을 알 수 있고 IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL을 실행하고 DB에서 식별자를 조회해옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SEQUENCE 전략</p></blockquote><p>데이터 베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트입니다. 예를 들면 오라클 시퀀스와 같습니다. 그리고 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@SequenceGenerator</span>(</span><br><span class="line">    name = <span class="string">"MEMBER_SEQ_GENERATOR"</span>,</span><br><span class="line">    sequenceName = <span class="string">"MEMBER_SEQ"</span></span><br><span class="line">    initValue = <span class="number">1</span>, allocationSize = <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.SEQUENCE,</span><br><span class="line">    generator = <span class="string">"MEMBER_SEQ_GENERATOR"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name: 식별자 이름</li><li>sequenceName: 데이터베이스에 등록되어있는 시퀀스 이름</li><li>initialValue: DDL 생성시에만 사용되고 시퀀스 DDL을 생성할때 처음 1 시작하는 수를 지정합니다.</li><li>allocationSize: 시퀀스 한 번 호출에 증가하는 수이며 성능최적화에 주로 사용됩니다. 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정하여야합니다.</li><li>catalog, schema: 데이터베이스 catalog, schema 이름</li></ul><h1 id="teibeul-jeonryag"><a href="#teibeul-jeonryag" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#테이블-전략"></a> 테이블 전략</h1><p>키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략인데 모든 데이터베이스에 적용이 가능하지만 성능적으로 뛰어나지는 않다는 단점을 가지고 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableGenerator</span>(</span><br><span class="line">    name = <span class="string">"MEMBER_SEQ_GENERATOR"</span>,</span><br><span class="line">    table = <span class="string">"MY_SEQUENCES"</span>,</span><br><span class="line">    pkColumnValue = <span class="string">"MEMBER_SEQ"</span>, allocationSize = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.TABLE,            <span class="comment">// 테이블 전략외</span></span><br><span class="line">    generator = <span class="string">"MEMBER_SEQ_GENERATOR"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@TableGenerator 속성</p></blockquote><ul><li>name: 식별자 이름(필수값)</li><li>table: 키생성 테이블명</li><li>pcColumnName: 시퀀스 컬럼명</li><li>valueColumnNa: 시퀀스 값 컬럼명</li><li>pkColumnValue: 키로 사용할 이름</li><li>initialValue: 초기 값, 마지막으로 생성된 값이 기준</li><li>allocationSize: 시퀀스 한 번 호출에 증가하는 수이며 최적화에 사용된다.</li><li>catalog, schema: 데이터베이스 catalog, schema 이름</li><li>uniqueConstraint: 유니크 제약조건 지정</li></ul><h1 id="gweonjanghaneun-sigbyeolja-jeonryag"><a href="#gweonjanghaneun-sigbyeolja-jeonryag" class="header-anchor">7. </a><a class="markdownIt-Anchor" href="#권장하는-식별자-전략"></a> 권장하는 식별자 전략</h1><p>기본 키 제약조건을 사용하고 null이 아니여야하고 변경성이 없어야합니다. 그리고 대체키를 활용하여 사용하도록 합니다. 즉, UUID와 같은 Long형+대체키+키생성전략을 사용하여 대체키를 생성할 수 있어야합니다. 예) 주민번호 PK</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;entity-maeping-eonoteisyeon&quot;&gt;&lt;a href=&quot;#entity-maeping-eonoteisyeon&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
    
      <category term="JPA" scheme="http://gwanhyeon.github.io/categories/jpa/"/>
    
    
      <category term="JPA" scheme="http://gwanhyeon.github.io/tags/jpa/"/>
    
      <category term="Entity" scheme="http://gwanhyeon.github.io/tags/entity/"/>
    
  </entry>
  
  <entry>
    <title>Network HTTP 상태코드</title>
    <link href="http://gwanhyeon.github.io/Network-20210205-network-09-http-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C/"/>
    <id>http://gwanhyeon.github.io/Network-20210205-network-09-http-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C/</id>
    <published>2021-02-05T04:17:11.000Z</published>
    <updated>2021-02-05T05:22:43.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http-sangtaekodeu"><a href="#http-sangtaekodeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#http-상태코드"></a> HTTP 상태코드</h1><h2 id="sangtae-kodeu"><a href="#sangtae-kodeu" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#상태-코드"></a> 상태 코드</h2><p>상태코드라고 하는것은 클라이언트가 보낸 요청의 처리상태를 응답에서 알려주는 기능이라고 할 수 있습니다.</p><p>예를 들어보겠습니다. 크롬에서 개발자모드를 키면 network탭에 보시면 어떤식으로 응답이 오고가는지를 확인할 수 있습니다.</p><blockquote><p>상태코드 예시</p></blockquote><ul><li>1xx(Informational): 요청 수신 및 처리진행중일때 나오는 상태코드</li><li>2xx(Successful): 요청 정상 처리 상태코드</li><li>3xx(Redirection): 요청을 완료하려면 추가 행동필요함을 알리는 상태코드</li><li>4xx(Client Error): 클라이언트 오류, 잘못된 문법 서버 요청 수행할 수 없을때 상태코드</li><li>5xx(Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못할때 나오는 상태코드</li></ul><p>인식할 수 없는 상태코드를 서버가 반환하게 되는 경우 상위 상태코드를 해석해서 처리를 진행합니다. 즉, 2xx면 성공상태 코드라고 생각하고, 4xx 클라이언트에러, 5xx 서버에러라고 생각하면 상태코드를 변경하지 않아도되게됩니다.</p><h2 id="sangtaekodeubyeol-ceori"><a href="#sangtaekodeubyeol-ceori" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#상태코드별-처리"></a> 상태코드별 처리</h2><ol><li><p>1xx(Informational)<br>현재 요청이 수신이 되어 처리를 진행중인 상태</p></li><li><p>2xx(Successful)<br>클라이언트의 요청을 성공적인 처리한 상태<br>200: OK, 201: Created(리소스 생성),  202: Accepted(요청접수 처리되었으나 처리 완료 X) - 배치 처리, 204: No Content: 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없을때 처리합니다.</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">HTTP/1.1 202 Accepted </span><br><span class="line">HTTP/1.1 200 No Content</span><br></pre></td></tr></table></figure><ol start="3"><li>3xx(Redirection)<br>요청을 완료하기 위해서는 유저의 에이전트에서 추가 조치가 필요한 상태코드</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 300 Multiple Choices</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">HTTP/1.1 303 See Other</span><br><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">HTTP/1.1 307 Temporary Redirect</span><br><span class="line">HTTP/1.1 308 Permanent Redirect</span><br></pre></td></tr></table></figure><p>웹 브라우저는 3xx 응답의 결과에 Location가 있는 경우 해당 위치로 리다이렉션을 진행합니다.</p><ul><li><p>영구 리다이렉션: 특정 리소스의 UR가 영구적으로 리다이렉션<br>301: 리다이렉트시 요청 메서드가 GET 변경되어 본문 제거<br>308: 리다이렉트시 요청 메서드와 본문 유지</p></li><li><p>일시적 리다이렉션: 특정 로직 주문같은 경우 주문이 모두 완료시 GET화면으로 리다이렉션<br>302: 리다이렉트시 요청 메서드가 GET 변경 본문 제거<br>307: 302와 기능은 같으나 요청메서드와 본문 유지<br>308: 리다이렉트시 요청 메서드가 GET으로 변경</p></li><li><p>특수 리다이렉션: 결과를 캐시로 리다이렉션<br>300: 잘 사용되지 않음<br>304: 캐시를 목적으로 사용되며 로컬 PC저장된 캐시를 재사용합니다.</p></li></ul><ol start="4"><li>4xx(Client Error)</li></ol><p>클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없습니다. 즉, 오류의 원인은 클라이언트</p><ul><li>400(Bad Request): 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없습니다.<br>요청 구문, 메시지 등의 오류와 클라이언트는 요청 내용을 다시검토하고 데이터를 전송해야합니다. Request Parameter 혹은 API 스펙이 맞지 않을 경우</li></ul><p>400은 500번과 다르게 복구가 불가능하고 500번은 같은 요청시 성공 가능성이 있습니다.</p><ul><li>401(Unauthorizaed)<br>클라이언트가 해당 리소스에 대한 인증이 필요합니다.</li></ul><p>인증이 되지 않거나 401 오류 발생시 응답에 WWW-Authenticate헤더와 함께 인증 방법을 설명해야합니다.<br>인증: 로그인, 인가: 권한부여(ADMIN)</p><ul><li><p>403(Forbidden)<br>서버가 요청을 이해했지만 승인을 거부한 경우<br>주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우 발생할 수 있습니다. (인가관련된 허가 여부-ADMIN)</p></li><li><p>404(Not Found)<br>요청 리소스를 찾을 수 없을때 발생하거나 권한이 부족한 리소스에 접근할때 발생합니다. 혹은 리소스를 Hide처리하고 싶을때 발생합니다.</p></li></ul><ol start="5"><li>5xx(Server Error)</li></ol><p>서버 문제로 오류가 발생할때 반환하는 상태코드입니다. 만약 서버가 문제가 있으니 클라이언트에서 재시도를 진행하면 성공할 수도 있다는것이 장점입니다.</p><ul><li><p>500(Internal Server Error)<br>서버 문제로 오류 발생, 애매하면 500을 반환합니다.</p></li><li><p>503(Service Unavailable)<br>서비스 이용 불가, 일시적인 과부하또는 예정된 작업으로 잠시 요청을 처리할 수 없는 경우 반환합니다. Retry-After헤더필드를 사용하면 얼마뒤에 복구되는지 반환시킬 수 있습니다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;http-sangtaekodeu&quot;&gt;&lt;a href=&quot;#http-sangtaekodeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#http-상태코드&quot;&gt;&lt;/a&gt; HTT
      
    
    </summary>
    
    
      <category term="Network" scheme="http://gwanhyeon.github.io/categories/network/"/>
    
    
      <category term="network" scheme="http://gwanhyeon.github.io/tags/network/"/>
    
      <category term="http" scheme="http://gwanhyeon.github.io/tags/http/"/>
    
      <category term="상태코드" scheme="http://gwanhyeon.github.io/tags/%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C/"/>
    
  </entry>
  
  <entry>
    <title>01 마이크로서비스 아키텍처의 이해</title>
    <link href="http://gwanhyeon.github.io/MSA-20210212-01-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98%EC%9D%B4%ED%95%B4/"/>
    <id>http://gwanhyeon.github.io/MSA-20210212-01-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98%EC%9D%B4%ED%95%B4/</id>
    <published>2021-02-04T01:52:30.000Z</published>
    <updated>2021-02-11T17:35:25.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sopeuteuweeo-akitegceoyi-ihae"><a href="#sopeuteuweeo-akitegceoyi-ihae" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처의-이해"></a> 소프트웨어 아키텍처의 이해</h1><h1 id="sopeuteuweeo-akitegceoran-mueosilgga"><a href="#sopeuteuweeo-akitegceoran-mueosilgga" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처란-무엇일까"></a> 소프트웨어 아키텍처란 무엇일까?</h1><h2 id="sopeuteuweeo-akitegceoyi-jeongyi"><a href="#sopeuteuweeo-akitegceoyi-jeongyi" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처의-정의"></a> 소프트웨어 아키텍처의 정의</h2><p>소프트웨어 아키텍처(software architecture)는 소프트웨어를 구성하는 요소와 요소간의 관계를 정의한것 입니다.<br>이는 소프트웨어의 전체적인 구성 관계인 구성 요소와 구성 요소간의 포함 관계, 호출 관계 등을 표현하여 소프트웨어 구성 전체를 조망하고 이해하는 데 매우 유용합니다.</p><h2 id="akitegceoyi-pyohyeon"><a href="#akitegceoyi-pyohyeon" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#아키텍처의-표현"></a> 아키텍처의 표현</h2><p>아키텍처는 시스템을 조망하고 소통의 도구이므로 이해할 수 있는 언어와 수준으로 작성되고 공유되야 합니다.<br>아키텍처를 표현하는 언어는 <code>UML(Unified Modeling Language)</code>와 같은 표준화 모델링 언어를 이용하여 작성해야합니다.</p><blockquote><p>표준된 언어를 사용하는 이유</p></blockquote><p>아키텍처를 표현하는 방법이 이를 표현하는 아키텍트(architect) 수준과 설계도 모습도 제각각으로 도식, 표기법으로 작성될 가능성이 높아 다르게 해석가능성이 있습니다.</p><p>하나의 아키텍처에는 <code>운영자, 아키텍트, 백엔드 개발자, 프론트엔드 개발자, 품질 담당자 등등</code> 각기 다른 아키텍처를 이해할 수 있는 상황이 발생하게 됩니다. 즉, 다양한 이해관계 각자의 관점에서 시스템을 바라봅니다.<br>아키텍처의 다양한 관점으로 접근하고 표현되는것을 <code>뷰(view)</code>라 일컫습니다.</p><blockquote><p>4+1 View(뷰)</p></blockquote><ol><li><p>논리 뷰(logic view)<br>소프트웨어를 구성하는 요소들의 관계 구조</p></li><li><p>프로세스 뷰(process view)<br>동적 흐름과 스레드(thread), 프로세스(process)등의 동시성 처리</p></li><li><p>구현 뷰(implementaion view)<br>논리적인 설계의 실제 구현된측면에서 소프트웨어의 구성과 구조</p></li><li><p>배치 뷰(deployment view)<br>소프트웨어 배치</p></li></ol><p>즉, 4가지의 모든 뷰를 포함하는 중심에는 <code>유스케이스 뷰(usecase view)</code></p><blockquote><p>View(뷰)란?</p></blockquote><p>시스템과 관련된 다양한 이해관계자들이 소프트웨어의 구조를 쉽게 이해할 수 있게 다양한 관점을 제시하고 표현한 명세</p><h2 id="akitegceoyi-yeoghal"><a href="#akitegceoyi-yeoghal" class="header-anchor">2.3. </a><a class="markdownIt-Anchor" href="#아키텍처의-역할"></a> 아키텍처의 역할</h2><p>소프트웨어 아키텍처는 폭넓은 시각과 사례를 기반으로 설계되어야합니다. 프로그램들을 연결하고 안정적으로 운영하기 위한 전체적인 뼈대를 설계하는 것이 무엇보다 중요합니다.<br>즉, 아키텍처는 구성 요소 간의 역할관계가 명확하고 효율적으로 구성될때 탄력적인 아키텍처가 되고, 시스템 품질속성으로 충족할 수 있게 설계되어야 합니다.</p><h1 id="sopeuteuweeo-akitegceo-seutail"><a href="#sopeuteuweeo-akitegceo-seutail" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처-스타일"></a> 소프트웨어 아키텍처 스타일</h1><h2 id="seutail"><a href="#seutail" class="header-anchor">3.1. </a><a class="markdownIt-Anchor" href="#스타일"></a> 스타일</h2><p>아키텍처의 스타일은 특정 제약 조건에서 아키텍처의 방향과 접근 방법을 말합니다. 즉, 어떠한 상황에 잘 어울릴 수 있는 방식이나 형태입니다.</p><h2 id="sopeuteuweeo-akitegceo-seutail"><a href="#sopeuteuweeo-akitegceo-seutail" class="header-anchor">3.2. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처-스타일-2"></a> 소프트웨어 아키텍처 스타일</h2><p>소프트웨어 아키텍처 스타일(software architecture style) 시스템 요건을 충족시키기 위한 제약 조건을 가진 아키텍처 측면의 접근방법입니다. 아키텍처 스타일과 아키텍처 패턴을 흔히 혼용해서 사용하지만 둘 사이에는 차이점이 존재합니다.</p><p>스타일은 상호아을 해결할 수 있는 접근 방법을 제시하지만, 정답을 제시해주지는 않습니다. 다만, 스타일에서 제시하는 접근 방법을 선택하면 그만큼 실패할 확률을 줄일 수 있습니다.<br>즉, 스타일은 접근방식을 제시하고 패턴은 구체적은 해결 전술을 제시한다고 생각하면 됩니다.</p><blockquote><p>아키텍처 스타일 예시</p></blockquote><p>아키텍처 -&gt; 아키텍처 스타일 -&gt; 시스템의 구조가 있으면 아키텍처 접근 방향을 제시하고 아키텍처를 어떻게 설계할지를 고민합니다.</p><blockquote><p>아키텍처 패턴</p></blockquote><p>메시지 전달이나 이벤트처리, Peer to Peer Patten, 이벤트-버스 패턴(Event Bus Pattern), Listener</p><h1 id="akitegceowa-akitegteu-yeoghalyi-byeonhwa"><a href="#akitegceowa-akitegteu-yeoghalyi-byeonhwa" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#아키텍처와-아키텍트-역할의-변화"></a> 아키텍처와 아키텍트 역할의 변화</h1><h2 id="monolriseueseo-maikeuroseobiseuro-byeonhwa"><a href="#monolriseueseo-maikeuroseobiseuro-byeonhwa" class="header-anchor">4.1. </a><a class="markdownIt-Anchor" href="#모놀리스에서-마이크로서비스로-변화"></a> 모놀리스에서 마이크로서비스로 변화</h2><blockquote><p>모놀리스한 아키텍처란?</p></blockquote><p>모든 업무로직이 하나의 애플리케이션 형태로 패키지(package)되어 서비스 되고, 애플리케이션에서 사용하는 데이터 또한 한곳에 모인 데이터를 참조하여 서비스하는 것이 일반적인 형태입니다.</p><p>제조회사에서는 약 1000개이상의 프로그램들이 단일 애플리케이션 패키지로 배포하고 돌아가기때문에 일부 프로그램을 수정하려고 하면 단일 애플리케이션이 다시 배포되어야 하는 번거로움과 시간적인 비용이 들어가게 됩니다.<br>즉, 관리구조의 편리함을 가지고 있지만 변화에 대한 대응이 힘들 수 있습니다.</p><p>Cloud, PaaS(Platform as a service)같은 플랫폼 서비스가 지금 수준으로 서비스 되지 않던 시절의 기준에서는 최적의 아키텍처 설계안으로 간주되었습니다.</p><p>하지만, 현재에는 서비스를 유연하고 안정적으로 운영할 수 있는 인프라 지원기술들(AWS, Azure)가 등장하면서 서비스 설계의 접근방법과 구축 운영 형태의 패러다임 전환이 일어나고 있습니다. 이때 나타나게 된 것이 마이크로 서비스입니다.</p><blockquote><p>마이크로 서비스</p></blockquote><p>기존 모놀리스와 달리 하나의 큰 애플리케이션을 아주 작은 애플리케이션으로 나누어 서비스하는 사싱입니다. 단일 애플리케이션이 가지는 단점을 해결하고 민첩성과 유연한 시스템을 구축할 수  있습니다.</p><h2 id="hoesaegjidaewa-akitegteu"><a href="#hoesaegjidaewa-akitegteu" class="header-anchor">4.2. </a><a class="markdownIt-Anchor" href="#회색지대와-아키텍트"></a> 회색지대와 아키텍트</h2><p>대내외 크고 작은 시스템 통합 프로젝트를 수행하다 보면 업무 영억이나 기술적인 측면에서 담당자가 애매하거나 복잡한 이해관계자들의 의견대립으로 결론나지 않은 상태 혹은 무관심한 상태로 방치되는 영역이 생기게 됩니다.<br>기술적인 측면에서 팀간의 틈을 메워 주는 역할자는 아키텍트 집단입니다 즉, 조직간에 발생할 수 있는 기술적 이슈와 연결에 대한 해결과 중재, 결과물의 통합과 프로젝트 경계 밖의 요소와 연결하는 역할을 잘 수행하여 프로젝트를 이끄는것들이 아키텍처 집단의 역할이 됩니다.</p><h2 id="akitegteu-yeoghalyi-sebunhwawa-byeonhwa"><a href="#akitegteu-yeoghalyi-sebunhwawa-byeonhwa" class="header-anchor">4.3. </a><a class="markdownIt-Anchor" href="#아키텍트-역할의-세분화와-변화"></a> 아키텍트 역할의 세분화와 변화</h2><p>아키텍트들은 프로젝트 모든 기술 요소에 이해수준이 높아야하며 소프트웨어와 하드웨어의 기술 구조를 이해하고 활용을 위한 가이드 배포를 작업하는 수행을 합니다. 모놀리스 형태의 아키텍처든 마이크로서비스 아키텍처구조에 대한 아키텍트 역할에 대한 구분이 필요한 이유중에 하나가 됩니다.</p><blockquote><p>역할의 세분화</p></blockquote><p>소프트웨어 아키텍트, 프론트엔드 아키텍트, 프레임워크 아키텍트, 데이터 아키텍트, 테크니컬 아키텍트, 인프라 아키텍트</p><h2 id="solrusyeon-akitegteu"><a href="#solrusyeon-akitegteu" class="header-anchor">4.4. </a><a class="markdownIt-Anchor" href="#솔루션-아키텍트"></a> 솔루션 아키텍트</h2><p>과거에는 아키텍트들이 했던 대부분의 작업 Saas(Software as a service), PaaS(Platform as a service), IaaS(Infrastructure as a service) 등 자동화된 기능으로 지원하게 되었습니다.</p><blockquote><p>예시</p></blockquote><ol><li>시스템 자원 구성, 할당, 관리, 모니터링, 소프트웨어 빌드, 통합, 배포 등의 일련의 프로세스들을 최근에는 자동화 시각화</li><li>인증 권한, 로깅, 모니터링 서비스기능 단위까지도 SaaS형태로 제공</li></ol><h1 id="gyeolron"><a href="#gyeolron" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#결론"></a> 결론</h1><p>아키텍트들도 기존 온프레미스(on-premise) 형태의 구축성 사업에서 요구하는 역할보다는 하루가 다르게 새롭게 만들어지는 기술 집약적 솔루션의 특징을 이해하고 조합할 줄 아는 능력이 요구되어지고 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sopeuteuweeo-akitegceoyi-ihae&quot;&gt;&lt;a href=&quot;#sopeuteuweeo-akitegceoyi-ihae&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/categories/msa/"/>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/tags/msa/"/>
    
  </entry>
  
  <entry>
    <title>01 마이크로서비스 아키텍처의 이해</title>
    <link href="http://gwanhyeon.github.io/MSA-20210204-msa-01-%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3-%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%E1%84%8B%E1%85%B4-%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2/"/>
    <id>http://gwanhyeon.github.io/MSA-20210204-msa-01-%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3-%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%E1%84%8B%E1%85%B4-%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2/</id>
    <published>2021-02-04T01:52:30.000Z</published>
    <updated>2021-02-04T06:32:31.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sopeuteuweeo-akitegceoyi-ihae"><a href="#sopeuteuweeo-akitegceoyi-ihae" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처의-이해"></a> 소프트웨어 아키텍처의 이해</h1><h1 id="sopeuteuweeo-akitegceoran-mueosilgga"><a href="#sopeuteuweeo-akitegceoran-mueosilgga" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처란-무엇일까"></a> 소프트웨어 아키텍처란 무엇일까?</h1><h2 id="sopeuteuweeo-akitegceoyi-jeongyi"><a href="#sopeuteuweeo-akitegceoyi-jeongyi" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처의-정의"></a> 소프트웨어 아키텍처의 정의</h2><p>소프트웨어 아키텍처(software architecture)는 소프트웨어를 구성하는 요소와 요소간의 관계를 정의한것 입니다.<br>이는 소프트웨어의 전체적인 구성 관계인 구성 요소와 구성 요소간의 포함 관계, 호출 관계 등을 표현하여 소프트웨어 구성 전체를 조망하고 이해하는 데 매우 유용합니다.</p><h2 id="akitegceoyi-pyohyeon"><a href="#akitegceoyi-pyohyeon" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#아키텍처의-표현"></a> 아키텍처의 표현</h2><p>아키텍처는 시스템을 조망하고 소통의 도구이므로 이해할 수 있는 언어와 수준으로 작성되고 공유되야 합니다.<br>아키텍처를 표현하는 언어는 <code>UML(Unified Modeling Language)</code>와 같은 표준화 모델링 언어를 이용하여 작성해야합니다.</p><blockquote><p>표준된 언어를 사용하는 이유</p></blockquote><p>아키텍처를 표현하는 방법이 이를 표현하는 아키텍트(architect) 수준과 설계도 모습도 제각각으로 도식, 표기법으로 작성될 가능성이 높아 다르게 해석가능성이 있습니다.</p><p>하나의 아키텍처에는 <code>운영자, 아키텍트, 백엔드 개발자, 프론트엔드 개발자, 품질 담당자 등등</code> 각기 다른 아키텍처를 이해할 수 있는 상황이 발생하게 됩니다. 즉, 다양한 이해관계 각자의 관점에서 시스템을 바라봅니다.<br>아키텍처의 다양한 관점으로 접근하고 표현되는것을 <code>뷰(view)</code>라 일컫습니다.</p><blockquote><p>4+1 View(뷰)</p></blockquote><ol><li><p>논리 뷰(logic view)<br>소프트웨어를 구성하는 요소들의 관계 구조</p></li><li><p>프로세스 뷰(process view)<br>동적 흐름과 스레드(thread), 프로세스(process)등의 동시성 처리</p></li><li><p>구현 뷰(implementaion view)<br>논리적인 설계의 실제 구현된측면에서 소프트웨어의 구성과 구조</p></li><li><p>배치 뷰(deployment view)<br>소프트웨어 배치</p></li></ol><p>즉, 4가지의 모든 뷰를 포함하는 중심에는 <code>유스케이스 뷰(usecase view)</code></p><blockquote><p>View(뷰)란?</p></blockquote><p>시스템과 관련된 다양한 이해관계자들이 소프트웨어의 구조를 쉽게 이해할 수 있게 다양한 관점을 제시하고 표현한 명세</p><h2 id="akitegceoyi-yeoghal"><a href="#akitegceoyi-yeoghal" class="header-anchor">2.3. </a><a class="markdownIt-Anchor" href="#아키텍처의-역할"></a> 아키텍처의 역할</h2><p>소프트웨어 아키텍처는 폭넓은 시각과 사례를 기반으로 설계되어야합니다. 프로그램들을 연결하고 안정적으로 운영하기 위한 전체적인 뼈대를 설계하는 것이 무엇보다 중요합니다.<br>즉, 아키텍처는 구성 요소 간의 역할관계가 명확하고 효율적으로 구성될때 탄력적인 아키텍처가 되고, 시스템 품질속성으로 충족할 수 있게 설계되어야 합니다.</p><h1 id="sopeuteuweeo-akitegceo-seutail"><a href="#sopeuteuweeo-akitegceo-seutail" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처-스타일"></a> 소프트웨어 아키텍처 스타일</h1><h2 id="seutail"><a href="#seutail" class="header-anchor">3.1. </a><a class="markdownIt-Anchor" href="#스타일"></a> 스타일</h2><p>아키텍처의 스타일은 특정 제약 조건에서 아키텍처의 방향과 접근 방법을 말합니다. 즉, 어떠한 상황에 잘 어울릴 수 있는 방식이나 형태입니다.</p><h2 id="sopeuteuweeo-akitegceo-seutail"><a href="#sopeuteuweeo-akitegceo-seutail" class="header-anchor">3.2. </a><a class="markdownIt-Anchor" href="#소프트웨어-아키텍처-스타일-2"></a> 소프트웨어 아키텍처 스타일</h2><p>소프트웨어 아키텍처 스타일(software architecture style) 시스템 요건을 충족시키기 위한 제약 조건을 가진 아키텍처 측면의 접근방법입니다. 아키텍처 스타일과 아키텍처 패턴을 흔히 혼용해서 사용하지만 둘 사이에는 차이점이 존재합니다.</p><p>스타일은 상호아을 해결할 수 있는 접근 방법을 제시하지만, 정답을 제시해주지는 않습니다. 다만, 스타일에서 제시하는 접근 방법을 선택하면 그만큼 실패할 확률을 줄일 수 있습니다.<br>즉, 스타일은 접근방식을 제시하고 패턴은 구체적은 해결 전술을 제시한다고 생각하면 됩니다.</p><blockquote><p>아키텍처 스타일 예시</p></blockquote><p>아키텍처 -&gt; 아키텍처 스타일 -&gt; 시스템의 구조가 있으면 아키텍처 접근 방향을 제시하고 아키텍처를 어떻게 설계할지를 고민합니다.</p><blockquote><p>아키텍처 패턴</p></blockquote><p>메시지 전달이나 이벤트처리, Peer to Peer Patten, 이벤트-버스 패턴(Event Bus Pattern), Listener</p><h1 id="akitegceowa-akitegteu-yeoghalyi-byeonhwa"><a href="#akitegceowa-akitegteu-yeoghalyi-byeonhwa" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#아키텍처와-아키텍트-역할의-변화"></a> 아키텍처와 아키텍트 역할의 변화</h1><h2 id="monolriseueseo-maikeuroseobiseuro-byeonhwa"><a href="#monolriseueseo-maikeuroseobiseuro-byeonhwa" class="header-anchor">4.1. </a><a class="markdownIt-Anchor" href="#모놀리스에서-마이크로서비스로-변화"></a> 모놀리스에서 마이크로서비스로 변화</h2><blockquote><p>모놀리스한 아키텍처란?</p></blockquote><p>모든 업무로직이 하나의 애플리케이션 형태로 패키지(package)되어 서비스 되고, 애플리케이션에서 사용하는 데이터 또한 한곳에 모인 데이터를 참조하여 서비스하는 것이 일반적인 형태입니다.</p><p>제조회사에서는 약 1000개이상의 프로그램들이 단일 애플리케이션 패키지로 배포하고 돌아가기때문에 일부 프로그램을 수정하려고 하면 단일 애플리케이션이 다시 배포되어야 하는 번거로움과 시간적인 비용이 들어가게 됩니다.<br>즉, 관리구조의 편리함을 가지고 있지만 변화에 대한 대응이 힘들 수 있습니다.</p><p>Cloud, PaaS(Platform as a service)같은 플랫폼 서비스가 지금 수준으로 서비스 되지 않던 시절의 기준에서는 최적의 아키텍처 설계안으로 간주되었습니다.</p><p>하지만, 현재에는 서비스를 유연하고 안정적으로 운영할 수 있는 인프라 지원기술들(AWS, Azure)가 등장하면서 서비스 설계의 접근방법과 구축 운영 형태의 패러다임 전환이 일어나고 있습니다. 이때 나타나게 된 것이 마이크로 서비스입니다.</p><blockquote><p>마이크로 서비스</p></blockquote><p>기존 모놀리스와 달리 하나의 큰 애플리케이션을 아주 작은 애플리케이션으로 나누어 서비스하는 사싱입니다. 단일 애플리케이션이 가지는 단점을 해결하고 민첩성과 유연한 시스템을 구축할 수  있습니다.</p><h2 id="hoesaegjidaewa-akitegteu"><a href="#hoesaegjidaewa-akitegteu" class="header-anchor">4.2. </a><a class="markdownIt-Anchor" href="#회색지대와-아키텍트"></a> 회색지대와 아키텍트</h2><p>대내외 크고 작은 시스템 통합 프로젝트를 수행하다 보면 업무 영억이나 기술적인 측면에서 담당자가 애매하거나 복잡한 이해관계자들의 의견대립으로 결론나지 않은 상태 혹은 무관심한 상태로 방치되는 영역이 생기게 됩니다.<br>기술적인 측면에서 팀간의 틈을 메워 주는 역할자는 아키텍트 집단입니다 즉, 조직간에 발생할 수 있는 기술적 이슈와 연결에 대한 해결과 중재, 결과물의 통합과 프로젝트 경계 밖의 요소와 연결하는 역할을 잘 수행하여 프로젝트를 이끄는것들이 아키텍처 집단의 역할이 됩니다.</p><h2 id="akitegteu-yeoghalyi-sebunhwawa-byeonhwa"><a href="#akitegteu-yeoghalyi-sebunhwawa-byeonhwa" class="header-anchor">4.3. </a><a class="markdownIt-Anchor" href="#아키텍트-역할의-세분화와-변화"></a> 아키텍트 역할의 세분화와 변화</h2><p>아키텍트들은 프로젝트 모든 기술 요소에 이해수준이 높아야하며 소프트웨어와 하드웨어의 기술 구조를 이해하고 활용을 위한 가이드 배포를 작업하는 수행을 합니다. 모놀리스 형태의 아키텍처든 마이크로서비스 아키텍처구조에 대한 아키텍트 역할에 대한 구분이 필요한 이유중에 하나가 됩니다.</p><blockquote><p>역할의 세분화</p></blockquote><p>소프트웨어 아키텍트, 프론트엔드 아키텍트, 프레임워크 아키텍트, 데이터 아키텍트, 테크니컬 아키텍트, 인프라 아키텍트</p><h2 id="solrusyeon-akitegteu"><a href="#solrusyeon-akitegteu" class="header-anchor">4.4. </a><a class="markdownIt-Anchor" href="#솔루션-아키텍트"></a> 솔루션 아키텍트</h2><p>과거에는 아키텍트들이 했던 대부분의 작업 Saas(Software as a service), PaaS(Platform as a service), IaaS(Infrastructure as a service) 등 자동화된 기능으로 지원하게 되었습니다.</p><blockquote><p>예시</p></blockquote><ol><li>시스템 자원 구성, 할당, 관리, 모니터링, 소프트웨어 빌드, 통합, 배포 등의 일련의 프로세스들을 최근에는 자동화 시각화</li><li>인증 권한, 로깅, 모니터링 서비스기능 단위까지도 SaaS형태로 제공</li></ol><h1 id="gyeolron"><a href="#gyeolron" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#결론"></a> 결론</h1><p>아키텍트들도 기존 온프레미스(on-premise) 형태의 구축성 사업에서 요구하는 역할보다는 하루가 다르게 새롭게 만들어지는 기술 집약적 솔루션의 특징을 이해하고 조합할 줄 아는 능력이 요구되어지고 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sopeuteuweeo-akitegceoyi-ihae&quot;&gt;&lt;a href=&quot;#sopeuteuweeo-akitegceoyi-ihae&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/categories/msa/"/>
    
    
      <category term="MSA" scheme="http://gwanhyeon.github.io/tags/msa/"/>
    
  </entry>
  
  <entry>
    <title>Redis 설치 및 명령어 정리</title>
    <link href="http://gwanhyeon.github.io/Database-20210131-redis-install-command/"/>
    <id>http://gwanhyeon.github.io/Database-20210131-redis-install-command/</id>
    <published>2021-01-30T16:17:34.000Z</published>
    <updated>2021-01-31T03:17:32.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-mac-os-redis"><a href="#1-mac-os-redis" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#1mac-os-redis"></a> 1.Mac OS Redis</h1><blockquote><p>Redis 설치하기</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$brew</span> install redis</span><br><span class="line"></span><br><span class="line">Warning: Treating redis as a formula. For the cask, use homebrew/cask/redis</span><br><span class="line">==&gt; Downloading https://homebrew.bintray.com/bottles/redis-6.0.9.catalina.bottle.tar.gz</span><br><span class="line">==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/673b1485f012e3c9a509c913d175e18451ddab50eca0</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; Pouring redis-6.0.9.catalina.bottle.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">To have launchd start redis now and restart at login:</span><br><span class="line">  brew services start redis</span><br><span class="line">Or, <span class="keyword">if</span> you don<span class="string">'t want/need a background service you can just run:</span></span><br><span class="line"><span class="string">  redis-server /usr/local/etc/redis.conf</span></span><br><span class="line"><span class="string">==&gt; Summary</span></span><br><span class="line"><span class="string">🍺  /usr/local/Cellar/redis/6.0.9: 13 files, 3.9MB</span></span><br></pre></td></tr></table></figure><p>다음과 같이 명령어를 진행하면 Redis설치가 진행됩니다. 아직 Homebrew가 없으신분들은 반드시 설치를 하셔야합니다.</p><blockquote><p>Redis가 설치된 경로</p></blockquote><p>Redis의 실행파일은 다음과 같은 경로에 저장됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/redis-server</span><br></pre></td></tr></table></figure><p>Redis 설정파일은 다음과 같은 경로에 저장됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/etc/redis.conf</span><br></pre></td></tr></table></figure><h1 id="2-redis-silhaenghagi"><a href="#2-redis-silhaenghagi" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#2-redis-실행하기"></a> 2. Redis 실행하기</h1><p>이제 brew를 통하여 Redis를 성공적으로 설치를 하였으니 Redis서버를 실행하여봅시다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$redis</span>-server</span><br></pre></td></tr></table></figure><p>다음과 같은 명령어를 사용하면</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">10529:C 31 Jan 2021 01:08:11.335 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">10529:C 31 Jan 2021 01:08:11.335 <span class="comment"># Redis version=6.0.9, bits=64, commit=00000000, modified=0, pid=10529, just started</span></span><br><span class="line">10529:C 31 Jan 2021 01:08:11.335 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span></span><br><span class="line">10529:M 31 Jan 2021 01:08:11.337 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">''</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">''</span>-._           Redis 6.0.9 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">''</span>-._</span><br><span class="line"> (    <span class="string">'      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|'</span>` _.-<span class="string">'|     Port: ----</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-'</span>    |     PID: ----</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">'    _.-'</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |           http://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span></span><br><span class="line">      `-._    `-.__.-<span class="string">'    _.-'</span></span><br><span class="line">          `-._        _.-<span class="string">'</span></span><br><span class="line"><span class="string">              `-.__.-'</span></span><br><span class="line"></span><br><span class="line">10529:M 31 Jan 2021 01:08:11.338 <span class="comment"># Server initialized</span></span><br><span class="line">10529:M 31 Jan 2021 01:08:11.338 * Loading RDB produced by version 6.0.9</span><br><span class="line">10529:M 31 Jan 2021 01:08:11.338 * RDB age 64 seconds</span><br><span class="line">10529:M 31 Jan 2021 01:08:11.338 * RDB memory usage when created 0.96 Mb</span><br><span class="line">10529:M 31 Jan 2021 01:08:11.338 * DB loaded from disk: 0.000 seconds</span><br><span class="line">10529:M 31 Jan 2021 01:08:11.338 * Ready to accept connections</span><br><span class="line">redis-cli</span><br><span class="line">^C10529:signal-handler (1612022976) Received SIGINT scheduling shutdown...</span><br><span class="line">10529:M 31 Jan 2021 01:09:36.132 <span class="comment"># User requested shutdown...</span></span><br><span class="line">10529:M 31 Jan 2021 01:09:36.132 * Saving the final RDB snapshot before exiting.</span><br><span class="line">10529:M 31 Jan 2021 01:09:36.135 * DB saved on disk</span><br><span class="line">10529:M 31 Jan 2021 01:09:36.135 <span class="comment"># Redis is now ready to exit, bye bye...</span></span><br></pre></td></tr></table></figure><p>다음과같은 하드디스크같은 그림이 뜨면서 Redis가 정상적으로 동작한것을 확인할 수 있습니다.</p><h1 id="3-redis-cli"><a href="#3-redis-cli" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#3-redis-cli"></a> 3. Redis-Cli</h1><p>이제 다음과 같이 서버가 동작하게 되었으므로, 해당 터미널은 띄워둔채 다른 터미널을 하나 키신후 다음과 같은 명령어를 진행합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><p>하나의 콘솔 cli창이 보여지게 되면서 이제 Redis관련 동작을 command로 제어할 수 있게됩니다.</p><h1 id="4-redis-command"><a href="#4-redis-command" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#4-redis-command"></a> 4. Redis Command</h1><blockquote><p>redis 키 생성 및 조회</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> gwan www.github.com</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; get gwan</span><br><span class="line"><span class="string">"www.github.com"</span></span><br></pre></td></tr></table></figure><blockquote><p>모든 키값 조회하기</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"gwan"</span></span><br></pre></td></tr></table></figure><blockquote><p>저장된 키값 조회</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$127</span>.0.0.1:6379&gt; keys *gw*</span><br><span class="line">1) <span class="string">"gwan"</span></span><br></pre></td></tr></table></figure><blockquote><p>키 존재여부 확인</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; exists gwan</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><blockquote><p>키 삭제하기</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; del gwan</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[15]&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><blockquote><p>키 만료시간 지정하기(Second)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; expire gwan 100</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p>키 만료시간 지정하기(Unix Time)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; expireat gwan 100</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; ttl gwan</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br></pre></td></tr></table></figure><blockquote><p>키 만료시간 삭제</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; persist gwan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p>키 만료시간 확인하기</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; expire gwan 1000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; ttl gwan</span><br><span class="line">(<span class="built_in">integer</span>) 997</span><br></pre></td></tr></table></figure><blockquote><p>키 타입 조회</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; <span class="built_in">type</span> gwan</span><br><span class="line">string</span><br></pre></td></tr></table></figure><blockquote></blockquote><blockquote><p>Redis 정보 조회</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:6.0.9</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:26c3229b35eb3beb</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Darwin 19.5.0 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:kqueue</span><br><span class="line">atomicvar_api:atomic-builtin</span><br><span class="line">gcc_version:4.2.1</span><br><span class="line">process_id:10758</span><br><span class="line">run_id:91ff9f67b95c54f394234f6004cffbe07960d2b2</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:1719</span><br><span class="line">uptime_in_days:0</span><br><span class="line">hz:10</span><br><span class="line">configured_hz:10</span><br><span class="line">lru_clock:1412238</span><br><span class="line">executable:/Users/kgh/redis-server</span><br><span class="line">config_file:</span><br><span class="line">io_threads_active:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_recent_max_input_buffer:16</span><br><span class="line">client_recent_max_output_buffer:0</span><br><span class="line">blocked_clients:0</span><br><span class="line">tracking_clients:0</span><br><span class="line">clients_in_timeout_table:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:1066368</span><br><span class="line">used_memory_human:1.02M</span><br><span class="line">used_memory_rss:901120</span><br><span class="line">used_memory_rss_human:880.00K</span><br><span class="line">used_memory_peak:1123120</span><br><span class="line">used_memory_peak_human:1.07M</span><br><span class="line">used_memory_peak_perc:94.95%</span><br><span class="line">used_memory_overhead:1019192</span><br><span class="line">used_memory_startup:1001536</span><br><span class="line">used_memory_dataset:47176</span><br><span class="line">used_memory_dataset_perc:72.77%</span><br><span class="line">allocator_allocated:1019776</span><br><span class="line">allocator_active:863232</span><br><span class="line">allocator_resident:863232</span><br><span class="line">total_system_memory:8589934592</span><br><span class="line">total_system_memory_human:8.00G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:0.85</span><br><span class="line">allocator_frag_bytes:18446744073709395072</span><br><span class="line">allocator_rss_ratio:1.00</span><br><span class="line">allocator_rss_bytes:0</span><br><span class="line">rss_overhead_ratio:1.04</span><br><span class="line">rss_overhead_bytes:37888</span><br><span class="line">mem_fragmentation_ratio:0.88</span><br><span class="line">mem_fragmentation_bytes:-118656</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:17456</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:libc</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:3</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1612023255</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:-1</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">rdb_last_cow_size:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line">aof_last_cow_size:0</span><br><span class="line">module_fork_in_progress:0</span><br><span class="line">module_fork_last_cow_size:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:1</span><br><span class="line">total_commands_processed:14</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">total_net_input_bytes:369</span><br><span class="line">total_net_output_bytes:18757</span><br><span class="line">instantaneous_input_kbps:0.00</span><br><span class="line">instantaneous_output_kbps:0.00</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">expired_stale_perc:0.00</span><br><span class="line">expired_time_cap_reached_count:0</span><br><span class="line">expire_cycle_cpu_milliseconds:49</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:1</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line">slave_expires_tracked_keys:0</span><br><span class="line">active_defrag_hits:0</span><br><span class="line">active_defrag_misses:0</span><br><span class="line">active_defrag_key_hits:0</span><br><span class="line">active_defrag_key_misses:0</span><br><span class="line">tracking_total_keys:0</span><br><span class="line">tracking_total_items:0</span><br><span class="line">tracking_total_prefixes:0</span><br><span class="line">unexpected_error_replies:0</span><br><span class="line">total_reads_processed:15</span><br><span class="line">total_writes_processed:14</span><br><span class="line">io_threaded_reads_processed:0</span><br><span class="line">io_threaded_writes_processed:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:4c355e7154a8a46cccffd4acfbe1e1ed5e5183d9</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.767543</span><br><span class="line">used_cpu_user:0.575956</span><br><span class="line">used_cpu_sys_children:0.000000</span><br><span class="line">used_cpu_user_children:0.000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line">cluster_enabled:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=1,expires=0,avg_ttl=0</span><br><span class="line">db15:keys=1,expires=1,avg_ttl=68029</span><br></pre></td></tr></table></figure><blockquote><p>Redis Database 변경</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$select</span> 1</span><br><span class="line"></span><br><span class="line">select 1~15</span><br><span class="line">해당 번호는 1~15 데이터베이스를 선택하겠다 라는 뜻입니다.</span><br></pre></td></tr></table></figure><p><em>주의할점:</em> select를 사용할때 1~15까지 진행하는 이유는 Redis는 하나의 인스턴스에 최대 16개의 데이터베이스를 가질 수 있습니다.</p><blockquote><p>auth 접속하기</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$redis</span>-cli</span><br><span class="line">127.0.0.1:6379&gt; auth 비밀번호입력</span><br></pre></td></tr></table></figure><h1 id="redis-myeongryeongeo-jeongri"><a href="#redis-myeongryeongeo-jeongri" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#redis-명령어-정리"></a> Redis 명령어 정리</h1><table><thead><tr><th>명령어</th><th>사용예시</th><th>기능설명</th></tr></thead><tbody><tr><td>del</td><td>del ${key}</td><td>키 삭제</td></tr><tr><td>exists</td><td>exists ${key}</td><td>키 존재여부</td></tr><tr><td>expire</td><td>expire ${key} ${second}</td><td>만료시간 지정 (초단위)</td></tr><tr><td>expireat</td><td>expireat $(key} ${unixtime}</td><td>만료시간 지정 (유닉스 시간)</td></tr><tr><td>get</td><td>get ${key}</td><td>해당 키의 값 출력</td></tr><tr><td>info</td><td>info</td><td>redis 정보 조회</td></tr><tr><td>keys</td><td>keys ${key_pattern}</td><td>패턴에 부합하는 키목록 출력</td></tr><tr><td>persist</td><td>persist ${key}</td><td>만료시간을 삭제</td></tr><tr><td>set</td><td>set ${key} ${value}</td><td>키와 데이터를 추가</td></tr><tr><td>ttl</td><td>ttl ${key}</td><td>만료시간 확인</td></tr><tr><td>type</td><td>type ${key}</td><td>해당 키의 타입 확인</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-mac-os-redis&quot;&gt;&lt;a href=&quot;#1-mac-os-redis&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1mac-os-redis&quot;&gt;&lt;/a&gt; 1.Mac
      
    
    </summary>
    
    
      <category term="Database" scheme="http://gwanhyeon.github.io/categories/database/"/>
    
    
      <category term="Redis" scheme="http://gwanhyeon.github.io/tags/redis/"/>
    
      <category term="Database" scheme="http://gwanhyeon.github.io/tags/database/"/>
    
      <category term="Command" scheme="http://gwanhyeon.github.io/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3/E Item 55 옵셔널반환은 신중히 하라</title>
    <link href="http://gwanhyeon.github.io/EffectiveJava-20210126-%EC%95%84%EC%9D%B4%ED%85%9C55-%EC%98%B5%EC%85%94%EB%84%90%EB%B0%98%ED%99%98%EC%9D%80-%EC%8B%A0%EC%A4%91%ED%9E%88%ED%95%98%EB%9D%BC/"/>
    <id>http://gwanhyeon.github.io/EffectiveJava-20210126-%EC%95%84%EC%9D%B4%ED%85%9C55-%EC%98%B5%EC%85%94%EB%84%90%EB%B0%98%ED%99%98%EC%9D%80-%EC%8B%A0%EC%A4%91%ED%9E%88%ED%95%98%EB%9D%BC/</id>
    <published>2021-01-26T12:01:34.000Z</published>
    <updated>2021-01-26T16:09:38.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="obsyeoneolbanhwaneun-sinjunghi-hara"><a href="#obsyeoneolbanhwaneun-sinjunghi-hara" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#옵셔널반환은-신중히-하라"></a> 옵셔널반환은 신중히 하라</h1><p>자바 8전에는 메서드가 특정조건에서 값을 반환할 수 없을때 취할 수 있는 선택지가 두가지가 있었다. 예외를 던지거나 null을 반환하는것입니다.</p><blockquote><p>예외</p></blockquote><p>예외의 경우는 스택 추적 전체를 캡처하므로 비용이 만만치 않습니다.</p><blockquote><p>null 반환</p></blockquote><p>null은 반환하면 이런 문제가 생기지 않지만 null을 반환할 수 있는 메서드를 호출할 때는 null이 반환될 일이 절대 없다고 확신하지 않는한) 별도의 null처리 코드를 추가해야합니다. null처리를 무시하고 반환된 null 값을 어딘가에 저장해두면 언젠가 NullPointerException이 발생할 수 있습니다.<br>즉, null을 반환하게 한 실제 원인과는 전혀 상관없는 코드일 경우입니다.</p><h1 id="jaba-8yi-deungjang"><a href="#jaba-8yi-deungjang" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#자바-8의-등장"></a> 자바 8의 등장</h1><p>Optional<t>는 null이 아닌 T타입 참조를 하나 담거나, 혹은 아무것도 담지 않을 수 있습니다. 아무것도 담지않은 옵셔널은 '비었다’라고 말하며 반대로 어떤값을 담은 옵셔녈은 비지않았다고 합니다. 옵셔널은 원소를 최대 1개 가질 수 있는 '불변’컬렉션입니다. Optional<t>가 Collection<t>를 구현하지는 않았지만, 원칙적으로는 그렇게 처리합니다.</t></t></t></p><p>보통은 T를 반환해야 하지만 특정 조건에서는 아무것도 반환하지 않아야할 때 T대신에 Optional<t>를 반환하도록 선언하면 됩니다. 그러면 유효한 반환값이 없을때는 빈 결과를 반환하는 메서드가 만들어집니다. 옵셔널을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null을 반환하는 메서드보다 오류 가능성이 적습니다.</t></p><h2 id="keolregsyeoneseo-coedaesgabseul-guhabnida-keolregsyeoni-bieosseumyeon-yeoereul-deonjibnida"><a href="#keolregsyeoneseo-coedaesgabseul-guhabnida-keolregsyeoni-bieosseumyeon-yeoereul-deonjibnida" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컬렉션에서-최댓값을-구합니다컬렉션이-비었으면-예외를-던집니다"></a> 컬렉션에서 최댓값을 구합니다(컬렉션이 비었으면 예외를 던집니다)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run Configuration -&gt; program arguement설정</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(args);</span><br><span class="line">    System.out.println(max(words));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 컬렉션에서 최댓값을 구한다 컬렉션이 비었으면 예외를 던진다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(Collection&lt;E&gt; c)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"empty Collection"</span>);</span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> || e.compareTo(result) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = Objects.requireNonNull(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="keolregsyeoneseo-coedaesgabseul-guhae-optionalro-banhwanhabnida"><a href="#keolregsyeoneseo-coedaesgabseul-guhae-optionalro-banhwanhabnida" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#컬렉션에서-최댓값을-구해-optionale로-반환합니다"></a> 컬렉션에서 최댓값을 구해 Optional<e>로 반환합니다.</e></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 컬렉션에서 최댓값을 구해 Optional&lt;E&gt;로 반환합니다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">Optional&lt;E&gt; <span class="title">max1</span><span class="params">(Collection&lt;E&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> || e.compareTo(result)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            result = Objects.requireNonNull(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>옵셔널 반환하도록 구현하기는 어렵지는 않지만 적절한 정적 팩터리를 사용해 옵셔널을 생성해주기만 하면됩니다. 이 코드에서는 두 가지 팩터리를 사용했습니다.</p><p>빈 옵셔널은 Optional.empty()로 만들고, 값이 든 옵셔널은 Optional.of(value)로 생성하였습니다. Optional.of(value)에 null을 넣으면 NullPointerException을 던집니다.</p><p>null값도 허용하는 옵셔널을 만드려면 Optional.ofNullable(value)를 사용하면 됩니다. <code>옵셔널을 반환하는 메서드에서는 절대 null을 반환하면 안됩니다.</code> (취지에 어긋납니다)</p><p>스트림의 종단 연산중 상당수가 옵셔널을 반환합니다. 앞의 max메서드를 스트림 버전으로 다시 작성하면 Stream의 max연산이 우리에게 필요한 옵셔널을 생성해줄 것입니다.</p><h2 id="keolregsyeoneseo-coedaesgabseul-guhae-optionalro-banhwanhabnida-stream"><a href="#keolregsyeoneseo-coedaesgabseul-guhae-optionalro-banhwanhabnida-stream" class="header-anchor">2.3. </a><a class="markdownIt-Anchor" href="#컬렉션에서-최댓값을-구해-optionale로-반환합니다-stream"></a> 컬렉션에서 최댓값을 구해 Optional<e>로 반환합니다. (Stream)</e></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 컬렉션에서 최댓값을 구해 Optional&lt;E&gt;로 반환합니다. (Stream)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">Optional&lt;E&gt; <span class="title">max2</span><span class="params">(Collection&lt;E&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.stream().max(Comparator.naturalOrder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 스트림 형식으로 간단하게 처리할 수 잇으며 Null을 반환하거나 예외를 던지는 대신 옵셔널 반환을 선택하는 기준은 무엇일까요?</p><p><code>옵셔널은 검사 예외와 취지가 비슷합니다.</code> 즉, 반환값이 없을 수도 있음을 API 사용자에게 명확하게 알려주며 비검사 예외를 던지거나 null을 반환한다면 API 사용자가 그 사실을 인지하지 못해 끔찍한 결과로 이어질 수 있습니다. 하지만 검사 예외를 던지면 클라이언트에서는 반드시 이에 대처하는 코드를 작성해넣어야합니다.</p><p>비슷하게, 메서드가 옵셔널을 반환한다면 클라이언트는 값을 받지 못했을때 취할 행동을 선택해야합니다.</p><h2 id="obsyeoneol-hwalyong-1-gibongabseul-jeonghaedul-su-issda"><a href="#obsyeoneol-hwalyong-1-gibongabseul-jeonghaedul-su-issda" class="header-anchor">2.4. </a><a class="markdownIt-Anchor" href="#옵셔널-활용-1-기본값을-정해둘-수-있다"></a> 옵셔널 활용 1- 기본값을 정해둘 수 있다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 코드 55-4 옵셔널 활용 1 - 기본값을 정해둘 수 있습니다.</span></span><br><span class="line">String lastWordInLexicon = max2(words).orElse(<span class="string">"단어 없음..."</span>);</span><br></pre></td></tr></table></figure><p>상황에 맞는 예외를 던질 수 있으며 다음 코드에서 실제 예외가 아니라 예외 팩터리를 건넨것에 주목해야합니다. 이렇게 하면 예외가 실제로 발생하지 않는한 예외 생성 비용은 들지 않게 됩니다.</p><h2 id="obsyeoneol-hwalyong-2-weonhaneun-yeoe-gabseul-deonjil-su-issseubnida"><a href="#obsyeoneol-hwalyong-2-weonhaneun-yeoe-gabseul-deonjil-su-issseubnida" class="header-anchor">2.5. </a><a class="markdownIt-Anchor" href="#옵셔널-활용-2-원하는-예외-값을-던질-수-있습니다"></a> 옵셔널 활용 2 - 원하는 예외 값을 던질 수 있습니다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 원하는 </span></span><br><span class="line">Toy myToy = max2(toys).orElseThrow(words).orElseThrow(TemperTantrumException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>옵셔널이 항상 값이 채워져있다고 확신한다면 그냥 바로 꺼내 사용하는 선택지도 있습니다. 다만 잘못 판단한 것이라면 NoSuchElementException이 발생하게 됩니다.</p><h2 id="obsyeoneol-hwalyong-hangsang-gabsi-caeweojyeo-issdago-gajeonghabnida"><a href="#obsyeoneol-hwalyong-hangsang-gabsi-caeweojyeo-issdago-gajeonghabnida" class="header-anchor">2.6. </a><a class="markdownIt-Anchor" href="#옵셔널-활용-항상-값이-채워져-있다고-가정합니다"></a> 옵셔널 활용 - 항상 값이 채워져 있다고 가정합니다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element lastNobleGas = max2(Elements.NOBLE_GASES).get();</span><br></pre></td></tr></table></figure><p>기본값을 설정하는 비용이 아주 커서 부담이 될 수 있습니다. 그럴때는 Supplier<t>를 인수로 받는 orElseGet을 사용하면 값이 처음 필요할때 Supplier<t>를 사용해 생성하므로 초기 설정 비용을 낮출 수 있습니다.</t></t></p><p>filter, map, flatMap, ifPresent메서드는 기본 메서드로 처리하기 어려워보인다면 API문서를 참조해 이 고급 메서드들이 문제를 해결해줄 수 있을지 검토해보면 됩니다.</p><p>isPresent메서드는 안전 밸브역할의 메서드로, 옵셔널이; 채워져있으면 true, 비어져있으면 false를 반환합니다. 이 메서드로는 원하는 모든 작업을 수행할 수 있지만 신중히 사용해야합니다.</p><p>실제로 isPresent를 쓴 코드 중 상당수는 앞서 언급한 메서드들로 대체할 수 있으며, 그렇게 하면 더 짧고 명확하고 용법에 맞는 코드가 됩니다.</p><h2 id="ispresent-meseodeu"><a href="#ispresent-meseodeu" class="header-anchor">2.7. </a><a class="markdownIt-Anchor" href="#ispresent-메서드"></a> isPresent 메서드</h2><blockquote><p>java 9</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ProcessHandle ph = <span class="keyword">new</span> ProcessHandle() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">pid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;ProcessHandle&gt; <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;ProcessHandle&gt; <span class="title">children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;ProcessHandle&gt; <span class="title">descendants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Info <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;ProcessHandle&gt; <span class="title">onExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsNormalTermination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">destroyForcibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ProcessHandle other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Optional&lt;ProcessHandle&gt; parentProcess = ph.parent();</span><br><span class="line">System.out.println(<span class="string">"부모 PID"</span> + (parentProcess.isPresent() ? String.valueOf(parentProcess.get().pid()) : <span class="string">"N/A"</span>));</span><br><span class="line">System.out.println(<span class="string">"부모 PID"</span> + (ph.parent().map(h -&gt; String.valueOf(h.pid())).orElse(<span class="string">"N/A"</span>)));</span><br></pre></td></tr></table></figure><p>위 코드는 Optional의 map을 사용하여 다음처럼 다듬을 수 있습니다.</p><p>스트림을 사용한다면 옵셔널들을 Stream(Optional<t>&gt; 로 받아서 그중 채워진 옵셔널들에서 값을 뽑아 Stream<t>에 건네 담아 처리하는 경우가 드물지 않습니다.</t></t></p><blockquote><p>java8</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 자바8 구현 </span></span><br><span class="line">streamOfOptionals</span><br><span class="line">        .filter(Optional::isPresent)</span><br><span class="line">        .map(Optional::get)</span><br></pre></td></tr></table></figure><p>옵셔널에 값이 있다면 (Optional::isPresent) 그 값을 꺼내 (Optional::get) 스트림에 매핑합니다.<br>자바9에서는 Optional에 stream()메서드가 추가되었습니다. 이 메서드는 Optional을 stream으로 변환해주는 어댑터 이며 옵셔널에 값이 있으면 그 값을 원소로 담은 스트림으로, 값이 없다면 빈 스트림으로 변환합니다. 이를 stream의 flatMap메서드와 조합하면 명료하게 바꿀 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">streamOfOptionals</span><br><span class="line">    .flatMap(Optional::stream)</span><br></pre></td></tr></table></figure><p>반환 값으로 옵셔널을 사용한다고 무조건 득이되는것이 아닙니다. 컬렉션, 스트림, 배열, 옵셔널과 같은 컨테이너 타입은 옵셔널로 감싸면 안됩니다. 빈 Optional&lt;List<t>&gt;를 반환하기 보다는 빈 List<t>를 반환하는게 더 좋습니다. 빈 컨테이너를 반환하게 되면 클라이언트에서 옵셔널 처리 코드를 넣지 않아도 됩니다.</t></t></p><ul><li>참고<br><a href="http://ProcessHandle.Info" target="_blank" rel="noopener">ProcessHandle.Info</a> 인터페이스의 arguements 메서드는 Optional&lt;String[]&gt;를 반환하는데, 이는 예외적인 경우이니 따라하지 않도록해야합니다.</li></ul><h2 id="eoddeohan-gyeongue-banhwantaibeul-tdaesin-optionalro-seoneonhaeyahalggayo"><a href="#eoddeohan-gyeongue-banhwantaibeul-tdaesin-optionalro-seoneonhaeyahalggayo" class="header-anchor">2.8. </a><a class="markdownIt-Anchor" href="#어떠한-경우에-반환타입을-t대신-optionalt로-선언해야할까요"></a> 어떠한 경우에 반환타입을 T대신 Optional<t>로 선언해야할까요?</t></h2><p>결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional<t>를 반환하도록 합니다.</t></p><p>박싱된 기본 타입을 담는 옵셔널은 기본 타입 자체보다 무거울 수밖에 없으며 자바 API설계자는 int, long, double 전용 옵셔널 클래스들을 준비해놨습니다. 바로 OptionalInt, OptionalLong, OptionalDouble입니다. 이 옵셔널들도 Optional<t>가 제공하는 메서드를 거의 다 제공하게 됩니다.</t></p><p>결과적으로 박싱도니 기본 타입을 담은 옵셔널을 반환하는일은 없도록 해야합니다.</p><h2 id="obsyeoneoleul-maebyi-gabseuro-sayonghaji-malja"><a href="#obsyeoneoleul-maebyi-gabseuro-sayonghaji-malja" class="header-anchor">2.9. </a><a class="markdownIt-Anchor" href="#옵셔널을-맵의-값으로-사용하지-말자"></a> 옵셔널을 맵의 값으로 사용하지 말자</h2><p>옵셔널을 맵의 값으로 사용하면 절대안됩니다. 키 자체가 없는 경우나 다른키는 있지만 그 키가 속이 빈 옵셔널인 경우가 있을 수 있기때문에 혼란만 가중시킬 수 있습니다.</p><p>즉, 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없습니다.</p><h2 id="obsyeoneoleul-inseuteonseu-pildeue-jeojanghaeduneunge-pilyohan-gyeongu"><a href="#obsyeoneoleul-inseuteonseu-pildeue-jeojanghaeduneunge-pilyohan-gyeongu" class="header-anchor">2.10. </a><a class="markdownIt-Anchor" href="#옵셔널을-인스턴스-필드에-저장해두는게-필요한-경우"></a> 옵셔널을 인스턴스 필드에 저장해두는게 필요한 경우?</h2><p>아이템2의 NutritionFacts 클래스의 예제를 보면 선택적 필드의 게터 메서드들이 옵셔널을 반환해주면 좋습니다. 따라서, 이럴때는 필드 자체를 옵셔널도 선언하는것도 좋은 방법중 하나입니다.</p><h1 id="haegsim-jeongri"><a href="#haegsim-jeongri" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#핵심-정리"></a> 핵심 정리</h1><p>값을 반환하지 못할 가능성이 있고, 호출할때마다 반환값이 없을 가능성을 염두하는 메서드라면 옵셔널을 반환해야 할 상황일 수도 있습니다. 하지만, 옵셔널 반환에는 성능저하가 뒤따르니, 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있습니다. 그리고 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드뭅니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;obsyeoneolbanhwaneun-sinjunghi-hara&quot;&gt;&lt;a href=&quot;#obsyeoneolbanhwaneun-sinjunghi-hara&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gwanhyeon.github.io/categories/java/"/>
    
    
      <category term="EffectiveJava3/E" scheme="http://gwanhyeon.github.io/tags/effectivejava3-e/"/>
    
      <category term="Optional" scheme="http://gwanhyeon.github.io/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>Network HTTP(HyperTextTransferProtocal) API 설계</title>
    <link href="http://gwanhyeon.github.io/Network-20210126-network-07-http-api/"/>
    <id>http://gwanhyeon.github.io/Network-20210126-network-07-http-api/</id>
    <published>2021-01-26T07:27:03.000Z</published>
    <updated>2021-01-26T08:43:12.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="api-uri-uniform-resource-identifier-seolgye"><a href="#api-uri-uniform-resource-identifier-seolgye" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#api-uriuniform-resource-identifier-설계"></a> API URI(Uniform Resource Identifier) 설계</h1><h2 id="resource-risoseu-ran"><a href="#resource-risoseu-ran" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#resource리소스란"></a> Resource(리소스)란?</h2><p>API URI설계에서 중요한것은 리소스의 식별입니다.<br>리소스(Resource)라고 하는것은 단순히 조회하고 수정 등록하는것을 일컫는 말이 아니라 만약 멤버의 정보를 조회한다고 했을때 멤버의 정보를 조회하는것이 리소스가 아니라 멤버라는 자체가 리소스(Resource)라고 할 수 있습니다.</p><h2 id="risoseu-sigbyeol-bangsig"><a href="#risoseu-sigbyeol-bangsig" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#리소스-식별-방식"></a> 리소스 식별 방식</h2><p>멤버의 조회,생성,수정,삭제의 의미가 아니라 멤버자체만을 리소스로 식별하고 회원 리소스를 URI에 매핑하면 됩니다.</p><ul><li>멤버 목록조회<br>/members</li><li>멤버 개별조회<br>/members/{id}</li><li>멤버 등록<br>/members/{id}</li><li>멤버 수정<br>/members/{id}</li><li>멤버 삭제<br>/members/{id}</li></ul><p>해당 5개의 API가 있다고 가정해보겠습니다. 여기서도 가장 중요한것은 리소스를 식별하는 방식입니다.</p><p>URI는 리소스만 식별하고 리소스와 리소스를 대상으로 하는 행위를 분리하여 URI를 설계를 진행합니다.</p><p>리소스: 멤버(명사)<br>행위: 목록조회, 개별조회, 등록, 수정, 삭제(동사)</p><h1 id="http-meseodeu"><a href="#http-meseodeu" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#http-메서드"></a> HTTP 메서드</h1><h2 id="http-method-jongryu"><a href="#http-method-jongryu" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#http-method-종류"></a> HTTP Method 종류</h2><ol><li>GET: 리소스를 조회합니다.</li><li>POST: 요청 데이터 처리, 주로 등록에 사용합니다.</li><li>PUT: 리소스를 대체하고 리소스가 없다면 생성시킵니다.</li><li>PATCH: 리소스를 부분 변경합니다.</li><li>DELETE: 리소스를 삭제합니다.</li></ol><h2 id="http-gita-meseodeu-jongryu"><a href="#http-gita-meseodeu-jongryu" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#http-기타-메서드-종류"></a> HTTP 기타 메서드 종류</h2><ol><li>HEAD: GET과 유사하지만 메시지부분을 제외 하고, 상태 줄과 헤더만 반환합니다.</li><li>OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명합니다. (CORS)</li><li>CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정합니다.</li><li>TRACE: 대상 리소스에 대한 경로에 따라 메시지 루프백 테스트를 수행합니다.</li></ol><h1 id="get-meseodeu"><a href="#get-meseodeu" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#get-메서드"></a> GET 메서드</h1><ol><li>리소스를 조회합니다.</li><li>서버에 전달하고 싶은 데이터는 쿼리 파라미터(쿼리스트링)을 통해서 전달됩니다.</li><li>메시지 바디를 사용하여 데이터를 전송할 수 있지만 지원하지 않는곳이 많아 권장하지않는 방식입니다. 최근에는 허용이 되었지만 실무에서는 잘 사용되지 않는 방식입니다.</li></ol><h1 id="post-meseodeu"><a href="#post-meseodeu" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#post-메서드"></a> POST 메서드</h1><p>POST메서드는 대상리소스가 리소스의 고유 한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 하는 요청입니다.</p><ol><li>요청 데이터를 처리합니다.</li><li>메시지 바디를 통하여 서버로 요청 데이터를 전달합니다.</li><li>서버는 요청 데이터를 처리하고 메시지 바디를 통해서 들어온 데이터를 처리하는 모든 기능을 수행합니다.</li><li>주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용됩니다.</li></ol><blockquote><p>POST가 사용되는 기능</p></blockquote><ul><li><p>HTML양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공합니다.<br>(회원가입,주문)</p></li><li><p>게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그릅에 메시지를 게시합니다.<br>(글쓰기, 댓글달기)</p></li><li><p>서버가 아직 식별하지 않은 새 리소스를 생성합니다.<br>(신규주문)</p></li><li><p>기존 자원에 데이터 추가<br>(문서에 내용 추가하기)</p></li></ul><p>즉, 이 리소스 URI에 POST요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야합니다.</p><blockquote><p>POST 정리</p></blockquote><ol><li><p>새 리소스를 생성합니다.(등록)<br>서버가 아직 식별하지 않은 새 리소스를 생성합니다.</p></li><li><p>요청 데이터 처리할때 사용됩니다.<br>데이터 생성하거나 변경을 넘어서 프로세스를 변경해야할 경우 POST를 사용합니다.<br>결제 -&gt; 주문 -&gt; 완료와 같은 프로세스의 상태가 변경되는 경우에 사용합니다.<br>POST의 결과로 새로운 리소스가 생성되지 않는 경우도 있습니다. 컨트롤 URI라고 하며 동사가 포함된것들로 컨트롤되어집니다.</p></li><li><p>다른 메서드로 처리가 애매한 경우에 사용됩니다.<br>JSON 데이터 형식으로 데이터를 넘길때 GET 메서드를 사용하기 어려운 경우 POST를 사용합니다.</p></li></ol><h1 id="put-meseodeu"><a href="#put-meseodeu" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#put-메서드"></a> PUT 메서드</h1><ol><li><p>리소스를 대체합니다. 대체한다는 의미는 리소스가 있으면 대체하고 리소스가 없으면 리소스를 생성합니다. 즉, 리소스를 덮어버리게 됩니다.</p></li><li><p>클라이언트가 리소스를 식별합니다. 클라이언트가 리소스 위치를 알고 URI를 지정합니다.<br>(POST와 차이점)</p></li></ol><h1 id="patch-meseodeu"><a href="#patch-meseodeu" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#patch-메서드"></a> PATCH 메서드</h1><ul><li>리소스를 부분만 교체합니다.</li></ul><h1 id="delete-meseodeu"><a href="#delete-meseodeu" class="header-anchor">7. </a><a class="markdownIt-Anchor" href="#delete-메서드"></a> DELETE 메서드</h1><ul><li>리소스를 제거합니다.</li></ul><h1 id="http-meseodeuyi-sogseong"><a href="#http-meseodeuyi-sogseong" class="header-anchor">8. </a><a class="markdownIt-Anchor" href="#http-메서드의-속성"></a> HTTP 메서드의 속성</h1><ol><li><p>안전(Safe Methods)<br>GET같은 경우는 안전하며 POST,PUT과 같은 변경이 많은 것들은 안전하지 않습니다. 호출해도 리소스를 변경하지 않습니다. 안전은 리소스만 고려합니다.</p></li><li><p>멱등(Idempotent Methods)<br>여러번 호출해도 결과는 같아야합니다. PUT을 호출하여 서버응답 호출을 통하여 재시도 할지 안할지를 확인할 수 있습니다. 즉, 자동 복구 매커니즘에서 많이 활용됩니다.</p></li></ol><p>만약, 재요청 중간에 다른 곳에서 리소스를 변경하게 된다면 멱등성은 외부 요인으로 중간에 리소스가 변경되는것 까지 고려하지 않습니다.</p><ul><li>멱등메서드<br>GET:여러번 조회하든 결과가 같습니다.<br>PUT: 결과를 대체하여 여러번 요청해도 최종 결과는 같습니다.<br>DELETE: 결과를 삭제합니다. 같은 요청을 여러번 해도 삭제된 결과는 같습니다.</li></ul><p>POST: 멱등성을 가진 메서드가 아닙니다. 두번 호출시 주문 중복이나 결제 중복이 발생할 수 있습니다.</p><ol start="3"><li>캐시가능(Cacheable Methods)</li></ol><ul><li>응답 결과 리소스를 캐시해서 사용할 수 있습니다. (GET, HEAD, POST, PATCH)</li><li>GET,HEAD정도만 캐시로 사용하고 POST, PATCH같은 경우는 본문 내용까지 캐싱을 진행해야하기 때문에 주로 GET,HEAD를 사용합니다.</li></ul><h1 id="keulraieonteu-seobeo-deiteo-jeondal-bangsig-2gaji"><a href="#keulraieonteu-seobeo-deiteo-jeondal-bangsig-2gaji" class="header-anchor">9. </a><a class="markdownIt-Anchor" href="#클라이언트-서버-데이터-전달-방식-2가지"></a> 클라이언트 서버 데이터 전달 방식 2가지</h1><ol><li>쿼리 파라미터를 통한 데이터 전송</li></ol><ul><li>GET, 정렬 필터 검색어 처리를 할때 사용됩니다.</li></ul><ol start="2"><li>메시지 바디를 통한 데이터 전송</li></ol><ul><li>POST, PUT, PATCH를 사용하며 리소스 등록이나 리소스 변경에 사용됩니다.</li></ul><blockquote><p>데이터 전달시 상황</p></blockquote><ol><li><p>정적 데이터 조회<br>이미지, 정적 텍스트 문서</p></li><li><p>동적 데이터 조회<br>주로 검색이나 게시판 목록에서 정렬필터에 사용됩니다(검색어)</p></li><li><p>HTML Form을 통한 데이터 전송<br>회원 가입이나 상품주문, 데이터 변경이 발생하는곳에 사용됩니다.</p></li><li><p>HTTP API를 통한 데이터 전송<br>회원 가입이나 상품주문 데이터변경시에 사용되고 서버간 통신이나, 클라이언트, 웹클라이언트 통신에 주로 사용됩니다. (Ajax, axios)</p></li></ol><h1 id="jeongjeog-deiteo-johoesi"><a href="#jeongjeog-deiteo-johoesi" class="header-anchor">10. </a><a class="markdownIt-Anchor" href="#정적-데이터-조회시"></a> 정적 데이터 조회시</h1><ol><li>이미지나 정적 텍스트 문서에 사용됩니다.</li><li>조회는 주로 GET을 사용합니다.</li><li>정적 데이터는 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능합니다.</li></ol><h1 id="dongjeog-deiteo-johoe"><a href="#dongjeog-deiteo-johoe" class="header-anchor">11. </a><a class="markdownIt-Anchor" href="#동적-데이터-조회"></a> 동적 데이터 조회</h1><p>쿼리 파라미터를 기반으로 정렬필터를 통하여 결과를 동적으로 생성하는 경우가 있습니다.</p><ol><li>검색, 목록에서 정렬 필터 및 검색어 등에 사용됩니다.</li><li>조회 조건을 줄여주는 필터나 조회 결과를 정렬하는 정렬 조건에 주로 사용됩니다.</li><li>조회는 주로 GET을 사용하고 쿼리파라미터를 통하여 데이터를 전달합니다. 메시지바디를 통하여 가능하지만 실무에서는 권장하지 않는 방식입니다.</li></ol><h1 id="html-from-deiteo"><a href="#html-from-deiteo" class="header-anchor">12. </a><a class="markdownIt-Anchor" href="#html-from-데이터"></a> HTML From 데이터</h1><ol><li>HTML Form Submit시에는 보통 POST전송을 진행합니다.</li></ol><ul><li>가입, 주문, 변경</li></ul><ol start="2"><li>Content-Type: application/x-www-form-urlencoded</li></ol><ul><li>form의 내용을 메시지 바디를 통하여 전송합니다. (쿼리파라미터)</li><li>전송 파라미터를 url encoding 처리합니다.<br>kgh -&gt; kgh%A%B%C%D%E%F%</li></ul><ol start="3"><li>HTML Form GET 전송 가능</li><li>Content-Type: multipart/form-data</li></ol><ul><li>파일 업로드 같은 바이너리 데이터 전송시 사용합니다.</li><li>다른 종류의 여러 파일의 폼 내용과 함께 전송이 가능합니다(multipart)</li></ul><ol start="5"><li>HTML Form전송은 GET,POST만 지원</li></ol><h1 id="http-api-deiteo-jeonsong"><a href="#http-api-deiteo-jeonsong" class="header-anchor">13. </a><a class="markdownIt-Anchor" href="#http-api-데이터-전송"></a> HTTP API 데이터 전송</h1><ol><li>서버간 통신</li></ol><ul><li>백엔드 시스템 통신(OPEN API)</li></ul><ol start="2"><li>앱 클라이언트</li></ol><ul><li>IOS, Android</li></ul><ol start="3"><li>웹 클라이언트</li></ol><ul><li>HTML에서 Form전송 대신 자바스크립트 통신(axios, ajax)</li></ul><ol start="4"><li>메시지 바디를 통하여 메시지 전송</li></ol><ul><li>POST,PUT,PATCH를 주로 사용합니다.</li></ul><ol start="5"><li>GET: 조회, 쿼리파라미터로 데이터전달</li></ol><ul><li>Content-Type: application/json 주로 사용</li><li>TEXT, XML, JSON</li></ul><h1 id="http-api-seolgye"><a href="#http-api-seolgye" class="header-anchor">14. </a><a class="markdownIt-Anchor" href="#http-api-설계"></a> HTTP API 설계</h1><ol><li>HTTP API 컬렉션</li></ol><ul><li>POST 기반 등록 및 회원관리 API</li></ul><ol start="2"><li>HTTP API 스토어</li></ol><ul><li>PUT 기반등록으로 진행되고 정적 컨텐츠나 원격 파일 관리에 사용됩니다.</li></ul><ol start="3"><li>HTML FORM</li></ol><ul><li>웹 페이지 회원 관리에 사용되며 GET,POST Method만 지원됩니다.</li></ul><h1 id="membeo-gwanri-siseutem-yesi"><a href="#membeo-gwanri-siseutem-yesi" class="header-anchor">15. </a><a class="markdownIt-Anchor" href="#멤버-관리-시스템-예시"></a> 멤버 관리 시스템 예시</h1><p>POST기반 멤버 관리 시스템</p><p>목록 /members :GET<br>등록 /members :POST<br>조회 /members/{id} :GET<br>수정 /members/{id} : PATCH, PUT,POST<br>리소스 덮는게 가능하면 PUT, 부분 교체하면 PATCH, 그외 POST<br>삭제 /members/{id} : DELETE</p><blockquote><p>POST 신규 자원 등록의 특징</p></blockquote><ol><li>클라이언트는 등록될 리소스의 URI의 정보를 모릅니다.</li></ol><ul><li>POST /members</li></ul><ol start="2"><li>서버가 새로 등록된 리소스 URI를 생성해줍니다.</li></ol><ul><li>HTTP/1.1 201 Created</li><li>Location: /membmer/1</li></ul><ol start="3"><li>컬렉션(Collection)</li></ol><ul><li>서버가 관리하는 리소스 디렉토리이며 리소스의 URI를 생성하고 관리합니다.</li><li>컬렉션 예: /members</li></ul><h1 id="pail-gwanri-siseutem-yesi"><a href="#pail-gwanri-siseutem-yesi" class="header-anchor">16. </a><a class="markdownIt-Anchor" href="#파일-관리-시스템-예시"></a> 파일 관리 시스템 예시</h1><p>PUT 기반 등록 시스템</p><p>목록 GET /files<br>조회 GET /files/{filename}<br>등록 PUT /files/{filename}<br>삭제 DELETE /files/{filename}<br>대량 등록 POST /files</p><blockquote><p>PUT 신규 자원 등록</p></blockquote><ol><li>클라이언트가 리소스 URI를 알고 있어야합니다.</li></ol><ul><li>등록 PUT /files/{filename}</li><li>PUT /files/hello.jpg</li></ul><ol start="2"><li>클라이언트가 직접 리소스의 URI를 지정합니다.</li><li>스토어(Store)</li></ol><ul><li>클라이언트가 관리하는 리소스 저장소이며 리소스의 URI를 알고 관리합니다.</li><li>스토어 예: /files</li></ul><h1 id="html-form-sayongsi-seolgye"><a href="#html-form-sayongsi-seolgye" class="header-anchor">17. </a><a class="markdownIt-Anchor" href="#html-form-사용시-설계"></a> HTML FORM 사용시 설계</h1><p>목록 GET /members<br>등록 폼 GET /members/new<br>등록 POST /members/new(보통 등록폼과 맞추어준다), /members<br>조회 GET /members/{id}<br>수정 폼 GET /members/{id}/edit<br>수정 POST /members/{id}/edit, /members/{id}<br>삭제 /members/{id}/delete</p><blockquote><p>특징</p></blockquote><ol><li>HTML FORM GET, POST만 지원</li><li>컨트롤 URI<br>GET,POST 제약조건을 가지고 있으며 이러한 제약을 해결하기 위해 동사로 된 리소스 경로를 사용합니다.  POST /new, /edit, /delete가 컨트롤 URI로 사용되며 HTTP메서드로 해결하기 애매한 경우 사용됩니다. (HTTP API를 포함합니다)</li></ol><blockquote><p>HTTP 설계 정리</p></blockquote><ol><li><p>HTTP API 컬렉션(서버)<br>POST기반으로 등록되며 서버가 리소스 URI를 결정합니다.</p></li><li><p>HTTP API 스토어(클라)<br>PUT기반 등록되며 클라이언트가 리소스 URI를 결정합니다.</p></li><li><p>HTML FORM<br>순수 HTML + HTML form을 사용하며 GET, POST만 지원합니다.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;api-uri-uniform-resource-identifier-seolgye&quot;&gt;&lt;a href=&quot;#api-uri-uniform-resource-identifier-seolgye&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Network" scheme="http://gwanhyeon.github.io/categories/network/"/>
    
    
      <category term="network" scheme="http://gwanhyeon.github.io/tags/network/"/>
    
      <category term="http" scheme="http://gwanhyeon.github.io/tags/http/"/>
    
      <category term="api" scheme="http://gwanhyeon.github.io/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>Netwrok 웹 API 디자인 REST API</title>
    <link href="http://gwanhyeon.github.io/Network-20210128-network-08-rest-api/"/>
    <id>http://gwanhyeon.github.io/Network-20210128-network-08-rest-api/</id>
    <published>2021-01-25T14:45:46.000Z</published>
    <updated>2021-01-30T17:00:54.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-api-dijain"><a href="#web-api-dijain" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#웹-api-디자인"></a> 웹 API 디자인</h1><p>대부분 최신 웹 어플리케이션은 클라이언트가 애플래케이션과 상호작용하는 데 사용할 수 있는 API를 표시합니다.</p><blockquote><p>웹 API의 특성 2가지</p></blockquote><ol><li><p>플랫폼 독립성<br>모든 클라이언트는 내부에서 API구현하는 방법에 관계없이 API를 호출할 수 있어야합니다. 그러기위해서는 표준 프로토콜을 사용해야하고,클라이언트가 및 웹서비스가 교환할 데이터 형식에 동의할 수 있는 매커니즘을 가지고 있어야합니다.</p></li><li><p>서비스진화<br>Web API는 클라이언트 애플리케이션과 독립적으로 기능을 진화시키고 추가 할 수 있어야합니다. API가 진화해도 기존클라이언트는 수정없이 작동되야하고 해당 기능을 완전히 이용할 수 있도록 검색 가능해야합니다.</p></li></ol><h1 id="rest-sogae"><a href="#rest-sogae" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#rest-소개"></a> REST 소개</h1><p>2000년에 Roy Fielding은 웹 서비스를 디자인하는 아키텍처 접근 방식으로 <code>REST(Representational State Transfer)</code>를 제안했습니다. REST는 하이퍼미디어 기반 분산 시스템을 구축하기 위한 아키텍처 스타일입니다. REST는 어떤 기본 프로토콜과도 독립적이며 HTTP에 연결될 필요가 없습니다. 그러나 대부분의 일반적인 REST 구현에서 애플리케이션 프로토콜로 HTTP를 사용하고, 이 지침에서는 HTTP를 위한 REST API 디자인에 중점을 둡니다.</p><blockquote><p>REST가 HTTP보다 우수한 장점</p></blockquote><ol><li>개방형 표준<br>API또는 클라이언트 애플리케이션의 구현이 특정 구현에 바인딩되지 않습니다.</li></ol><blockquote><p>Restful API 디자인 원칙</p></blockquote><ol><li><p>리소스를 중심으로 디자인되며 클라이언트에서 액세스 할 수 있는 모든 종류의 개체, 데이터 또는 서비스가 리소스에 포함됩니다.</p></li><li><p>리소스마다 해당 리소스를 고유하게 식별하는 URI식별자 존재</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">고객 주문 URI</span><br><span class="line">https:<span class="comment">//adventure-works.com/orders/1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>클라이언트가 리소스의 표현을 교환하여 서비스와 상호작용합니다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"orderId"</span>:<span class="number">1</span>,<span class="string">"orderValue"</span>:<span class="number">99.90</span>,<span class="string">"productId"</span>:<span class="number">1</span>,<span class="string">"quantity"</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>REST API는 균일한 인터페이스를 사용하므로 클라이언트와 서비스 구현을 분리하는데 도움이 됩니다.</li></ol><p><code>HTTP기반으로 하는 REST API경우 리소스에 표준 HTTP 동사 수행 작업을 사용하는것이 균일한 인터페이스에 포함됩니다.</code><br>Ex) GET,POST,PUT,PATCH,DELETE</p><ol start="5"><li>REST API는 상태 비저장 요청 모델을 사용합니다.</li></ol><p>독립적이며 임의순서로 발생할 수 있으므로 요청 사이에 일시적인 상태정보를 유지할 수 없습니다. 그리고 클라이언트 서버 사이에서 연결성을 유지할 필요가 없습니다. <code>즉, Connectionsless, Stateful, Stateless의 특성을 가지고 있습니다.</code></p><ol start="6"><li>REST API는 표현에 포함된 하이퍼미디어 링크에 따라 구동됩니다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"orderID"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">"productID"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">"quantity"</span>:<span class="number">4</span>,</span><br><span class="line">    <span class="string">"orderValue"</span>:<span class="number">16.60</span>,</span><br><span class="line">    <span class="string">"links"</span>: [</span><br><span class="line">        &#123;<span class="string">"rel"</span>:<span class="string">"product"</span>,<span class="string">"href"</span>:<span class="string">"https://adventure-works.com/customers/3"</span>, <span class="string">"action"</span>:<span class="string">"GET"</span> &#125;,</span><br><span class="line">        &#123;<span class="string">"rel"</span>:<span class="string">"product"</span>,<span class="string">"href"</span>:<span class="string">"https://adventure-works.com/customers/3"</span>, <span class="string">"action"</span>:<span class="string">"PUT"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2008년에 Leonard Richardson은 Web API에 대한 다음과 같은 모델 제안</p></blockquote><ul><li>수준 0: 한 URI를 정의하고 모든 작업은 이 URI에 대한 POST 요청을 통해 진행됩니다.</li><li>수준 1: 개별 리소스에 대한 별도의 URI를 만듭니다.</li><li>수준 2: HTTP 메서드를 사용하여 리소스에 대한 작업을 정의합니다.</li><li>수준 3: 하이퍼미디어(HATEOAS) 를 사용합니다.</li></ul><h1 id="risoseureul-jungsimeuro-api-guseong"><a href="#risoseureul-jungsimeuro-api-guseong" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#리소스를-중심으로-api-구성"></a> 리소스를 중심으로 API 구성</h1><p>웹 API가 표시하는 비즈니스 Entity 에 집중해야합니다.</p><p>전자상거래 시스템에서는 기본 엔티티가 고객과 주문인데 주문 정보가 포함된 HTTP POST요청을 전송하여 주문만들기를 진행할 수 있습니다. <code>이때 가장 중요한점은 리소스 URI는 동사(리소스에 대한작업)이 아닌 명사(리소스)기반으로 설계되어야합니다.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//adventure-works.com/orders // Good</span></span><br><span class="line">https:<span class="comment">//adventure-works.com/create-order // Avoid</span></span><br></pre></td></tr></table></figure><p>리소스는 단일 물리적 항목을 기반으로 구현할 필요가 없습니다. 내부적으로 관계형 DB로 구현할 수 있지만 클라이언트에 대해서는 단일 엔티티로 표시됩니다. 내부구조를 반영하는 API를 설계하면 안됩니다. <code>즉, 클라이언트 내부구현에 노출되면 안됩니다.</code></p><p>엔티티는 종종 컬렉션(주문, 고객)으로 그룹화 되는데 <code>컬렉션은 고유한 URI</code>가 있어야합니다.</p><blockquote><p>주문 URI 주문 컬렉션</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">컬렉션 URI에 HTTP GET 요청을 보내면 컬렉션에 있는 항목 목록을 검색합니다.</span><br><span class="line">https:<span class="comment">//adventure-works.com/orders</span></span><br></pre></td></tr></table></figure><p>URI에 일관적인 명명 규칙하는데 컬렉션을 참조하는 URI에 대해 복수 명사를 사용할 수 있습니다. 컬렉션 및 항목에 대한 URI를 계층 구조로 구성해야합니다.</p><p>예를 들어 <code>/customers는 고객 컬렉션의 경로</code>이고, <code>/customers/5는 ID가 5인 고객의 경로</code>입니다.</p><p>이 접근 방식을 사용하면 웹 API를 직관적으로 유지할 수 있습니다. 또한 많은 Web API 프레임워크는 매개 변수가 있는 URI 경로를 기반으로 라우팅 경로 /customers/{id}에 대한 경로를 정의할 수 있습니다.</p><p>서로 다른 리소스 형식과 이러한 연결을 표시하는 방법 사이의 관계도 고려해야 합니다.<br>예를 들어 <code>/customers/5/orders는 고객 5에 대한 모든 주문</code>을 나타낼 수 있습니다. 반대 방향으로 이동하여 <code>/orders/99/customer 같은 URI를 사용하여 주문에서 고객으로의 연결을 표시</code>할 수도 있습니다.</p><p>단, 모델을 광범위하게 확대시 구현이 어려울 수 있습니다.</p><blockquote><p>구현이 어려운 경우</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/customers/<span class="number">1</span>/orders/<span class="number">99</span>/products</span><br></pre></td></tr></table></figure><p><code>클라이언트가 여러 관계 수준을 탐색할 수 있는 URI를 제공</code>하고 싶을 수 있습니다. 그러나 이 수준의 복잡성은 유지하기 어려울 수 있으며 나중에 리소스 사이의 관계가 변하면 유연성이 떨어집니다.<br>위와같이 설계시 <code>모든 웹 요청이 웹 서버의 부하를 높인다는 점</code>입니다. 요청이 많을수록 부하가 커집니다. 따라서 다수의 작은 리소스를 표시하는 <code>복잡한 Web API를 피해야합니다.</code></p><blockquote><p>그러면 어떤식으로 설계해야할까요?</p></blockquote><p>이전 쿼리를 <code>/customers/1/orders</code> URI로 바꿔서 고객 1의 모든 주문을 찾은 후 <code>/orders/99/products</code>로 바꿔서 이 주문의 제품을 찾을 수 있습니다.</p><p>그리고 <code>Web API와 기본 데이터 원본 사이에 종속성이 발생하지 않도록 해야 합니다.</code></p><p>예를 들어 데이터가 관계형 데이터베이스에 저장되는 경우 Web API는 각 테이블을 리소스 컬렉션으로 표시할 필요가 없습니다.</p><p>마지막으로, <code>웹 API에 의해 구현된 일부 작업을 특정 리소스에 매핑하지 못할 수 있습니다.</code> HTTP GET 요청을 통해 기능을 호출하고 결과를 HTTP 응답 메시지로 반환하는 리소스가 아닐 수 있습니다.</p><blockquote><p>예시1</p></blockquote><p>더하기 및 빼기 같은 단순한 계산기 작업을 구현하는 Web API 리소스로 표시하고 쿼리 문자열을 사용하여 필요한 매개 변수를 지정하는 URI설계 할 수 있습니다.</p><blockquote><p>예시2</p></blockquote><p>URI /add? operand1 = 99&amp;99&amp;operand2 = 1 에 대 한 GET 요청은 100 값을 포함 하는 본문이 포함 된 응답 메시지를 반환 합니다. 그러나 이러한 형식의 URI는 제한적으로만 사용해야 합니다.</p><h1 id="http-meseodeureul-gijuneuro-jageob-jeongyi"><a href="#http-meseodeureul-gijuneuro-jageob-jeongyi" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#http-메서드를-기준으로-작업-정의"></a> HTTP 메서드를 기준으로 작업 정의</h1><blockquote><p>HTTP 메서드 정의</p></blockquote><ul><li><code>GET</code> 은 지정된 URI에서 리소스의 표현을 검색합니다. 응답 메시지의 본문은 요청된 리소스의 세부 정보를 포함하고 있습니다.</li><li><code>POST</code> 는 지정된 URI에 새 리소스를 만듭니다. 요청 메시지의 본문은 새 리소스의 세부 정보를 제공합니다. 참고로 POST를 사용하여 실제로 리소스를 만들지 않는 작업을 트리거할 수도 있습니다.</li><li><code>PUT</code> 은 지정된 URI에 리소스를 만들거나 대체합니다. 요청 메시지의 본문은 만들 또는 업데이트할 리소스를 지정합니다.</li><li><code>PATCH</code> 는 리소스의 부분 업데이트를 수행합니다. 요청 본문은 리소스에 적용할 변경 내용을 지정합니다.</li><li><code>DELETE</code> 는 지정된 URI의 리소스를 제거합니다.</li></ul><table><thead><tr><th>리소스</th><th>POST</th><th>GET</th><th>PUT</th><th>DELETE</th></tr></thead><tbody><tr><td>/customers</td><td>새 고객 만들기</td><td>모든 고객 검색</td><td>고객 대량 업데이트</td><td>모든 고객 제거</td></tr><tr><td>/customers/1</td><td>오류</td><td>고객 1에 대한 세부 정보 검색</td><td>고객 1이 있는 경우</td><td>고객 1의 세부 정보 업데이트</td></tr><tr><td>/customers/1/orders</td><td>고객 1에 대한 새 주문 만들기</td><td>고객 1에 대한 모든 주문 검색</td><td>고객 1의 주문 대량 업데이트</td><td>고객 1의 모든 주문 제거</td></tr></tbody></table><blockquote><p>POST, PUT 및 PATCH 차이점</p></blockquote><ul><li><p><code>POST 요청은 리소스를 만듭니다.</code> 서버는 새 리소스에 대한 URI를 할당하고 클라이언트에 해당 URI를 반환합니다. REST 모델에서는 컬렉션에 POST 요청을 자주 적용합니다. 즉, 프로세스 처리에 사용됩니다.</p></li><li><p><code>PUT 요청은 리소스를 만들거나 또는 기존 리소스를 업데이트합니다.</code> 클라이언트는 리소스의 URI를 지정합니다. 요청 본문에는 리소스의 완전한 표현이 포함됩니다. 이 URI를 사용하는 리소스가 이미 있으면 리소스가 대체됩니다. 아직 없고 서버에서 리소스 만들기를 지원하는 경우 새 리소스가 생성됩니다.</p></li></ul><blockquote><p><code>PUT사용시 주의할점: PUT 요청은 idempotent(멱등성)이여야 합니다.</code></p></blockquote><p>클라이언트가 동일한 PUT 요청을 여러 번 제출하는 경우 그 결과가 항상 같아야 합니다(같은 값을 사용하여 같은 리소스가 수정)</p><ul><li><code>PATCH 요청은 기존 리소스에 부분 업데이트를 수행합니다.</code> 클라이언트는 리소스의 URI를 지정합니다. 요청 본문은 리소스에 적용할 변경 내용을 지정합니다. 즉, 리소스 부분변경을 업데이트합니다.</li></ul><blockquote><p>멱등성의 개념</p></blockquote><p><code>멱등(Idempotent Methods) 여러번 호출해도 결과는 같아야합니다.</code> PUT을 호출하여 서버응답 호출을 통하여 재시도 할지 안할지를 확인할 수 있습니다. 즉, <code>자동 복구 매커니즘</code>에서 많이 활용됩니다.</p><h1 id="midieo-yuhyeong"><a href="#midieo-yuhyeong" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#미디어-유형"></a> 미디어 유형</h1><p><code>HTTP 프로토콜에서 형식은 MIME 유형이라고도 하는 미디어 유형을 사용하여 지정됩니다.</code> 보통 <code>Web API는 JSON(미디어 유형 = 애플리케이션/json) 및 XML(미디어 유형 = 애플리케이션/xml)을 지원</code>합니다. 그리고 요청과 응답의 경우 <code>Content-Type</code> 헤더는 표현 형식을 지정합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JSON 형식</span><br><span class="line"></span><br><span class="line">POST https:<span class="comment">//adventure-works.com/orders HTTP/1.1</span></span><br><span class="line">Content-Type: application/json; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Length: <span class="number">57</span></span><br><span class="line">&#123;<span class="string">"Id"</span>:<span class="number">1</span>,<span class="string">"Name"</span>:<span class="string">"Gizmo"</span>,<span class="string">"Category"</span>:<span class="string">"Widgets"</span>,<span class="string">"Price"</span>:<span class="number">1.99</span>&#125;</span><br></pre></td></tr></table></figure><p>만약에, <code>서버에서 미디어 유형을 지원하지 않으면 HTTP 상태 코드 415(지원되지 않는 미디어 유형)를 반환</code>해야 합니다.</p><blockquote><p>클라이언트 요청</p></blockquote><p>클라이언트 요청에는 클라이언트가 응답 메시지에서 서버로부터 받는 미디어 유형 목록을 포함하는 <code>Accept 헤더가 포함</code>될 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https:<span class="comment">//adventure-works.com/orders/2 HTTP/1.1</span></span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure><h1 id="get-meseodeu"><a href="#get-meseodeu" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#get-메서드"></a> GET 메서드</h1><p>성공적인 GET 메서드는 일반적으로 <code>HTTP 상태 코드 200(정상)를 반환</code>합니다. <code>리소스를 찾을 수 없는 경우 404(Not Found)반환</code>합니다.</p><h1 id="post-meseodeu"><a href="#post-meseodeu" class="header-anchor">7. </a><a class="markdownIt-Anchor" href="#post-메서드"></a> POST 메서드</h1><p><code>POST 메서드는 새 리소스를 만드는 경우 HTTP 상태 코드 201(만들어짐)을 반환합니다.</code> 새 리소스의 URI는 응답의 Location 헤더에 포함됩니다. 응답 본문은 리소스의 표현을 포함합니다.</p><p>만약에 <code>새 리소스를 만들지 않는 경우 메서드는 HTTP 상태 코드 200을 반환</code>하고 작업의 결과를 응답 본문에 포함할 수 있습니다. 또는 <code>반환할 결과가 없으면 메서드가 응답 본문 없이 HTTP 상태 코드 204(컨텐츠 X) 를 반환</code>할 수 있습니다.</p><h1 id="putmeseodeu"><a href="#putmeseodeu" class="header-anchor">8. </a><a class="markdownIt-Anchor" href="#put메서드"></a> PUT메서드</h1><p><code>PUT 메서드는 POST 메서드와 마찬가지로 새 리소스를 만드는 경우 HTTP 상태 코드 201(만들어짐)을 반환</code>합니다. 이 메서드는 기존 리소스를 업데이트할 경우 <code>200(정상) 또는 204(내용 없음)를 반환</code>합니다. 상황에 따라 기존 리소스를 업데이트할 수 없는 경우도 있습니다.</p><h1 id="patch-meseodeu"><a href="#patch-meseodeu" class="header-anchor">9. </a><a class="markdownIt-Anchor" href="#patch-메서드"></a> PATCH 메서드</h1><p>클라이언트는 <code>PATCH 요청을 사용하여 업데이트를 패치 문서 의 형태로 기존 리소스에 보냅니다.</code> 서버는 패치 문서를 처리하여 업데이트를 수행합니다. 패치 문서는 리소스 전체가 아니라 적용할 변경 내용만 설명합니다.  <code>즉, 부분변경만 진행합니다.</code></p><blockquote><p>두 가지 주요 JSON 기반 패치 형식으로 JSON 패치 및 JSON 병합 패치</p></blockquote><p><code>JSON 병합 패치는 비교적 간단합니다.</code> 패치 문서는 원래 JSON 리소스와 동일한 구조를 갖지만 변경 또는 추가할 필드의 하위 집합만 포함하고 있습니다. 또한 패치 문서에서 필드 값에 대해 null을 지정하여 필드를 삭제할 수 있습니다.</p><p><em>JSON 기반 패치</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"gizmo"</span>,</span><br><span class="line">    <span class="string">"category"</span>:<span class="string">"widgets"</span>,</span><br><span class="line">    <span class="string">"color"</span>:<span class="string">"blue"</span>,</span><br><span class="line">    <span class="string">"price"</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>JSON 병합패치</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;price&quot;:12,</span><br><span class="line">    &quot;color&quot;:null,</span><br><span class="line">    &quot;size&quot;:&quot;small&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결론적으로 <code>원래 리소스가 명시적 null 값을 포함할 수 있으면 패치 문서에서 null이 갖는 특별한 의미 때문에 병합 패치가 적합하지 않습니다.</code> 또한 패치 문서는 서버에서 업데이트를 적용할 순서를 지정하지 않습니다. <code>JSON 패치의 미디어 유형은 application/json-patch+json</code>입니다.</p><blockquote><p>HTTP 상태 코드와 함께 PATCH 요청을 처리할 때 발생할 수 있는 몇 가지 일반적인 오류 조건</p></blockquote><table><thead><tr><th>오류조건</th><th>HTTP 상태 코드</th></tr></thead><tbody><tr><td>지원되지 않는 패치 문서 형식입니다.</td><td>415(지원되지 않는 미디어 형식)</td></tr><tr><td>패치 문서의 형식이 잘못되었습니다.</td><td>400(잘못된 요청)</td></tr><tr><td>패치 문서가 유효하지만 현재 상태에서는 변경 내용을 리소스에 적용할 수 없습니다.</td><td>409(충돌)</td></tr></tbody></table><h1 id="delete-meseodeu"><a href="#delete-meseodeu" class="header-anchor">10. </a><a class="markdownIt-Anchor" href="#delete-메서드"></a> DELETE 메서드</h1><p>삭제 작업이 성공하면 웹 서버는 프로세스가 성공적으로 처리되었지만 응답 본문에 추가 정보가 포함되지 않았음을 나타내는 <code>HTTP 204 상태 코드로 응답</code>해야 합니다. 리소스가 없는 경우 웹 서버는 <code>HTTP 404(찾을 수 없음)를 반환</code>할 수 있습니다.</p><h1 id="bidonggi-jageob"><a href="#bidonggi-jageob" class="header-anchor">11. </a><a class="markdownIt-Anchor" href="#비동기-작업"></a> 비동기 작업</h1><p>경우에 따라 POST, PUT, PATCH 또는 DELETE 작업을 완료 하는 데 시간이 오래 걸리는 처리가 필요할 수 있습니다. 이 경우 요청 처리가 수락되었지만 아직 완료되지 않았음을 나타내는 <code>HTTP 상태 코드 202(수락됨)를 반환</code>합니다.</p><p>즉, 클라이언트가 상태 엔드포인트를 폴링하여 상태를 모니터링할 수 있도록 비동기 요청의 상태를 반환하는 <code>엔드포인트를 표시</code>해야합니다. <code>202 응답의 Location 헤더에 상태 엔드포인트의 URI를 포함</code>합니다.</p><blockquote><p>엔드포인트 표시 예시</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">202</span> Accepted</span><br><span class="line">Location: /api/status/<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>클라이언트가 이 엔드포인트에 GET 요청을 보내는 경우 응답에 요청의 현재 상태가 포함되어야 합니다. 필요에 따라 <code>예상 완료 시간 또는 작업 취소 링크를 포함하는 경우는 어떻게 표현</code>할 수 있을까요?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>:<span class="string">"In progress"</span>,</span><br><span class="line">    <span class="string">"link"</span>: &#123; <span class="string">"rel"</span>:<span class="string">"cancel"</span>, <span class="string">"method"</span>:<span class="string">"delete"</span>, <span class="string">"href"</span>:<span class="string">"/api/status/12345"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>비동기 작업에서 새 리소스를 만드는 경우 작업 완료 후 상태 엔드포인트에서 상태 코드 <code>303(다른 항목 보기)을 반환</code>해야 합니다. <code>303 응답에 새 리소스의 URI를 제공하는 Location 헤더를 포함</code>합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">303</span> See Other</span><br><span class="line">Location: /api/orders/<span class="number">12345</span></span><br></pre></td></tr></table></figure><h1 id="deiteo-pilteoring-mic-peijineisyeon"><a href="#deiteo-pilteoring-mic-peijineisyeon" class="header-anchor">12. </a><a class="markdownIt-Anchor" href="#데이터-필터링-및-페이지네이션"></a> 데이터 필터링 및 페이지네이션</h1><p>클라이언트 애플리케이션에서 비용이 특정 값을 초과하는 모든 주문을 찾아야 한다고 가정해 봅시다.</p><p>클라이언트 응용 프로그램은 <code>/orders URI에서 모든 주문을 검색한 후 클라이언트 쪽에서 이러한 주문을 필터링</code>할 것입니다. 이 프로세스는 매우 <code>비효율적</code>입니다. Web API를 호스팅하는 <code>서버의 네트워크 대역폭 및 처리 성능이 낭비됩니다.</code></p><blockquote><p>동적 쿼리 및 페이지네이션</p></blockquote><p>이 방법 대신, <code>/orders?minCost=n</code> 처럼 API가 <code>URI의 쿼리 문자열에서 필터 전달을 허용</code>할 수 있습니다. 그러면 Web API가 쿼리 문자열의 minCost 매개 변수를 구문 분석 및 처리하고 <code>서버 쪽에서 필터링된 결과를 반환</code>합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/orders?limit=<span class="number">25</span>&amp;offset=<span class="number">50</span></span><br></pre></td></tr></table></figure><p>다음과 같이 오프셋을 지정할 수 있습니다.</p><blockquote><p>서비스 거부 공격을 방지하기 위해 반환되는 항목 수를 제한하는 방안</p></blockquote><p>필드 이름을 <code>/orders?sort=ProductID</code> 같은 값으로 가져오는 정렬 매개 변수를 제공하여 데이터를 가져올 때 데이터를 정렬하는 비슷한 전략을 처리할 수 있습니다.</p><p>But, 쿼리 문자열 매개 변수는 여러 캐시 구현에서 캐시된 데이터의 키로 사용되는 리소스 식별자의 일부를 구성하기 때문에 <code>이 접근 방식은 캐싱에 나쁜 영향</code>을 끼칩니다.</p><h1 id="daeyongryang-ijin-risoseue-daehan-bubun-eungdab-jiweon"><a href="#daeyongryang-ijin-risoseue-daehan-bubun-eungdab-jiweon" class="header-anchor">13. </a><a class="markdownIt-Anchor" href="#대용량-이진-리소스에-대한-부분-응답-지원"></a> 대용량 이진 리소스에 대한 부분 응답 지원</h1><p>대용량 응답 시간을 개선하려면 이러한 <code>리소스를 청크로 검색할 수 있게 하는 방안을 고안</code>해야합니다.</p><blockquote><p>예시</p></blockquote><p>Web API가 큰 리소스의 GET 요청에 대해 <code>Accept-Ranges 헤더를 지원</code>해야 합니다. 이 헤더는 GET 작업이 부분 요청을 지원한다는 것을 나타냅니다. 클라이언트 애플리케이션은 바이트 범위로 지정된 리소스 하위 집합을 반환하는 GET을 반환할 수 있습니다.</p><blockquote><p>HEAD</p></blockquote><p>HEAD 요청은 리소스에 대해 설명하는 HTTP 헤더만 반환하고 메시지 본문이 비어 있다는 점을 제외하면 GET 요청과 비슷합니다.</p><ul><li>요청 메시지</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEAD https:<span class="comment">//adventure-works.com/products/10?fields=productImage HTTP/1.1</span></span><br></pre></td></tr></table></figure><ul><li>응답메시지</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">Content-Length: <span class="number">4580</span></span><br></pre></td></tr></table></figure><p>Content-Length 헤더는 총 리소스 크기를 제공하고, <code>Accept-Ranges 헤더</code>는 해당 GET 작업이 <code>일부 결과를 지원</code>합니다. 첫 번째 요청은 범위 헤더를 사용하여 <code>처음 2500 바이트를 가져옵니다.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https:<span class="comment">//adventure-works.com/products/10?fields=productImage HTTP/1.1</span></span><br><span class="line">Range: bytes=<span class="number">0</span>-<span class="number">2499</span></span><br></pre></td></tr></table></figure><blockquote><p>일부범위만 Content-Range에 넣는방법</p></blockquote><p>메시지 본문에 반환된 실제 바이트 수(리소스의 크기가 아닌)를 지정하며, <code>Content-Range 헤더는 해당 바이트가 리소스의 어느 부분인지(4580 바이트 중 바이트 0-2499)를 나타냅니다.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line"></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">Content-Length: <span class="number">2500</span></span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">2499</span>/<span class="number">4580</span></span><br></pre></td></tr></table></figure><blockquote><p>Reference</p></blockquote><p><a href="https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web-api-dijain&quot;&gt;&lt;a href=&quot;#web-api-dijain&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#웹-api-디자인&quot;&gt;&lt;/a&gt; 웹 API 디자인
      
    
    </summary>
    
    
      <category term="Network" scheme="http://gwanhyeon.github.io/categories/network/"/>
    
    
      <category term="Network" scheme="http://gwanhyeon.github.io/tags/network/"/>
    
      <category term="REST" scheme="http://gwanhyeon.github.io/tags/rest/"/>
    
  </entry>
  
  <entry>
    <title>JPA 영속성 컨텍스트(Persistence Context)</title>
    <link href="http://gwanhyeon.github.io/JPA-20210127-jpa-02-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"/>
    <id>http://gwanhyeon.github.io/JPA-20210127-jpa-02-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/</id>
    <published>2021-01-25T06:05:04.000Z</published>
    <updated>2021-01-27T07:09:21.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yeongsogseong-keontegseuteu-persistence-context"><a href="#yeongsogseong-keontegseuteu-persistence-context" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#영속성-컨텍스트persistence-context"></a> 영속성 컨텍스트(Persistence Context)</h1><p>영속성 컨텍스트란 논리적인 개념(무형성)으로 엔티티를 영구 저장하는 환경이라고 할 수 있습니다. 특히, JPA를 이해하는데 가장 중요한 용어입니다. 그리고 EntityManager를 통하여 영속성 컨텍스트에 접근할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityManager.persist(entity);</span><br></pre></td></tr></table></figure><p>다음과 같이 EntityManagerFactory가 생성시킨 EntityManager를 사용하여 Connection pool에 접근하여 Database에 접근할 수 있습니다.</p><h1 id="j2se-standard-edition-vs-j2ee-enterprise-edition"><a href="#j2se-standard-edition-vs-j2ee-enterprise-edition" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#j2se-standard-edition-vs-j2ee-enterprise-edition"></a> J2SE (Standard Edition) VS J2EE ( Enterprise Edition)</h1><blockquote><p>J2SE</p></blockquote><p>일반 자바 프로그램 개발을 위한 용도로 이용되는 개발도구이며 각종 자료구조, 기본 유틸리티, 스윙이나 AWT와 같은 GUI도구등의 기본기능을 포함하고 있다.</p><blockquote><p>J2EE</p></blockquote><p>엔터프라이즈 환경을 위한 도구로 EJB, JSP, Servlet, JNDI같은 기능을 지원하며 웹 애플리케이션 서버를 이용하는 프로그램 개발시 많이 사용한다.</p><p>두 가지 환경에서는 어떠한 차이가 있을까요?</p><p>J2SE는 엔티티매니저와 영속성컨텍스트가 1:1로 관계를 가지고 있으며 J2EE 스프링 프레임워크 같은 컨테이너 환경은 엔티티 매니저와 영속성 컨텍스트가 N:1의 관계를 가지고 있습니다.</p><h1 id="entity-saengmyeongjugi"><a href="#entity-saengmyeongjugi" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#entity-생명주기"></a> Entity 생명주기</h1><blockquote><p>생명주기</p></blockquote><p><img src="https://www.objectdb.com/files/images/manual/jpa-states.png" alt="엔티티 생명주기"></p><h2 id="biyeongsog-new-transient"><a href="#biyeongsog-new-transient" class="header-anchor">3.1. </a><a class="markdownIt-Anchor" href="#비영속newtransient"></a> 비영속(new/transient)</h2><p>영속성 컨텍스트와 전혀관계가 없는 새로운 상태</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 생성 (비영속)</span></span><br><span class="line">Member member = <span class="keyword">new</span> Member();</span><br><span class="line">member.setId(<span class="string">"memberId1"</span>);</span><br><span class="line">member.setUsername(<span class="string">"gwanhyeonkim"</span>)</span><br></pre></td></tr></table></figure><h2 id="yeongsog-managed"><a href="#yeongsog-managed" class="header-anchor">3.2. </a><a class="markdownIt-Anchor" href="#영속managed"></a> 영속(managed)</h2><p>영속성 컨텍스트에 관리되는 상태</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 생성(비영속)</span></span><br><span class="line">Member member = <span class="keyword">new</span> Member();</span><br><span class="line">member.setId(<span class="string">"memberId1"</span>);</span><br><span class="line">member.setUsername(<span class="string">"gwanhyeonkim"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 엔티티 매니저 팩토리로 엔티티 매니저를 생성합니다.</span></span><br><span class="line">EntityManager em = emf.createEntityManager();</span><br><span class="line"><span class="comment">// 트랙잭션위에서 동작합니다.</span></span><br><span class="line">em.getTransaction().begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체를 저장한 상태(영속) - 영속상태가 되는것 DB에 저장되는 상태가 아니며 트랜잭션 커밋시점에 해당 DB에 들어가게 됩니다.</span></span><br><span class="line"><span class="comment">// 만약 1차캐시가 있다면 1차캐시를 사용합니다.</span></span><br><span class="line">em.persist(member);</span><br></pre></td></tr></table></figure><h2 id="junyeongsog-detached"><a href="#junyeongsog-detached" class="header-anchor">3.3. </a><a class="markdownIt-Anchor" href="#준영속detached"></a> 준영속(detached)</h2><p>영속성 컨텍스트에 저장되었다가 분리된 상태</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 엔티티를 영속성 컨텍스트에서 분리시키고 준영속상태로 만듭니다.</span></span><br><span class="line">em.detach(member);</span><br></pre></td></tr></table></figure><h2 id="sagje-removed"><a href="#sagje-removed" class="header-anchor">3.4. </a><a class="markdownIt-Anchor" href="#삭제removed"></a> 삭제(removed)</h2><p>삭제된 상태</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체를 삭제한 상태</span></span><br><span class="line">em.remove(member);</span><br></pre></td></tr></table></figure><h1 id="yeongsogseong-keontegseuteu-teugjing"><a href="#yeongsogseong-keontegseuteu-teugjing" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#영속성-컨텍스트-특징"></a> 영속성 컨텍스트 특징</h1><ol><li>1차캐시를 활용합니다.</li><li>동일성(Identity)를 보장합니다.</li><li>트랜잭션을 지원하는 쓰기 지연을 일으킵니다(Transcational write-behind)</li><li>변경 감지(Dirty Checking)이 가능합니다.</li><li>지연 로딩(Lazy Loading)을 지원합니다</li></ol><p>즉, 영속성 컨텍스트는 버퍼링과 캐싱의 기능을 가질 수 있습니다.</p><h1 id="entiti-johoe-mic-1ca-kaesi"><a href="#entiti-johoe-mic-1ca-kaesi" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#엔티티-조회-및-1차-캐시"></a> 엔티티 조회 및 1차 캐시</h1><p>1차 캐시는 Map형태로 구성되어있습니다. 예를 들면 key-@Id : value-@Entity &lt;Key,Value&gt;형식으로 구성되어있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//엔티티를 생성한 상태 비영속상태입니다.</span></span><br><span class="line">Member member = <span class="keyword">new</span> Member();</span><br><span class="line">member.setId(<span class="string">"memberId1"</span>);</span><br><span class="line">member.setUsername(<span class="string">"gwanhyeonkim"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//엔티티를 영속하는 단계</span></span><br><span class="line">em.persist(member);</span><br></pre></td></tr></table></figure><blockquote><p>이제 이것들은 1차캐시에서 어떻게 사용될까요?</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//엔티티를 생성한 상태 비영속상태입니다.</span></span><br><span class="line">Member member = <span class="keyword">new</span> Member();</span><br><span class="line">member.setId(<span class="string">"memberId1"</span>);</span><br><span class="line">member.setUsername(<span class="string">"gwanhyeonkim"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1차 캐시에 저장</span></span><br><span class="line">em.persist(member);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1차 캐시에서 조회</span></span><br><span class="line">Member member1 = em.find(Member.class, "gwanhyeonkim");</span><br></pre></td></tr></table></figure><p>em.persist(member)를 하게 되면 1차 캐시에 값이 저장되고 그 이후에 만약 값을 조회하는 경우 현재 1차캐시에 올라간 값으로 조회해옵니다.<br>즉, 영속성 컨텍스트에서 1차캐시를 확인하고 없으면 1차캐시에 저장을 하게됩니다. 그리고 값을 조회하면 1차캐시에 저장된 저장값들을 불러와서 조회가 가능하게 됩니다.</p><blockquote><p>데이터베이스 조회</p></blockquote><p>EntityManager은 트랜잭션단위로 처리를 진행합니다. 즉, 1차 캐시도 날아가며 1차캐시는 전체적인 확인을 통해 진행됩니다.</p><ol><li>find(“gwanhyeonkim”) 1차 캐시를 확인하여 없으면 DB를 조회합니다.</li><li>DB조회후 1차캐시에 저장을 시키고 해당 member값을 반환시켜주게 됩니다.</li></ol><h1 id="yeongsogseong-entiti-dongilseong-identifier"><a href="#yeongsogseong-entiti-dongilseong-identifier" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#영속성-엔티티-동일성identifier"></a> 영속성 엔티티 동일성(Identifier)</h1><p>만약에 똑같은 값을 조회한다고 가정하면 영속성 엔티티의 동일성을 보장시켜줍니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Member member1 = em.find(Member.class, "gwanhyeonkim");</span><br><span class="line">Member member2 = em.find(Member.class, "gwanhyeonkim");</span><br><span class="line"></span><br><span class="line">(a == b) <span class="comment">// 동일성이 같습니다. true</span></span><br></pre></td></tr></table></figure><p>1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공됩니다. 즉, 같은 트랜잭션내에 동일성이 보장되면 true를 리턴한다고 할 수 있습니다.</p><blockquote><p>데이터베이스에 언제 Insert를 진행할까요?</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.commit(); <span class="comment">// 해당 시점에 트랜잭션 커밋을 진행하면서 insert값들을 실제 SQL쿼리를 날리게 됩니다. 즉, 쓰기지연이 일어나는 시점이며 flush SQL이 같이 동작됩니다.</span></span><br></pre></td></tr></table></figure><blockquote><p>em.persist()</p></blockquote><p>persist가 동작하면 INSERT SQL과 1차캐시에 저장을 동시에 진행합니다. INSERT SQL생성시 쓰기 지연 SQL저장소에 저장시키고 1차 캐시에서 해당 캐시가 있는지 없는지를 확인하고 있으면 해당 값을 캐시에서 가져오고<br>그게 아니라면 영속성컨텍스트가 DB에 접근하여 SQL 쓰기지연저장소에 저장된 쿼리를 날리게 됩니다. transaction.commit()으로 쓰기지연이 동작하고 flush sql이 함께 동작됩니다. 이때 해당 실제 DB에 값을 넣게 됩니다.</p><p>이것을 쓰는 이유는 무엇일까요? 버퍼링, 즉, 캐싱개념이 생기게 됩니다.</p><h1 id="entiti-sujeong"><a href="#entiti-sujeong" class="header-anchor">7. </a><a class="markdownIt-Anchor" href="#엔티티-수정"></a> 엔티티 수정</h1><p>영속성 엔티티를 조회후에 데이터를 수정한다면 어떻게 처리가 될까요?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//영속 엔티티 조회</span></span><br><span class="line">Member member1 = em.find(Member.class, "gwanhyeonkim");</span><br><span class="line"></span><br><span class="line"><span class="comment">//영속 엔티티 데이터 수정</span></span><br><span class="line">member1.setUsername(<span class="string">"kgh"</span>);</span><br><span class="line">member1.setAge(<span class="string">"20"</span>);</span><br><span class="line"></span><br><span class="line">transcation.commit(); <span class="comment">// 트랜잭션을 커밋하는 시점입니다.</span></span><br></pre></td></tr></table></figure><p>데이터수정시 em.persist를 넣을 필요는 없게 됩니다. 이미 영속성컨텍스트에 관리되어지고 있기 때문입니다.</p><h1 id="byeongyeong-gamji-dirty-checking"><a href="#byeongyeong-gamji-dirty-checking" class="header-anchor">8. </a><a class="markdownIt-Anchor" href="#변경-감지dirty-checking"></a> 변경 감지(Dirty Checking)</h1><p>변경 감지 순서에 대해서 알아보겠습니다.</p><p>영속성 컨텍스트(entity manager)안에서 transcation.commit()이 작동되게 되면 어떻게 처리될까요?</p><ol><li>flush()함수가 동작됩니다.</li><li>엔티티 스냅샷(최초 시점에만)과 비교되어 집니다.</li><li>쓰기지연 저장소에 UPDATE SQL이 생성됩니다.</li><li>다시 flush()를 수행하면서 SQL UPDATE구문이 DB에 날리게 되면서 이때, commit이 진행됩니다.</li></ol><h1 id="entiti-sagje"><a href="#entiti-sagje" class="header-anchor">9. </a><a class="markdownIt-Anchor" href="#엔티티-삭제"></a> 엔티티 삭제</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Member member1 = em.find(Member.class, "gwanhyeonkim");</span><br><span class="line">em.remove(member1);</span><br></pre></td></tr></table></figure><p>삭제 대상 엔티티를 조회하고 엔티티를 삭제하는 구문입니다.</p><h1 id="peulreosi-flush"><a href="#peulreosi-flush" class="header-anchor">10. </a><a class="markdownIt-Anchor" href="#플러시flush"></a> 플러시(Flush)</h1><p>영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는것을 뜻합니다. 즉, 지연 sql 스냅샷과 쓰기지연 SQL 저장소에 저장해놓은 쿼리를 데이터베이스에 반영하는 과정이라고 생각하시면 됩니다.</p><ol><li>변경 감지(dirty checking)를 진행합니다.</li><li>수정된 엔티티 쓰기 지연 SQL 저장소에 등록됩니다.</li><li>쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송합니다. (등록, 수정, 삭제)</li></ol><h1 id="yeongsogseong-keontegseuteureul-peulreosireul-eoddeohge-halggayo"><a href="#yeongsogseong-keontegseuteureul-peulreosireul-eoddeohge-halggayo" class="header-anchor">11. </a><a class="markdownIt-Anchor" href="#영속성-컨텍스트를-플러시를-어떻게-할까요"></a> 영속성 컨텍스트를 플러시를 어떻게 할까요?</h1><ol><li>em.flush()를 직접호출하여 진행합니다. 테스트를 진행할때 이러한 방식으로 새로가동하는것처럼 진행할 수 있습니다.</li><li>트랜잭션 커밋을 진행합니다. 이때 플러시가 자동으로 같이 호출되게 됩니다.</li><li>JPQL쿼리를 실행합니다. 이때 플러시가 자동으로 같이 호출되게 됩니다. JPQL쿼리실행시 1차 캐시가 사라지는것이 아니고 쓰기지연SQL, 변경감지 업데이트 쿼리들이 DB에 반영됩니다.</li></ol><h1 id="jpql-kweori-silhaengsi-peulreosiga-jadongeuro-hoculdoeneun-iyu"><a href="#jpql-kweori-silhaengsi-peulreosiga-jadongeuro-hoculdoeneun-iyu" class="header-anchor">12. </a><a class="markdownIt-Anchor" href="#jpql-쿼리-실행시-플러시가-자동으로-호출되는-이유"></a> JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유</h1><p>em.persist에 persist를 실행한다고 하였을때 persist 자체만으로 DB에 접근은 하지 못합니다. 그 이유는 JPQL을 날리게 되면 자동으로 flush()를 호출하여 DB를 가져오기때문에 현재 값들을 select해올 값이 없게 됩니다.</p><h1 id="peulreosi-modeu-obsyeon"><a href="#peulreosi-modeu-obsyeon" class="header-anchor">13. </a><a class="markdownIt-Anchor" href="#플러시-모드-옵션"></a> 플러시 모드 옵션</h1><ol><li>FlushModeType.AUTO - 커밋이나 쿼리를 실행할 때 Flush(Default)</li><li>FlushModeType.COMMIT - 커밋할때만 Flush</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em.setFlushMode(FlushModeType.COMMIT)</span><br></pre></td></tr></table></figure><h1 id="peulreosi-teugjing"><a href="#peulreosi-teugjing" class="header-anchor">14. </a><a class="markdownIt-Anchor" href="#플러시-특징"></a> 플러시 특징</h1><ol><li>영속성 컨텍스트를 비우지 않습니다.</li><li>영속성 컨텍스트의 변경내용을 데이터베이스에 동기화합니다.</li><li>트랜잭션이라는 작업단위가 중요하며 커밋직전에만 동기화를 진행하면 됩니다.</li></ol><h1 id="junyeongsog-sangtae"><a href="#junyeongsog-sangtae" class="header-anchor">15. </a><a class="markdownIt-Anchor" href="#준영속-상태"></a> 준영속 상태</h1><ol><li>영속상태(1차캐시에 저장된 상태)에서 준영속상태를 만드는 상태</li><li>영속상태의 엔티티가 영속성 컨텍스트에서 분리합니다.(detached) - Dirty Checking을 사용하지 못합니다.</li><li>영속성 컨텍스트가 제공하는 기능을 사용하지 못합니다.</li></ol><blockquote><p>준영속 상태로 어떻게 만들 수 있을까?</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">em.detach(entity) 특정 엔티티만 준영속상태로 전환</span><br><span class="line">em.clear(entity) 영속성 컨텍스트를 완전히 초기화</span><br><span class="line">em.close() 영속성 컨텍스트를 종료</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yeongsogseong-keontegseuteu-persistence-context&quot;&gt;&lt;a href=&quot;#yeongsogseong-keontegseuteu-persistence-context&quot; class=&quot;header-anchor&quot;&gt;1.
      
    
    </summary>
    
    
      <category term="JPA" scheme="http://gwanhyeon.github.io/categories/jpa/"/>
    
    
      <category term="JPA" scheme="http://gwanhyeon.github.io/tags/jpa/"/>
    
      <category term="Entity" scheme="http://gwanhyeon.github.io/tags/entity/"/>
    
      <category term="Persistence" scheme="http://gwanhyeon.github.io/tags/persistence/"/>
    
      <category term="Flush" scheme="http://gwanhyeon.github.io/tags/flush/"/>
    
  </entry>
  
  <entry>
    <title>JPA(Java Persistence API)</title>
    <link href="http://gwanhyeon.github.io/JPA-20210127-jpa-01-jpa%EB%9E%80/"/>
    <id>http://gwanhyeon.github.io/JPA-20210127-jpa-01-jpa%EB%9E%80/</id>
    <published>2021-01-25T05:24:24.000Z</published>
    <updated>2021-01-27T07:11:36.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jpa-database-dialect"><a href="#jpa-database-dialect" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#jpa-database-dialect"></a> JPA Database Dialect</h1><p>JPA는 특정 데이터베이스에 종속되지 않으며 각각 데이터베이스가 제공하는 SQL 문법과 함수는 차이가 있습니다.</p><p>가변문자에서 Mysql은 VARCHAR으로 선언되고 Oracle은 VARCHAR2 으로 사용되면서 문법적 차이가 존재합니다. 그리고 문자열을 자르는 함수같은 경우는 SQL 표준은 SUBSTRING(), Oracle은 SUBSTR()로 사용됩니다. 페이징 처리 같은 경우는 MySQL LIMIT을 사용하고 Oracle은 ROWNUM을 사용합니다.<br>JPA Database Dialect는 SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능이라고 할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H2: org.hibernate.dialect.H2Dialect</span><br><span class="line">Oracle <span class="number">10</span>g: org.hibernate.dialect.Oracle10gDialect</span><br><span class="line">MySQL: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure><p>다음과 같이 hibernate.dialect속성을 지정하여 사용할 수 있습니다. Hibernate는 약 40개 이상의 Dialect를 지원합니다.</p><h1 id="jpa-gudongbangsig"><a href="#jpa-gudongbangsig" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#jpa-구동방식"></a> JPA 구동방식</h1><p>Persistance(영속성)가 Maven(META-INF/persistance.xml), Gradle(application.properties,application.yml) 설정 정보를 조회한후 해당 설정정보로 EntityManagerFactory를 생성하여 EntityManagerFactory가 EntityManager를 생성하게 됩니다.</p><blockquote><p>주의 사항</p></blockquote><ol><li><p>EntitiyManagerFactory:<br>하나만 생성하여 어플리케이션 전체에 공유되는 방식을 사용합니다.</p></li><li><p>EntityManager:<br>쓰레드간에 공유를 하지 못합니다. 따라서, EntitiyManager를 선언하고 추후에 따로 해지시켜주는 방식으로 구동되어야합니다.</p></li><li><p>JPA는 모든 데이터 변경은 트랜잭션안에서 실행됩니다. 따라서, 모든 데이터변경시에  트랜잭션이 실행되어 commit과 rollback과정을 처리합니다.</p></li></ol><h1 id="entity-id"><a href="#entity-id" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#entity-id"></a> @Entity, @Id</h1><p>@Entity: Entity어노테이션은 JPA가 관리하는 객체로 선언해줍니다.<br>@Id: Id어노테이션은 데이터베이스 PK와 매핑됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String memberName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="jpql-java-persistence-query-language"><a href="#jpql-java-persistence-query-language" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#jpqljava-persistence-query-language"></a> JPQL(Java Persistence Query Language)</h1><p>JPA를 사용하면 엔티티 객체를 중심으로 개발이 진행되고 만약에 검색쿼리를 진행한다고 할대, 테이블이 아닌 엔티티객체를 대상으로 검색을 진행하게 됩니다. 하지만, 모든DB데이터를 객체로 변환해서 검색하는것은 불가능합니다. 따라서, 필요한 데이터만 가져오기위해 검색조건이 포함된 SQL이 필요로 되어지는데 이때 JPQL을 사용하게 됩니다.</p><p>JPQL은 SQL을 추상화하여 JPQL이라는 객체지향 쿼리언어를 제공하는것을 말합니다. SQL문법과도 매우 유사하며 SELECT,FROM,WHERE,GROUP BY, HAVING, JOIN과 같은 문법도 지원을 해줍니다.</p><blockquote><p>SQL VS JPQL</p></blockquote><p>JPQL은 엔티티 객체를 대상으로 쿼리문을 날리고, SQL은 데이터베이스 테이블 대상으로 쿼리를 날립니다.</p><blockquote><p>정리</p></blockquote><p>테이블이 아닌 객체를 대상으로 검색하는 객체지향쿼리를 일컫는말이고 SQL을 추상화하였기때문에 특정 SQL에 의존하지 않는다는 장점을 가지고 있습니다. JPQL은 객체지향 SQL이라고 말할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jpa-database-dialect&quot;&gt;&lt;a href=&quot;#jpa-database-dialect&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jpa-database-
      
    
    </summary>
    
    
      <category term="JPA" scheme="http://gwanhyeon.github.io/categories/jpa/"/>
    
    
      <category term="JPA" scheme="http://gwanhyeon.github.io/tags/jpa/"/>
    
      <category term="JPQL" scheme="http://gwanhyeon.github.io/tags/jpql/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3/E Item 54 null이 아닌,빈 컬렉션이나 배열을 반환하라</title>
    <link href="http://gwanhyeon.github.io/EffectiveJava-20210125-%EC%95%84%EC%9D%B4%ED%85%9C54-null%EC%9D%B4-%EC%95%84%EB%8B%8C-%EB%B9%88-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%B4%EB%82%98-%EB%B0%B0%EC%97%B4%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EB%9D%BC/"/>
    <id>http://gwanhyeon.github.io/EffectiveJava-20210125-%EC%95%84%EC%9D%B4%ED%85%9C54-null%EC%9D%B4-%EC%95%84%EB%8B%8C-%EB%B9%88-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%B4%EB%82%98-%EB%B0%B0%EC%97%B4%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EB%9D%BC/</id>
    <published>2021-01-25T01:11:11.000Z</published>
    <updated>2021-01-25T01:42:07.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nulli-anin-bin-keolregsyeonina-baeyeoleul-banhwanhara"><a href="#nulli-anin-bin-keolregsyeonina-baeyeoleul-banhwanhara" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#null이-아닌-빈-컬렉션이나-배열을-반환하라"></a> null이 아닌, 빈 컬렉션이나 배열을 반환하라</h1><h2 id="keolregsyeoni-bieosseumyeon-nulleul-banhwanhanda-ddarahajimalaya-haneun-bangbeob"><a href="#keolregsyeoni-bieosseumyeon-nulleul-banhwanhanda-ddarahajimalaya-haneun-bangbeob" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컬렉션이-비었으면-null을-반환한다-따라하지말아야-하는-방법"></a> 컬렉션이 비었으면 null을 반환한다. - 따라하지말아야 하는 방법</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 매장 안의 모든 치즈 목록을 반환한다.</span></span><br><span class="line"><span class="comment"> * 단, 재고가 하나도 없다면 null을 반환한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheess1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 절대 이렇게 처리하지말것! 서버와 클라이언트에서 모두 방어코드를 작성해야하는 불편함이 있다.</span></span><br><span class="line">    <span class="keyword">return</span> cheesesInStock.isEmpty() ? <span class="keyword">null</span> : <span class="keyword">new</span> ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 코드를 작성하면 클라이언트는 이 null 상황을 처리하는 코드를 추가로 작성해야합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cheese shop = <span class="keyword">new</span> Cheese();</span><br><span class="line">List&lt;Cheese&gt; cheeses = shop.getCheess1();</span><br><span class="line"><span class="keyword">if</span>(cheeses != <span class="keyword">null</span> &amp;&amp; cheeses.contains(Cheese.STILTON));&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello guys~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컬렉션이나 배열 같은 컨테이너(container)가 비었을 때 null을 반환하는 메서드를 사용할 때면 항시 이와 같은 방어코드를 작성해야합니다. 클라이언트에서 방어 코드를 빼먹으면 오류가 발생할 수 있다. 실제로 객체가 0개일 가능성이 거의 없는 상황에서는 수년 뒤에야 오류가 발생하기도 한다. 한편, null을 반환하려면 반환하는 쪽에서도 이 상황을 특별히 취급해줘야 해서 코드가 더 복잡해진다.</p><p>때로는 빈 컨테이너를 할당하는 데도 비용이 드니 null을 반환하는 쪽이 낫다는 주장이 있지만. 하지만 이는 두 가지면에서 틀린 주장이다.</p><ol><li>이 할당이 성능 저하의 주범이라고 확인되지 않는 한 , 이정도의 성능 차이는 신경 쓸 수준이 못 된다.</li><li>두 번째, 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.</li></ol><h2 id="bin-keolregsyeoneul-banhwanhaneun-olbareun-ye"><a href="#bin-keolregsyeoneul-banhwanhaneun-olbareun-ye" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#빈-컬렉션을-반환하는-올바른-예"></a> 빈 컬렉션을 반환하는 올바른 예</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 빈 컬렉션을 반환하는 올바른 예</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheess2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>가능성은 작지만, 사용 패턴에 따라서 빈 컬렉션 할당이 성능을 눈에 띄게 떨어뜨릴 수도 있지만, 이것에 대한 해결 방법은 매번 똑같은 빈 불변 컬렉션을 반환하면 됩니다. 불변 객체는 자유롭게 공유해도 안전합니다.</p><p>다음 코드에서 사용하는 Collections.emptyList 메서드나 집합이 필요한 경우 Collections.emptySet(), 맵이 필요하면 Collections.emptyMap()을 사용하면 됩니다. 이 역시 매우 최적화에 해당하니 되도록 꼭 필요할때만 사용하는것이 좋습니다. 반드시 성능 측정이 필요합니다.</p><h2 id="coejeoghwa-bin-keolregsyeoneul-maebeon-saero-haldanghaji-anhdorog-haessda"><a href="#coejeoghwa-bin-keolregsyeoneul-maebeon-saero-haldanghaji-anhdorog-haessda" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#최적화-빈-컬렉션을-매번-새로-할당하지-않도록-했다"></a> 최적화 - 빈 컬렉션을 매번 새로 할당하지 않도록 했다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 최적화 - 빈 컬렉션을 매번 새로 할당하지 않도록 하였다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheess3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cheesesInStock.isEmpty() ? Collections.emptyList() : <span class="keyword">new</span> ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>배열을 쓸 때도 마찬가지인데, 절대로 null을 반환하지 말고 길이가 0인 배열을 반환합니다. 보통은 단순히 정확한 길이의 배열을 반환하기만 하면 됩니다.</p><p>그 길이가 0일수도 있을뿐이고 다음코드에서 toArray메서드에 건넨 길이 0짜리 배열을 우리가 원하는 반환 타입(Cheese[])을 알려주는 역할을 합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 길이가 0일수도 있는 배열을 반환하는 올바른 방법</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Cheese[] getCheess4()&#123;</span><br><span class="line">   <span class="keyword">return</span> cheesesInStock.toArray(<span class="keyword">new</span> Cheese[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당방식이 성능을 떨어뜨릴 것 같다면 0짜리 배열을 미리 선언해두고 매번 그 배열을 반환하면 됩니다. 길이가 0인 배열은 모두 불변하기 때문입니다.</p><h2 id="coejeoghwa-bin-baeyeoleul-maebeon-saero-haldanghaji-anhdoroghayeossseubnida"><a href="#coejeoghwa-bin-baeyeoleul-maebeon-saero-haldanghaji-anhdoroghayeossseubnida" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#최적화-빈-배열을-매번-새로-할당하지-않도록하였습니다"></a> 최적화 - 빈 배열을 매번 새로 할당하지 않도록하였습니다.</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 최적화 - 빈배열을 매번 새로 할당하지 않도록 처리</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cheese[] EMPTY_CHEESE_ARRAY = <span class="keyword">new</span> Cheese[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">public</span> Cheese[] getCheess5()&#123;</span><br><span class="line">   <span class="keyword">return</span> cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 최적화 버전의 getCheeses는 항상 EMPTY_CHEESE_ARRAY를 인수로 넘겨 toArray를 호출하게 됩니다. 따라서 cheesesInStock이 비었을 때면 언제나 EMPTY_CHEESE_ARRAY를 반환하게 됩니다.</p><p>단순히 성능을 개선할 목적이라면 toArray에 넘기는 배열을 미리 할당하는 건 추천하지 않습니다. 오히려 성능을 떨어진다는 연구 결과가 있습니다.</p><h2 id="nabbeun-ye-baeyeoleul-miri-haldanghamyeon-seongneungi-nabbajinda"><a href="#nabbeun-ye-baeyeoleul-miri-haldanghamyeon-seongneungi-nabbajinda" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#나쁜-예-배열을-미리-할당하면-성능이-나빠진다"></a> 나쁜 예 - 배열을 미리 할당하면 성능이 나빠진다</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 나쁜예- 배열을 미리 할당하면 성능이 나빠진다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Cheese[] getCheess6()&#123;</span><br><span class="line">    <span class="keyword">return</span> cheesesInStock.toArray(<span class="keyword">new</span> Cheese[cheesesInStock.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jeonce-kodeu"><a href="#jeonce-kodeu" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#전체-코드"></a> 전체 코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Item54;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item54_null</span>이아닌빈컬렉션이나배열을반환하라 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cheese shop = <span class="keyword">new</span> Cheese();</span><br><span class="line">        List&lt;Cheese&gt; cheeses = shop.getCheess1();</span><br><span class="line">        <span class="keyword">if</span>(cheeses != <span class="keyword">null</span> &amp;&amp; cheeses.contains(Cheese.STILTON));&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello guys~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STILTON = <span class="string">"STILTON"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Cheese&gt; cheesesInStock = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 매장 안의 모든 치즈 목록을 반환한다.</span></span><br><span class="line"><span class="comment">         * 단, 재고가 하나도 없다면 null을 반환한다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheess1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 절대 이렇게 처리하지말것! 서버와 클라이언트에서 모두 방어코드를 작성해야하는 불편함이 있다.</span></span><br><span class="line">            <span class="keyword">return</span> cheesesInStock.isEmpty() ? <span class="keyword">null</span> : <span class="keyword">new</span> ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 빈 컬렉션을 반환하는 올바른 예</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheess2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 최적화 - 빈 컬렉션을 매번 새로 할당하지 않도록 하였다.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheess3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cheesesInStock.isEmpty() ? Collections.emptyList() : <span class="keyword">new</span> ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 길이가 0일수도 있는 배열을 반환하는 올바른 방법</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Cheese[] getCheess4()&#123;</span><br><span class="line">            <span class="keyword">return</span> cheesesInStock.toArray(<span class="keyword">new</span> Cheese[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 최적화 - 빈배열을 매번 새로 할당하지 않도록 처리</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cheese[] EMPTY_CHEESE_ARRAY = <span class="keyword">new</span> Cheese[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">public</span> Cheese[] getCheess5()&#123;</span><br><span class="line">            <span class="keyword">return</span> cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 나쁜예- 배열을 미리 할당하면 성능이 나빠진다.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Cheese[] getCheess6()&#123;</span><br><span class="line">            <span class="keyword">return</span> cheesesInStock.toArray(<span class="keyword">new</span> Cheese[cheesesInStock.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>핵심 정리</p></blockquote><p>null이 아닌, 빈 배열이나 컬렉션을 반환하라. null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다. 그렇다고 성능이 좋은것도 아니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nulli-anin-bin-keolregsyeonina-baeyeoleul-banhwanhara&quot;&gt;&lt;a href=&quot;#nulli-anin-bin-keolregsyeonina-baeyeoleul-banhwanhara&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gwanhyeon.github.io/categories/java/"/>
    
    
      <category term="EffectiveJava3/E" scheme="http://gwanhyeon.github.io/tags/effectivejava3-e/"/>
    
  </entry>
  
  <entry>
    <title>Network HTTP(HyperText Transfer Protocal) 구조 및 HTTP 메시지 구조</title>
    <link href="http://gwanhyeon.github.io/Network-20210121-network-06-http/"/>
    <id>http://gwanhyeon.github.io/Network-20210121-network-06-http/</id>
    <published>2021-01-21T07:58:03.000Z</published>
    <updated>2021-01-26T07:21:51.130Z</updated>
    
    <content type="html"><![CDATA[<p>웹에서 가장 중요한 요소라고 할 수 있는 HTTP(Hyper Text Transfer Protocal)에 대해서 살펴보도록 하겠습니다.<br>들어가기 앞서 HTTP가 왜 중요할까요?</p><p><code>클라이언트-서버 구조</code>에서 데이터를 전송하기위해 필수 불가결한 요소입니다. <code>HTTP 메시지</code>에 <code>모든것들을 전송</code>할 수 있기때문입니다.<br>HTTP는 <code>HTML, TEXT, Image, 음성, 영상, 파일, JSON, XML(API)</code> 거의 모든 형태의 데이터로 전송이 가능하기 때문에 상당히 네트워크에서 중요한 부분을 차지하고 있습니다.</p><h1 id="http-hyper-text-transfer-protocal-heureum"><a href="#http-hyper-text-transfer-protocal-heureum" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#httphyper-text-transfer-protocal-흐름"></a> HTTP(Hyper Text Transfer Protocal) 흐름</h1><ul><li>HTTP/0.9 1991년에 GET메서드만 지원하는 형태로 나오게 되었으며 HTTP 헤더는 가지고 있지 않았습니다.</li><li>HTTP/1.0 1996년 메서드와 헤더가 추가 되었습니다.</li><li><strong>HTTP/1.1 1997년 가장 많이 사용되었으며 현재 우리에게 가장 중요한 버전이라고 할 수 있습니다.(RFC2068 -&gt; RFC2616 -&gt; RFC7230~7235(2014)) 의 스펙으로 진화되어 왔습니다.</strong></li><li>HTTP/2 2015년에 성능개선을 이루게 되었습니다.</li><li>HTTP/3 현재 개발이 진행되고 있으며 TCP대신에 UDP사용, 성능개선을 이루어 내고 있습니다.</li></ul><blockquote><p>여기서 가장 중요한 부분은 어디일까요?<br>HTTP표준스펙처럼 자리잡은 HTTP/1.1 버전을 웹에서는 주로 사용하고 있습니다.</p></blockquote><h1 id="http-hyper-text-transfer-protocal-giban-peurotokol"><a href="#http-hyper-text-transfer-protocal-giban-peurotokol" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#httphyper-text-transfer-protocal-기반-프로토콜"></a> HTTP(Hyper Text Transfer Protocal) 기반 프로토콜</h1><ol><li><p>TCP<br>HTTP/1.1, HTTP/2</p></li><li><p>UDP<br>HTTP/3, HTTP/1.1을 주로사용하고 하고 점차적으로  HTTP/2, HTTP/3의 사용 점유율도 상승되고 있습니다.</p></li></ol><p>이러한것들을 실제로 웹상에서 확인해보고 싶으면, 개발자모드-네트워크도구탭에서 어떠한 HTTP프로토콜이 이용되어져 있고 기반 프로토콜은 무엇을 주로 사용하는지 확인할 수 있습니다.</p><h1 id="http-hyper-text-transfer-protocal-teugjing"><a href="#http-hyper-text-transfer-protocal-teugjing" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#httphyper-text-transfer-protocal-특징"></a> HTTP(Hyper Text Transfer Protocal) 특징</h1><ol><li>클라이언트-서버 구조를 가지고 있습니다.</li><li>무상태성 프로토콜(Stateless), 비연결성</li><li>HTTP 메시지</li><li>단순함, 확장기능을 가지고 있습니다.</li></ol><h1 id="keulraieonteu-client-seobeo-server-gujo"><a href="#keulraieonteu-client-seobeo-server-gujo" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#클라이언트client-서버server-구조"></a> 클라이언트(Client)- 서버(Server) 구조</h1><ul><li>요청(request), 응답(Response) 구조를 가지고 있습니다.</li><li>클라이언트는 서버에 요청을 보내고 응답을 대기합니다.</li><li>서버가 요청에 대한 결과를 만들어서 응답하게 됩니다.</li></ul><h1 id="musangtae-peurotokol-stateless"><a href="#musangtae-peurotokol-stateless" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#무상태-프로토콜stateless"></a> 무상태 프로토콜(Stateless)</h1><ul><li>서버가 클라이언트의 상태를 보존하지 않습니다.</li><li>서버의 확장성이 매우 높은 장점을 가지고 있습니다.(Scale-out)</li><li>클라이언트가 추가 데이터를 전송해야한다는 단점을 가지고 있습니다.</li></ul><h1 id="stateful-sangtaeyuji-vs-stateless-musangtaeseong"><a href="#stateful-sangtaeyuji-vs-stateless-musangtaeseong" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#stateful상태유지-vs-stateless무상태성"></a> Stateful(상태유지) VS Stateless(무상태성)</h1><p>이커머스 환경에서 제품 구매하는 예제를 들 수 있습니다. 고객이 점원에게 물품을 구매할때 도중에 상태가 변경되거나 Context가 변화하게 되어도 상태를 유지하기가 쉽습니다.(무상태성) 그에 반해 Stateful은 어떤 상태인지 계속 알고 있기때문에 중간에 상태가 변경되거나 Context가 변화가 없도록 하여야 합니다.</p><blockquote><p>차이 정리</p></blockquote><blockquote><p>Stateful:</p></blockquote><ul><li>중간에 다른상태로 변경되면 X</li><li>항상 같은 서버가 유지되어야 합니다.</li><li>서버가 터지게 되면 상태보존하는데 보존이 불가능합니다.</li></ul><blockquote><p>Stateless:</p></blockquote><ul><li>중간에 다른상태로 변경 OK</li><li>트래픽이 증가해도 다양한 스케일아웃 많은 서버들을 Scale-out이 가능합니다.</li><li>Stateless는 응답 서버를 쉽게 변경이 가능하기 때문에 무한한 서버를 증설을 할 수 있습니다.</li><li>트래픽이 몰리는경우가 많을 경우 정적페이지를 띄워놓고 요청 트래픽을 분산시킬 수 있는 방식으로 설계해야합니다.</li><li>모든것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있습니다.</li><li>로그인시 브라우저쿠키나 서버세션을 이용하여 상태를 유지합니다.</li><li>상태유지는 최소한만 사용해야합니다.</li></ul><h1 id="biyeongyeolseong-connectionsless"><a href="#biyeongyeolseong-connectionsless" class="header-anchor">7. </a><a class="markdownIt-Anchor" href="#비연결성connectionsless"></a> 비연결성(connectionsless)</h1><blockquote><p>연결 유지 모델</p></blockquote><ul><li>클라이언트-서버 구조에서는 클라이언트가 요청후 TCP/IP에 연결한후 HTTP 서버요청을 진행합니다.</li><li>서버는 연결을 계속 유지함에 따라 서버 자원 소모가 증가될 수 있습니다.</li><li></li></ul><blockquote><p>연결 비유지 모델</p></blockquote><ul><li>클라이언트가 요청후 서버에게 응답을 받을때 TCP/IP 연결을 종료시켜버립니다.</li><li>서버는 연결을 유지하지 않고, 최소한의 자원을 유지합니다.</li></ul><h1 id="biyeongyeolseong-connectionsless-teugjing"><a href="#biyeongyeolseong-connectionsless-teugjing" class="header-anchor">8. </a><a class="markdownIt-Anchor" href="#비연결성connectionsless-특징"></a> 비연결성(connectionsless) 특징</h1><ul><li>HTTP는 기본이 연결을 유지하지 않는 모델입니다.(Default)</li><li>초 단위의 이하의 빠른 속도로 응답을 합니다.</li><li>실제 서비스에서 서비스를 사용해도 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작습니다.</li><li>서버 자원을 매우 효율적으로 사용할 수 있습니다.</li></ul><h1 id="biyeongyeolseong-connectionsless-hangye"><a href="#biyeongyeolseong-connectionsless-hangye" class="header-anchor">9. </a><a class="markdownIt-Anchor" href="#비연결성connectionsless-한계"></a> 비연결성(connectionsless) 한계</h1><ul><li>자원을 받을때 마다 TCP/IP 연결을 새로 맺어야합니다.(3-way-handshake 시간 증대)</li><li>웹 브라우저로 사이트를 요청하면 HTML뿐만 아니라 html,css,js,image files 등 많은 Resource를 다운로드 받습니다.</li><li>HTTP/2, HTTP/3에서 더 많은 최적화를 지원합니다.</li></ul><p>HTTP초기에는 연결,종료를 낭비가 많았는데 그 이유는 매번 요청마다 분리를 해야했기 때문입니다. 그래서 나온것이 HTTP 지속 연결(Persistent Connections)입니다.</p><p>지속 연결의 과정은 요청-&gt; 응답 -&gt; 유지 (내부 매커니즘으로 지속연결을 계속 진행합니다.)</p><blockquote><p>정리</p></blockquote><p>Stateless같은 경우는 동시간에 진행되는 실시간 대용량 트래픽에 매우 용이 합니다.<br>예를 들면, 수만명의 트래픽이 들어왔다고 가정하면 Stateles 환경에 서버 요청이 많아집니다. 이에 따른 대응방식으로 정적페이지나 HTML을 먼저 렌더링 시켜준후 해당 본 요청 이벤트를 처리하는 로직으로 진행합니다.</p><h1 id="http-mesijigujo"><a href="#http-mesijigujo" class="header-anchor">10. </a><a class="markdownIt-Anchor" href="#http-메시지구조"></a> HTTP 메시지구조</h1><h2 id="http-yoceongmesiji-gujo"><a href="#http-yoceongmesiji-gujo" class="header-anchor">10.1. </a><a class="markdownIt-Anchor" href="#http-요청메시지-구조"></a> HTTP 요청메시지 구조</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. start-line 시작라인(HTTP메서드, 요청대상, HTTP Version)</span><br><span class="line">2. header 헤더(표준헤더 많음, 헤더추가도 가능함)</span><br><span class="line">3. empty line 공백라인(CRLF) - RFC7230 표준</span><br><span class="line">4. message body</span><br></pre></td></tr></table></figure><blockquote><p>HTTP 요청메시지 예시</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. GET /search?q=hello&amp;hl=ko HTTP/1.1 (start-line)</span><br><span class="line">2. Host: www.google.com (header)</span><br><span class="line">3. (empty line)</span><br></pre></td></tr></table></figure><p>요청메시지도 body본문을 가질수 있습니다.</p><h2 id="http-eungdab-mesiji-gujo"><a href="#http-eungdab-mesiji-gujo" class="header-anchor">10.2. </a><a class="markdownIt-Anchor" href="#http-응답-메시지-구조"></a> HTTP 응답 메시지 구조</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. start-line 시작라인(HTTP버전, HTTP상태코드, 요청 및 성공)</span><br><span class="line">2. header 헤더(표준헤더 많음, 헤더추가도 가능함)</span><br><span class="line">3. empty line 공백라인(CRLF) - RFC7230 표준</span><br><span class="line">4. message body(실제 전송데이터 HTML,이미지,영상,JSON, XML 등 byte표현가능한 모든 데이터)</span><br></pre></td></tr></table></figure><blockquote><p>HTTP 응답메시지 예시</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. HTTP/1.1 200 OK (start-line)</span><br><span class="line">2. Content-Type:text/html;charset=UTF-8    (header)</span><br><span class="line">3. Content-Length: 3423    (empty line)</span><br><span class="line"></span><br><span class="line">4.(message body)</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>                  </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>..<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>정리</p></blockquote><ul><li>HTTP1.1 기준</li><li>클라이언트,서버 구조</li><li>무상태 프로토콜(Stateless)</li><li>HTTP 메시지 구조</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;웹에서 가장 중요한 요소라고 할 수 있는 HTTP(Hyper Text Transfer Protocal)에 대해서 살펴보도록 하겠습니다.&lt;br&gt;
들어가기 앞서 HTTP가 왜 중요할까요?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;클라이언트-서버 구조&lt;/code&gt;에서 
      
    
    </summary>
    
    
      <category term="Network" scheme="http://gwanhyeon.github.io/categories/network/"/>
    
    
      <category term="network" scheme="http://gwanhyeon.github.io/tags/network/"/>
    
      <category term="http" scheme="http://gwanhyeon.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>릿코드 Trapping Rain Water</title>
    <link href="http://gwanhyeon.github.io/Leetcode-20210118-leetcode-trapping-rain-water/"/>
    <id>http://gwanhyeon.github.io/Leetcode-20210118-leetcode-trapping-rain-water/</id>
    <published>2021-01-18T04:00:24.000Z</published>
    <updated>2021-01-21T09:24:35.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-trapping-rain-water"><a href="#leetcode-trapping-rain-water" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#leetcode-trapping-rain-water"></a> <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">leetcode Trapping Rain Water</a></h1><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><p>해당 문제는 릿코드 Hard 난이도 문제이며 비가 내린후 빗물의 컨테이너에 채워지는 빗물의 양을 구하는 문제입니다.</p><ul><li>(1) 왼쪽에 가장 작은 인덱스와 오른쪽 가장 큰 인덱스와 모든 빗물중에 가장 큰 인덱스도 구해줍니다. 그 이유는 왼쪽인덱스~빗물양이 가장 큰 인덱스, 오른쪽인덱스~빗물양이 가장 큰 인덱스 2가지 경우로 나누어서 계산하기 위함입니다.</li><li>(2) 기존에 입력으로 주어진 빗물의 크기(왼쪽 + 오른쪽)와 진행하면서 가장 큰 높이의 빗물기준으로 빗물의 크기를 구해줍니다.</li><li>(3) 기존의 컨테이너로 가둘 수 있는 빗물을 가둘 수 있는 최대의 크(컨테이너+빗물) - 입력으로 주어진 컨테이너의 높이를 계산해주면 최종적으로 담겨진 빗물의 크기를 알 수 있습니다.</li></ul><p>시간복잡도: O(N) 선형시간</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_trapping_rain_water_kgh</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        trap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        trap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        trap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMax = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMin = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 가장 작은 인덱스 값 찾기</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                isMin = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 연속적으로 0이 나오는 경우</span></span><br><span class="line">                <span class="keyword">if</span>(isMin)&#123;</span><br><span class="line">                    minIdx = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 0이 나오기전에 가장 작은 인덱스를 찾은 경우</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    minIdx = Math.min(minIdx, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가장 큰 인덱스값 찾기</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=height.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                maxIdx = i;</span><br><span class="line">                isMax = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 연속적으로 0이 나온경우</span></span><br><span class="line">                <span class="keyword">if</span>(isMax)&#123;</span><br><span class="line">                    maxIdx = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 0이 나오기전에 가장 큰 인덱스를 찾은 경우</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxIdx = Math.max(maxIdx, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(minIdx + <span class="string">" "</span> + maxIdx);</span><br><span class="line">        <span class="keyword">int</span> maxHightIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 빗물중에서 가장 큰 인덱스 값 찾기</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[maxHightIdx])&#123;</span><br><span class="line">                maxHightIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 왼쪽 가장 작은 인덱스 ~ 가장 큰 인덱스까지 가장 큰 높이 기준으로 빗물 크기를 구합니다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=minIdx; i&lt;maxHightIdx; i++)&#123;</span><br><span class="line">            <span class="comment">// 기존 빗물 크기의 합</span></span><br><span class="line">            leftSum += height[i];</span><br><span class="line">            <span class="comment">// 진행되면서 가장 큰 높이 빗물 기준으로 총 빗물양 구하기</span></span><br><span class="line">            h = Math.max(height[i], h);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 높이 초기화</span></span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightSum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 오른쪽 가장 큰 인덱스 ~ 가장 큰 인덱스까지 가장 큰 높이 기준으로 빗물 크기를 구합니다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=maxIdx; i&gt;maxHightIdx; i--)&#123;</span><br><span class="line">            rightSum += height[i];</span><br><span class="line">            h = Math.max(height[i], h);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum + <span class="string">" "</span> + leftSum + <span class="string">" "</span>+ rightSum);</span><br><span class="line">        <span class="keyword">return</span> sum-(leftSum + rightSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;leetcode-trapping-rain-water&quot;&gt;&lt;a href=&quot;#leetcode-trapping-rain-water&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://gwanhyeon.github.io/categories/leetcode/"/>
    
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="릿코드" scheme="http://gwanhyeon.github.io/tags/%EB%A6%BF%EC%BD%94%EB%93%9C/"/>
    
  </entry>
  
  <entry>
    <title>Spring 빈(Bean)과 의존관계, DI(Dependency Injection)</title>
    <link href="http://gwanhyeon.github.io/Spring-20210117-spring-dependency-injection/"/>
    <id>http://gwanhyeon.github.io/Spring-20210117-spring-dependency-injection/</id>
    <published>2021-01-17T04:08:13.000Z</published>
    <updated>2021-01-17T04:43:15.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seupeuring-keonteineo-ioc-jeeo-banjeon-inversion-of-control-keonteineo"><a href="#seupeuring-keonteineo-ioc-jeeo-banjeon-inversion-of-control-keonteineo" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#스프링-컨테이너-ioc제어-반전-inversion-of-control-컨테이너"></a> 스프링 컨테이너, IoC(제어 반전 Inversion of control) 컨테이너</h1><p><code>스프링 Bean과 DI(Dependency Injection)의 개념</code>에 대해서 살펴보기전에 <code>스프링 컨테이너(IoC)의 특징</code>을 살펴보겠습니다.</p><ul><li><p>스프링 애플리케이션에서는 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립된 컨테이너가 담당하게 됩니다. 컨테이너가 코드 대신 오브젝트에 대한 제어권 을 갖기때문에 IoC라고 부릅니다. <code>즉, 스프링컨테이너라는 것은 IoC컨테이너와 같은 말로 쓰여집니다.</code></p></li><li><p><code>스프링 컨테이너는 DI(Dependency Injection)보다 많은 일들을 담당</code>하게 됩니다. 예를 들면,<br>DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는 데 필요한 여러 가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트를 관리하게 됩니다.</p></li><li><p>스프링의 빈 팩토리와 애플리케이션 컨텍스트는 각각 기능을 <code>대표하는 BeanFactory와 ApplicationContext라는 두 개의 인터페이스</code>로 정의 되어있습니다.</p></li><li><p>ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속한 서브 인터페이스 입니다.</p></li></ul><h1 id="di-dependency-injection"><a href="#di-dependency-injection" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#didependency-injection"></a> DI(Dependency Injection)</h1><p>스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 객체 의존관계를 외부에서 넣어주는 것을 <code>DI (Dependency Injection), 의존성 주입</code>이라 합니다.</p><h1 id="seupeuringbingwa-yijongwangye"><a href="#seupeuringbingwa-yijongwangye" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#스프링빈과-의존관계"></a> 스프링빈과 의존관계</h1><p>컨트롤러와 서비스에 대한 레포지토리를 만들때 <code>@Autowired가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어줍니다.</code> 그렇게 객체 의존관계를 외부에서 넣어주는것을 <code>DI(Dependency Injetion)</code>이라 하며 이전 테스트 에서는 개발자가 직접 주입을 시켰지만 이제는 <code>@autowired에 의해 스프링이 주입</code>해줍니다.</p><blockquote><p>스프링 빈이 등록되어 있지 않다면?</p></blockquote><p>만약 컨트롤러와 서비스간의 스프링 빈이 등록되어 있지 않다면 <code>@Controller가 스프링빈</code>으로 자동등록해주거나 직접 자바코드로 직접 스프링빈을 등록할 수 있습니다. 그 이유는 <code>@Controller에 포함되어있는 @Component 어노테이션이 빈으로 등록</code>을 해주기 때문입니다. 그 외는 <code>SpringConfig라는 설정파일을 만들어서 직접 자바코드로 스프링빈</code>을 등록하게 할 수 있다.</p><h1 id="keomponeonteu-seukaenyi-weonri"><a href="#keomponeonteu-seukaenyi-weonri" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#컴포넌트-스캔의-원리"></a> 컴포넌트 스캔의 원리</h1><blockquote><p>컴포넌트 스캔은 어떤 원리를 가지고 있을까요?</p></blockquote><p>@Component 애노테이션이 있으면 스프링빈으로 자동등록 됩니다.바로 @Controller가 스프링빈으로 등록된 이유도 컴포넌트 스캔때문이라고 할 수 있습니다.</p><p>@Component을 포함하는 애노테이션은 다음과 같습니다. <code>@Controller, @Service @Repository가 있습니다.</code> 즉, <code>스프링 빈으로 자동등록</code>된다는 말입니다.</p><p>결론, 생성자에 @Autowired를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입해줍니다. 생성자가 1개만 있으면 @Autowired는 생략이 가능합니다.</p><p>스프링은 스프링 컨테이너에서 스프링 빈을 등록할 때, 기본적으로 <code>싱글톤으로 등록합니다(유일하게 하나만 등록해서 공유하고) 같은 스프링 빈이면 모두 같은 인스턴스</code>이다. 싱글톤이 아니게 설정할 수 있지만, 특별한 경우 제외하면 대부분 싱글톤을 사용합니다.</p><h1 id="di-dependency-injection-juib"><a href="#di-dependency-injection-juib" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#didependency-injection-주입"></a> DI(Dependency Injection) 주입</h1><p><code>DI주입</code>은 <code>필드주입, setter주입, 생성자 주입 총 3가지 방법</code>이 있습니다.</p><p>의존관계가 실행중 동적으로 변하는 경우는 거의 없기때문에 생성자 주입을 통한 DI주입을 권장합니다. DI주입시 주의사항은 @Autowired를 통한 DI는 Controller, Service등과 같이 스프링이 관리하는 객체에서만 동작하게 됩니다. <code>스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작되지 않습니다.</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;seupeuring-keonteineo-ioc-jeeo-banjeon-inversion-of-control-keonteineo&quot;&gt;&lt;a href=&quot;#seupeuring-keonteineo-ioc-jeeo-banjeon-inversion-o
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/categories/spring/"/>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/tags/spring/"/>
    
      <category term="IoC" scheme="http://gwanhyeon.github.io/tags/ioc/"/>
    
      <category term="DI" scheme="http://gwanhyeon.github.io/tags/di/"/>
    
      <category term="컴포넌트 스캔" scheme="http://gwanhyeon.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%EC%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>Network 웹 브라우저의 요청 흐름</title>
    <link href="http://gwanhyeon.github.io/Network-20210115-network-05-web-browser-request-flow/"/>
    <id>http://gwanhyeon.github.io/Network-20210115-network-05-web-browser-request-flow/</id>
    <published>2021-01-15T13:25:39.000Z</published>
    <updated>2021-01-15T14:00:35.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-beuraujeo-yoceong-heureum"><a href="#web-beuraujeo-yoceong-heureum" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#웹-브라우저-요청-흐름"></a> 웹 브라우저 요청 흐름</h1><p>웹 브라우저에 대한 요청흐름에 대해서 살펴보겠습니다. 예시로 된 IP이기때문에 실제와 같지 않습니다.<br>웹브라우저: 127.0.0.1<br>구글서버: 127.0.0.2<br>요청 URL: <code>https://www.google.com:443/search?q=google&amp;oq=google</code></p><blockquote><p>다음과 같이 웹브라우저와 구글서버 IP, 요청 URL이 주어졌다고 가정하면 어떤일이 발생하게 될까요?</p></blockquote><ol><li>웹브라우저가 요청 URL에 접근을 요청합니다.</li><li>DNS(Domain Name System)에서 해당되는 DNS의 IP를 조회해옵니다.</li><li>조회해 온 127.0.0.2 IP를 바탕으로 HTTP 요청 메시지를 생성합니다.</li></ol><ul><li>HTTP 요청 메시지</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /search?q=google&amp;oq=google HTTP/1.1</span><br><span class="line">Host:www.google.com</span><br></pre></td></tr></table></figure><ol start="4"><li>HTTP 요청 메시지를 바탕으로 HTTP 메시지를 웹 브라우저상에 전송합니다.</li></ol><h1 id="http-mesiji-jeonsonggwajeong"><a href="#http-mesiji-jeonsonggwajeong" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#http-메시지-전송과정"></a> HTTP 메시지 전송과정</h1><ol><li>웹 브라우저가 HTTP 메시지를 생성합니다.</li><li>SOCKET 라이브러리를 통해 해당 HTTP 메시지를 전달합니다.<br>TCP/IP를 연결(IP,PORT)에 대해서 데이터 전달을 진행합니다.</li><li>TCP/IP 패킷을 생성하여, HTTP 메시지를 포함시킵니다.</li><li>네트워크인터페이스인 LAN 장비를 통하여 인터넷으로 해당 메시지와 데이터를 전송합니다.</li><li>최종적으로 <a href="http://google.com" target="_blank" rel="noopener">google.com</a>(127.0.0.2) 서버에 도달하게 됩니다.</li></ol><h1 id="paekis-saengseong"><a href="#paekis-saengseong" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#패킷-생성"></a> 패킷 생성</h1><blockquote><p>TCP/IP패킷은 어떤 구조로 구성되어있을까요?</p></blockquote><p>출발지 IP, 출발지 PORT, 목적지 IP, 목적지 PORT, 전송 데이터, 그 외 기타의 설정들이 담겨져 있습니다.<br>즉, 출발지 IP, 출발지 PORT, 목적지 IP, 목적지 PORT는 TCP/IP 패킷으로 구성되어 있으며 HTTP메시지는 TCP/IP 패킷안에 HTTP 메시지가 포함되어 있는 형태로 볼 수 있습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># TCP/IP 패킷(상위 개념)</span><br><span class="line">----------------------------</span><br><span class="line">출발지 IP,PORT</span><br><span class="line">목적지 IP,PORT</span><br><span class="line">----------------------------</span><br><span class="line"># HTTP 메시지(하위 개념)</span><br><span class="line">GET /search?q=google&amp;oq=google HTTP/1.1</span><br><span class="line">Host:www.google.com</span><br><span class="line">----------------------------</span><br></pre></td></tr></table></figure><h1 id="http-eungdab-mesiji"><a href="#http-eungdab-mesiji" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#http-응답-메시지"></a> HTTP 응답 메시지</h1><blockquote><p>이제 이렇게 웹 브라우저에 요청에 대한 서버는 응답값은 어떤 형식으로 오게 될까요?</p></blockquote><p>정상적으로 요청에 대한 값을 받고 응답에 대한 패킷을 전달할때 응답패킷 형태로(TCP/IP, HTTP 메시지)를 함께 전송하게 됩니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> ~ <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="web-beuraujeo-rendeoring"><a href="#web-beuraujeo-rendeoring" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#웹-브라우저-렌더링"></a> 웹 브라우저 렌더링</h1><p>웹 브라우저의 요청을 통해서 서버에 대한 응답 요청 패킷을 전달받은 웹브라우저는 응답 패킷으로 넘어온 TCP/IP, HTTP 메시지에 포함된 데이터를 바탕으로 HTML 렌더링을 진행합니다.</p><h1 id="httpyi-teugjing"><a href="#httpyi-teugjing" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#http의-특징"></a> HTTP의 특징</h1><ul><li>The World Wide Web (WWW)은 모든것이 대부분 HTTP형태로 통신</li><li>Client-Server 구조</li><li>Stateful : server side에 client와 server의 동작, 상태정보를 저장하는 형태, 세션 상태에 기반하여 server의 응답이 달라짐</li><li>Stateless : server side에 client와 server의 동작, 상태정보를 저장하지 않는 형태, server의 응답이 client와의 세션 상태와 독립적</li><li>비 연결성(Connetionless)</li><li>HTTP 메시지</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web-beuraujeo-yoceong-heureum&quot;&gt;&lt;a href=&quot;#web-beuraujeo-yoceong-heureum&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
      <category term="Network" scheme="http://gwanhyeon.github.io/categories/network/"/>
    
    
      <category term="network" scheme="http://gwanhyeon.github.io/tags/network/"/>
    
      <category term="웹브라우저" scheme="http://gwanhyeon.github.io/tags/%EC%9B%B9%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80/"/>
    
      <category term="TCP/IP" scheme="http://gwanhyeon.github.io/tags/tcp-ip/"/>
    
      <category term="HTTP" scheme="http://gwanhyeon.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>릿코드 Search Insert Position</title>
    <link href="http://gwanhyeon.github.io/Leetcode-20210114-leetcode-search-insert-position/"/>
    <id>http://gwanhyeon.github.io/Leetcode-20210114-leetcode-search-insert-position/</id>
    <published>2021-01-14T10:09:42.000Z</published>
    <updated>2021-01-14T11:12:57.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riskodeu-search-insert-position"><a href="#riskodeu-search-insert-position" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#릿코드-search-insert-position"></a> <a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">릿코드 search insert position</a></h1><h1 id="munje"><a href="#munje" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h1><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><h3 id="example-1"><a href="#example-1" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#example-1"></a> Example 1:</h3><p>Input: nums = [1,3,5,6], target = 5<br>Output: 2</p><h3 id="example-2"><a href="#example-2" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#example-2"></a> Example 2:</h3><p>Input: nums = [1,3,5,6], target = 2<br>Output: 1</p><h3 id="example-3"><a href="#example-3" class="header-anchor">2.3. </a><a class="markdownIt-Anchor" href="#example-3"></a> Example 3:</h3><p>Input: nums = [1,3,5,6], target = 7<br>Output: 4</p><h3 id="example-4"><a href="#example-4" class="header-anchor">2.4. </a><a class="markdownIt-Anchor" href="#example-4"></a> Example 4:</h3><p>Input: nums = [1,3,5,6], target = 0<br>Output: 0</p><h3 id="example-5"><a href="#example-5" class="header-anchor">2.5. </a><a class="markdownIt-Anchor" href="#example-5"></a> Example 5:</h3><p>Input: nums = [1], target = 0<br>Output: 0</p><h3 id="constraints"><a href="#constraints" class="header-anchor">2.6. </a><a class="markdownIt-Anchor" href="#constraints"></a> Constraints:</h3><p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums contains distinct values sorted in ascending order.<br>-104 &lt;= target &lt;= 104</p><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>binarySearch 함수를 구현하여 해당되는 타겟값이 있으면 해당 인덱스를 반환하고 그렇지 않으면 -1을 반환합니다.</li><li>insertBinarySearch 함수를 구현하여 현재 해당되는 Target의 끝지점 인덱스를 찾아 반환합니다. end는 target값의 이전인덱스이기 때문에 end+1을 반환시켜줍니다.</li></ul><blockquote><p>시간복잡도</p></blockquote><p>이진탐색 O(logN)</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_search_insert_position</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(searchInsert(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = binarySearch(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(answer == -<span class="number">1</span>)&#123;</span><br><span class="line">            answer = insertBinarySearch(nums,target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 해당되는 타겟값이 있으면 해당 인덱스 반환, 그렇지 않으면 -1 반환</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 타겟의 끝지점을 찾는다. End점에는 결국에는 해당되는 값의 마지막지점 인덱스가 저장되어있다.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertBinarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;riskodeu-search-insert-position&quot;&gt;&lt;a href=&quot;#riskodeu-search-insert-position&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://gwanhyeon.github.io/categories/leetcode/"/>
    
    
      <category term="릿코드" scheme="http://gwanhyeon.github.io/tags/%EB%A6%BF%EC%BD%94%EB%93%9C/"/>
    
      <category term="binarysearch" scheme="http://gwanhyeon.github.io/tags/binarysearch/"/>
    
      <category term="이진탐색" scheme="http://gwanhyeon.github.io/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring Lombok @Annotation(어노테이션)</title>
    <link href="http://gwanhyeon.github.io/Spring-20210114-spring-lombok-annotation/"/>
    <id>http://gwanhyeon.github.io/Spring-20210114-spring-lombok-annotation/</id>
    <published>2021-01-14T09:13:01.000Z</published>
    <updated>2021-01-14T09:15:13.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lombok-library-annotation"><a href="#lombok-library-annotation" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#lombok-library-annotation"></a> Lombok library @Annotation</h1><h2 id="lombok"><a href="#lombok" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#lombok"></a> Lombok</h2><p>Lombok(롬복)은 MIT 라이선스로 배포되는 오픈소스 라이브러리로서 annotation 주석으로 VO(Value Object), DTO(Data Transfort Object), Entity Class 등을 만들때 Getter/Setter 및 toString()을 자동화 시켜줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.</span><br><span class="line">Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</span><br></pre></td></tr></table></figure><p><a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok 공식 사이트</a></p><blockquote><p>Lombok 사용방법</p></blockquote><p>Lombok을 사용하기 위해서는 해당 라이브러리를 다운을 받아야합니다. IntellJ같은 경우는 플러그인을 설치하여 Lombok을 다운받으면 되고 Gradle or Maven Dependency를 추가해주어야합니다.<br>모든 설치가 완료되면</p><blockquote><p>IntellJ Configuration</p></blockquote><p><code>IntelliJ의 File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors를 선택 한 후 &quot;Enable annotation processing&quot;을 체크</code><br>해당 설정을 해주는 이유는 Lombok을 작업중에도 동작시키기 위해서는 해당과 같은 설정을 해주셔야 Lombok이 정상적으로 동작하게 됩니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># gradle</span><br><span class="line">configurations &#123;</span><br><span class="line">    compileOnly &#123;</span><br><span class="line">      extendsFrom annotationProcessor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.projectlombok:lombok'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># maven</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">   &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="getter-setter"><a href="#getter-setter" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#getter-setter"></a> @Getter, @Setter</h2><p>Lombok에서 가장 많이 사용되는 어노테이션인 @Getter와 @Setter에 대해서 설명드리겠습니다.<br>기존에 스프링에서는 필드를 선언하면 명시적으로 선언을 매번해주어야하였지만, Lombok을 사용하면 필드를 선언하면 Getter(),Setter()  메소드를 자동으로 생성해줍니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> item;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> user;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lombok 사용시 필요없는 코드</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(<span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필드 레벨이 아닌 클래스 레벨에 @Getter 또는 @Setter를 선언해줄 경우, 모든 필드에 접근자와 설정자가 자동으로 생성됩니다.</p><h2 id="noargsconstructor"><a href="#noargsconstructor" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#noargsconstructor"></a> NoArgsConstructor</h2><p>@NoArgsConstructor 어노테이션은 파라미터가 없는 기본 생성자를 생성해줍니다.</p><h2 id="allargsconstructor"><a href="#allargsconstructor" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#allargsconstructor"></a> @AllArgsConstructor</h2><p>@AllArgsConstructor 어노테이션은 모든 필드 값을 파라미터로 받는 생성자를 만들어줍니다.</p><h2 id="requiredargsconstructor"><a href="#requiredargsconstructor" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#requiredargsconstructor"></a> @RequiredArgsConstructor</h2><p>@RequiredArgsConstructor 어노테이션은 final이나 @NonNull인 필드 값만 파라미터로 받는 생성자를 만들어줍니다.</p><h2 id="data"><a href="#data" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#data"></a> @Data</h2><p>Class Level에서 @Data 어노테이션을 붙여주면, 모든 필드를 대상으로 접근자와 설정자가 자동으로 생성됩니다. 그리고, final 또는 @NonNull 필드 값을 파라미터로 받는 생성자가 만들어지며, toStirng, equals, hashCode 메소드가 자동으로 생성되게 됩니다. 개인적으로는 @Data를 무분별하게 사용하면 나중에 유지보수측면에서 시간이 많이 소요되고 불필요한 소스양이 늘어날 것으로 생각하며 결론적으로 @Data는 지양하고 무분별한 Setter 남용을 하지 않도록 해야할 것입니다.</p><h2 id="builder"><a href="#builder" class="header-anchor">1.7. </a><a class="markdownIt-Anchor" href="#builder"></a> @Builder</h2><p>@Builder Annotation은 모델 객체를 생성할 때 Builder를 자동으로 추가해 주는 Annotation입니다. 해당 Annotation을 사용하면 Builder Pattern을 적용할 수 있습니다.</p><blockquote><p>Builder Annotation 미적용</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserBuilder();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Builder Class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="keyword">this</span>.name);</span><br><span class="line">    user.setAge(<span class="keyword">this</span>.age);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Builder Annotation 적용</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Builder pattern 사용</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = User.builder()</span><br><span class="line">                  .name(<span class="string">"KGH"</span>)</span><br><span class="line">                  .age(<span class="number">100</span>)</span><br><span class="line">                  .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>References</p></blockquote><p><a href="https://projectlombok.org/features/" target="_blank" rel="noopener">https://projectlombok.org/features/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lombok-library-annotation&quot;&gt;&lt;a href=&quot;#lombok-library-annotation&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lom
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/categories/spring/"/>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/tags/spring/"/>
    
      <category term="Annotation" scheme="http://gwanhyeon.github.io/tags/annotation/"/>
    
      <category term="Lombok" scheme="http://gwanhyeon.github.io/tags/lombok/"/>
    
  </entry>
  
</feed>
