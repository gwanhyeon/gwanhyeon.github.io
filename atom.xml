<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Ethan Kim IT Blog</title>
  
  <subtitle>Ethan Kim IT Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gwanhyeon.github.io/"/>
  <updated>2021-01-03T11:10:16.267Z</updated>
  <id>http://gwanhyeon.github.io/</id>
  
  <author>
    <name>Ethan Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective Java 3/E Item 43 람다보다는 메서드 참조를 사용하라</title>
    <link href="http://gwanhyeon.github.io/EffectiveJava-20210103-%EC%95%84%EC%9D%B4%ED%85%9C43-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/"/>
    <id>http://gwanhyeon.github.io/EffectiveJava-20210103-%EC%95%84%EC%9D%B4%ED%85%9C43-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <published>2021-01-03T09:32:06.000Z</published>
    <updated>2021-01-03T11:10:16.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ramdabodaneun-meseodeu-camjoreul-sayonghara"><a href="#ramdabodaneun-meseodeu-camjoreul-sayonghara" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#람다보다는-메서드-참조를-사용하라"></a> 람다보다는 메서드 참조를 사용하라</h1><p><code>람다가 익명 클래스보다 나은 점 중에서 가장 큰 특징은 간결함</code>입니다. 그런데 자바에는 함수객체를 심지어 람다보다도 더 간결하게 만드는 방법이 있습니다. 바로 <code>메서드 참조(Method reference)</code>입니다.</p><p>다음 코드는 임의의 키와 Integer 값의 매핑을 관리하는 프로그램의 일부입니다.</p><p>키의 인스턴스 개수로 해석된다면, 이 프로그램은 멀티셋(multiset)을 구현한게 됩니다.<br><code>이 코드는 키가 맵 안에 없다면 키와 숫자 1을 매핑하고 이미 존재한다면 기존 매핑 값을 증가시킵니다.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//comment 람다보다도 더 간결하게 만드는 방법은 -&gt; 메서드 참조</span></span><br><span class="line">Map&lt;String,Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//comment java 8 추가된 Map merge 메서드를 사용하기 (키가 없다면 &#123;키,쌍&#125; 그대로저장, 있다면 현재값과 주어진값에 적용후 그 결과로 현재값을 덮어쓴다</span></span><br><span class="line">m.merge(<span class="string">"1"</span>,<span class="number">1</span>,(count, increment)-&gt;count+increment);</span><br><span class="line">System.out.println(m.get(<span class="string">"1"</span>)); <span class="comment">// 1</span></span><br><span class="line">m.merge(<span class="string">"1"</span>,<span class="number">1</span>,(count, increment)-&gt;count+increment);</span><br><span class="line">System.out.println(m.get(<span class="string">"1"</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>자바 8때 Map에 추가된 merge메서드를 사용하였습니다. merge 메서드는 키,값,함수를 인자로 받으며, 주어진 키가 이미 있다면(세번째 인수로 받은) 함수를 현재 값과 주어진 값에 적용한 후에, 그 결과로 현재 값을 덮어씌웁니다.<br><code>즉, 맵에 {키,함수의 결과} 쌍을 저장합니다</code> 이코드는 merge 메서드의 전형적인 쓰임을 잘 보여주고 있습니다.</p><blockquote><p>조금 더 최적화는 어떻게 시킬 수 있을까요?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// comment 위와 같은 merge기능은 count, increment가 공간을 꽤나 차지하기때문에 이것을 더 쉽게 람다로 바꾸어보자.</span><br><span class="line">m.merge(&quot;1&quot;, 1, Integer::sum);</span><br><span class="line">System.out.println(m.get(&quot;1&quot;)); // 3</span><br></pre></td></tr></table></figure><p>매개변수는 직접적으로 크게 하는일이 없기때문에 일 없이 공간을 차지하는 경우가 많습니다. 이때, <code>자바 8이 되면서 Integer 클래스(와 모든 기본타입의 박싱 타입)</code>는 이 람다와 기능이 같은 <code>정적 메서드 sum을 제공</code>하기 시작하였습니다.<br><code>따라서, 람다 대신 이 메서드의 참조를 전달하면 똑같은 결과를 더 보기 좋게 얻을 수 있습니다.</code></p><blockquote><p>람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다.</p></blockquote><p>메서드 참조를 사용하는편이 보통 더 짧고 간결하므로, <code>람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 더 좋은 대안</code>이 되어줍니다. 즉, <code>람다로 작성할 코드를 새로운 메서드</code>에 담은 다음, <code>람다 대신 그 메서드 참조</code>를 사용하는 식입니다.</p><blockquote><p>때론 람다가 메서드 참조보다 간결할 때가 있다.</p></blockquote><p>주로 메서드와 람다가 같은 클래스에 있을때 그렇습니다. goshThisClassNameIsHumongous::action 클래스 안에 있다고 가정하겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Item43;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoshThisClassNameIsHumongous</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Executor service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 메서드 참조</span></span><br><span class="line">        service.execute( GoshThisClassNameIsHumongous::action);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 람다</span></span><br><span class="line">        service.execute(()-&gt;action());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>메서드 참조 쪽도 더 짧지도, 더 명확하지도 않습니다. 따라서 람다 쪽이 더 낫다고 할 수 있습니다.</code><br>같은 선상에서 <code>java.util.function</code> 패키지가 제공하는 제네릭 정적 팩터리 메서드인 <code>Function.identity()</code>를 사용하기 보다는 똑같은 기능의 람다를 직접 사용하는 편이 더 낫다고 할 수 있습니다.</p><h1 id="meseodeu-camjoyuhyeongyi-daseosgaji"><a href="#meseodeu-camjoyuhyeongyi-daseosgaji" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#메서드-참조유형의-다섯가지"></a> 메서드 참조유형의 다섯가지</h1><blockquote><ol><li>정적 메서드를 가리키는 메서드입니다.</li></ol></blockquote><p><code>인스턴스 메서드를 참조하는 유형</code>은 <code>수신 객체(receiving object: 참조 대상 인스턴스)</code>를 특정하는 <code>한정적(bound)인스턴스 메서드 참조</code>이고, 다른 하나는 <code>수신 객체를 특정하지 않은 비한정적(unbound) 인스턴스 메서드 참조</code>입니다.</p><blockquote><ol start="2"><li>한정적 참조<br>근본적으로 <code>정적 참조</code>와 비슷합니다. <code>즉, 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑같습니다.</code></li></ol></blockquote><blockquote><ol start="3"><li>비한정적 참조<br><code>비한정적 참조</code>에서는 <code>함수 객체를 적용하는 시점에 수신 객체</code>를 알려줍니다. 이를 위해 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따릅니다.<br><code>비한정적 참조는 주로 스트림 파이프라인에서 매핑과 필터 함수</code>에 쓰입니다.</li></ol></blockquote><blockquote><p>4,5. 클래스 생성자를 가리키는 메서드 참조, 배열 생성자를 가리키는 메서드 참조<br>마지막으로, 클래스 생성자를 가리키는 메서드 참조와 배열 생성자를 가리키는 메서드 참조가 있습니다. 생성자 참조는 팩터리 객체로 사용됩니다.</p></blockquote><table><thead><tr><th>인터페이스</th><th>함수 시그니처</th><th>예</th></tr></thead><tbody><tr><td>UnaryOperator</td><td>T apply(T t)</td><td>String::toLowerCase</td></tr><tr><td>BinaryOperator</td><td>T apply(T t1, T t2)</td><td>BigInteger::add</td></tr><tr><td>Predicate</td><td>boolean test(T t)</td><td>Collection::isEmpty</td></tr><tr><td>Function&lt;T,R&gt;</td><td>R apply(T t)</td><td>Arrays::asList</td></tr><tr><td>Supplier</td><td>T get()</td><td>Instant::now</td></tr><tr><td>Consumer</td><td>void accept(T t)</td><td>System.out::println</td></tr></tbody></table><blockquote><p>핵심 정리</p></blockquote><p><code>메서드 참조</code>는 람다의 간단명료한 대안이 될 수 있습니다. <code>메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라</code></p><p><a href="https://github.com/gwanhyeon/Effective-Java/tree/main/src/Item43" target="_blank" rel="noopener">https://github.com/gwanhyeon/Effective-Java/tree/main/src/Item42</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ramdabodaneun-meseodeu-camjoreul-sayonghara&quot;&gt;&lt;a href=&quot;#ramdabodaneun-meseodeu-camjoreul-sayonghara&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gwanhyeon.github.io/categories/java/"/>
    
    
      <category term="EffectiveJava3/E" scheme="http://gwanhyeon.github.io/tags/effectivejava3-e/"/>
    
      <category term="람다" scheme="http://gwanhyeon.github.io/tags/%EB%9E%8C%EB%8B%A4/"/>
    
      <category term="익명클래스" scheme="http://gwanhyeon.github.io/tags/%EC%9D%B5%EB%AA%85%ED%81%B4%EB%9E%98%EC%8A%A4/"/>
    
      <category term="메서드참조" scheme="http://gwanhyeon.github.io/tags/%EB%A9%94%EC%84%9C%EB%93%9C%EC%B0%B8%EC%A1%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3/E Item 42 익명클래스 보다는 람다를 사용하라</title>
    <link href="http://gwanhyeon.github.io/EffectiveJava-20210103-%EC%95%84%EC%9D%B4%ED%85%9C42-%EC%9D%B5%EB%AA%85%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%9E%8C%EB%8B%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/"/>
    <id>http://gwanhyeon.github.io/EffectiveJava-20210103-%EC%95%84%EC%9D%B4%ED%85%9C42-%EC%9D%B5%EB%AA%85%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%9E%8C%EB%8B%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <published>2021-01-03T09:32:06.000Z</published>
    <updated>2021-01-03T11:10:27.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="igmyeongkeulraeseu-bodaneun-ramdareul-sayonghara"><a href="#igmyeongkeulraeseu-bodaneun-ramdareul-sayonghara" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#익명클래스-보다는-람다를-사용하라"></a> 익명클래스 보다는 람다를 사용하라</h1><p>자바에서 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스를 사용했습니다. 이러한 인터페이스의 인스턴스를 함수 객체(function object)라고 하여, 특정 함수나 동작을 나타내는 데 썼습니다.</p><p>1997년 JDK1.1 이 등장하면서 함수 객체를 만드는 주요 수단은 익명 클래스가 되었습니다.<br><code>문자열을 길이순</code>으로 <code>정렬</code>하는데, 정렬을 위한 비교 함수로 <code>익명 클래스</code>로 사용하였습니다.(과거)</p><blockquote><p>익명 클래스의 인스턴스를 함수 객체로 사용합니다.(낡은 기법)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comment 익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법!!!!</span></span><br><span class="line">Collections.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>전략 패턴처럼, 함수 객체를 사용하는 <code>과거 객체 지향 디자인 패턴</code>에는 <code>익명 클래스</code>면 충분하였습니다. 위의 코드는 <code>Comparator 인터페이스</code>가 <code>정렬</code>을 담당하는 <code>추상전략</code>을 뜻하며, 문자열을 정렬하는 구체적인 전략을 <code>익명 클래스로 구현</code>했습니다.</p><p><code>하지만, 익명클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않게 되었습니다.</code></p><blockquote><p>자바 8에서는 어떻게 변화되었을까요?</p></blockquote><p>추상 메서드 하나짜리 인터페이스는 특별한 의미를 인정받아 특별한 대우를 받게 되었습니다. 지금은 함수형 인터페이스라 부르는 이 인터페이스들의 인스턴스를 람다식(lambda expression, 람다)을 사용하여 만들수 있게 된 것입니다. 람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하게 처리할 수 있습니다.</p><blockquote><p>람다식을 함수 객체로 사용(익명 클래스 대체)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comment 람다식을 함수 객체로 사용 - 익명 클래스 대체</span></span><br><span class="line"><span class="comment">// comment 타입을 명시해야 코드가 더 명확할때마 제외하고는 람다의 모든 매개변수 타입은 생략하자</span></span><br><span class="line">Collections.sort(words, (s1,s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure><p>여기서 람다, 매개변수(s1, s2) 반환값 타입은 각각 <code>Comparator&lt;String&gt;, String, int</code> 이지만 코드에서는 언급이 없습니다. 상황에 따라 컴파일러가 타입을 결정하지 못하는 경우가 있는데 그럴때는 프로그래머가 직접 명시를 해야합니다.</p><p><strong>타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하도록 합니다.</strong></p><p>컴파일러가 타입을 추론하는데 필요한 정보는 대부분 제네릭에서 얻기 때문에 컴파일러는 람다의 타입을 추론할 수 없게 되어, 결국 우리가 일일이 명시해야합니다.</p><blockquote><p>비교자 생성 메서드를 사용하여 이 코드를 더 간결하게 만들어봅시다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(words, comparingInt(String::length));</span><br></pre></td></tr></table></figure><blockquote><p>더 나아가 자바 8때 List 인터페이스에 추가된 sort 메서드를 이용하면 더욱더 짧아집니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.sort(comparingInt(String::length));</span><br></pre></td></tr></table></figure><p>람다를 언어 차원에서 지원하면서 기존에는 적합하지 않았던 곳에서도 함수 객체를 실용적으로 사용할 수 있게 되었습니다.</p><p>아이템 34의 Operation 열거타입을 예로 들어봅시다. apply 메서드의 동작이 상수마다 달라야해서 상수별 클래스 몸체를 사용해 각 상수에서 apply 메서드를 재정의합니다.</p><blockquote><p>상수별 클래스 몸체와 데이터를 사용한 열거 타입</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comment 상수별 클래스 몸체와 데이터를 사용한 열거 타입</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation&#123;</span><br><span class="line"></span><br><span class="line">    PLUS(<span class="string">"+"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">"*"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    Operation(String symbol)&#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>아이템 34</strong>에서는 상수별 클래스 몸체를 구현하는 방식보다는 <code>열거 타입에 인스턴스 필드를 두는 편이 낫습니다.</code> 람다를 이용하면 후자의 방식, 즉 열거타입의 인스턴스 필드를 이용하는 방식으로 상수별로 다르게 동작하는 코드를 쉽게 구현할 수 있습니다.</p><p>단순히 각 열거 타입의 동작을 람다로 구현해 생성자에 넘기고, 생성자는 이 람다를 인스턴스 필드로 저장해둡니다. 그런 다음 <code>apply 메서드에서 필드에 저장된 람다를 호출하기만 하면 됩니다.</code></p><blockquote><p>함수객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거타입</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation_lambda&#123;</span><br><span class="line">    PLUS(<span class="string">"+"</span>, (x,y) -&gt; x+y),</span><br><span class="line">    MINUS(<span class="string">"-"</span>, (x,y) -&gt; x-y),</span><br><span class="line">    TIMES(<span class="string">"*"</span>, (x,y) -&gt; x*y),</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>, (x,y) -&gt; x/y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DoubleBinaryOperator op;</span><br><span class="line"></span><br><span class="line">    Operation_lambda(String symbol, DoubleBinaryOperator op)&#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">        <span class="keyword">this</span>.op = op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> op.applyAsDouble(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 객체 람다를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거타입입니다. 열거 타입 상수의 동작을 표현한 람다를 <code>DoubleBinaryOperator 인터페이스</code>변수에 할당하였습니다. <code>java.util.function 패키지가 제공하는 다양한 함수</code> 인터페이스(아이템 44) 중 하나 인수를 받아서 결과를 반환시켜줍니다(double)</p><blockquote><p>핵심 정리</p></blockquote><p>람다 기반 Operation 열거 타입을 보면 상수별 클래스 몸체는 더 이상 사용할 이유가 없다고 느낄지 모르지만, 꼭 그렇지는 않습니다. 메서드나 클래스와 달리 <code>람다는 이름이 없고 문서화도 못한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄수가 많아지면 람다를 쓰지 말아야합니다</code></p><p><code>람다는 한줄일 때 가장 좋고 길어야 세줄</code> 안에 끝내는게 좋습니다. 열거 타입 생성자 안의 람다는 타입의 인스턴스 멤버에 접근을 할 수 없습니다. 따라서, 상수별 동작을 단 몇줄로 구현하기 어렵거나, <code>인스턴스 필드나 메서드를 사용해야만 하는 상황</code>이라면 <code>상수별 클래스 몸체를 사용</code>해야합니다.</p><p><code>추상클래스의 인스턴스를 만들 때 람다를 쑬 수 없으니, 익명 클래스</code>를 써야합니다. 비슷하게 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있습니다.</p><p>마지막으로 람다는 자신을 참조할 수 없습니다. 람다에서의 <code>this 키워드는 바깥 인스턴스</code>를 가리킵니다. 그래서 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야합니다. 따라서 람다를 직렬화하는 일은 극히 삼가해야합니다.</p><blockquote><p>요약</p></blockquote><p>자바가 8로 판올림 되면서 작은 함수 객체를 구현하는데 적합한 람다가 도입되었습니다. <code>익명 클래스는(함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용해야합니다.</code> 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있어서 함수형 프로그래밍의 지평을 열게 되었습니다.</p><p><a href="https://github.com/gwanhyeon/Effective-Java/tree/main/src/Item42" target="_blank" rel="noopener">https://github.com/gwanhyeon/Effective-Java/tree/main/src/Item42</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;igmyeongkeulraeseu-bodaneun-ramdareul-sayonghara&quot;&gt;&lt;a href=&quot;#igmyeongkeulraeseu-bodaneun-ramdareul-sayonghara&quot; class=&quot;header-anchor&quot;&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gwanhyeon.github.io/categories/java/"/>
    
    
      <category term="EffectiveJava3/E" scheme="http://gwanhyeon.github.io/tags/effectivejava3-e/"/>
    
      <category term="람다" scheme="http://gwanhyeon.github.io/tags/%EB%9E%8C%EB%8B%A4/"/>
    
      <category term="익명클래스" scheme="http://gwanhyeon.github.io/tags/%EC%9D%B5%EB%AA%85%ED%81%B4%EB%9E%98%EC%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC @ResponseBody의 역할</title>
    <link href="http://gwanhyeon.github.io/Spring-20201231-responsebody%EC%9D%98-%EC%97%AD%ED%95%A0/"/>
    <id>http://gwanhyeon.github.io/Spring-20201231-responsebody%EC%9D%98-%EC%97%AD%ED%95%A0/</id>
    <published>2020-12-31T10:08:47.000Z</published>
    <updated>2020-12-31T11:05:00.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="responsebody"><a href="#responsebody" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#responsebody"></a> @ResponseBody</h1><p>스프링환경에서 개발을 진행하다보면 컨트롤러에서 <code>@ResponseBody</code>를 사용하는일이 많습니다. <code>@ResponseBody</code>를 사용하는것과 사용하지 않는것은 어떤차이점이 있을까요?</p><p>기본적으로 <code>Spring은 MVC</code> 환경에서 동작을 합니다. 이때 MVC의 동작을 간략하게 말씀드리겠습니다.</p><p>만약 사용자가 웹브라우저상에서 서버에게 <code>localhost:8080/mvc</code> 라는 경로로 요청을 진행한다고 가정하겠습니다.<br>이때 Spring 내부의 <code>내장 톰캣 서버</code>가 해당 요청을 받아 들여 스프링 컨테이너는 해당 요청을 가지고 있는 <code>@Controller</code> 어노테이션이 붙여진 컨트롤러를 찾아주게됩니다.</p><blockquote><p>@Controller</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2017 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.stereotype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates that an annotated class is a "Controller" (e.g. a web controller).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This annotation serves as a specialization of &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;,</span></span><br><span class="line"><span class="comment"> * allowing for implementation classes to be autodetected through classpath scanning.</span></span><br><span class="line"><span class="comment"> * It is typically used in combination with annotated handler methods based on the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.web.bind.annotation.RequestMapping&#125; annotation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Component</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.bind.annotation.RequestMapping</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.ClassPathBeanDefinitionScanner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = Component<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    String value() default "";</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Component</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2017 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.stereotype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates that an annotated class is a "component".</span></span><br><span class="line"><span class="comment"> * Such classes are considered as candidates for auto-detection</span></span><br><span class="line"><span class="comment"> * when using annotation-based configuration and classpath scanning.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Other class-level annotations may be considered as identifying</span></span><br><span class="line"><span class="comment"> * a component as well, typically a special kind of component:</span></span><br><span class="line"><span class="comment"> * e.g. the &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125; annotation or AspectJ's</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.aspectj.lang.annotation.Aspect <span class="doctag">@Aspect</span>&#125; annotation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Repository</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.ClassPathBeanDefinitionScanner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">     * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 컨트롤러를 타고 들어가면 다음과 같은 구조를 볼 수 있습니다. 자세히 살펴보시면 <code>@Component</code> 어노테이션을 살펴보실 수 있습니다. 과연 이것의 어노테이션의 역할은 무엇일까요?<br>즉, 기존의 Spring에서는 <code>@Bean</code>을 붙여 빈을 등록하던 것처럼 빈 클래스에 <code>@Component</code> 애노테이션을 붙여 빈을 등록할 수 있습니다. 따라서 <code>@Controller</code> 어노테이션 내부에는 해당 컨트롤러를 <code>@Bean</code> 으로 등록하는 역할도 하고 있다는 뜻입니다.<br>@Component를 붙여 빈을 등록하면 클래스 이름의 첫 문자를 소문자로 바꾼 것이 빈의 이름(id)이 됩니다. 그리고 빈 객체가 생성되는 시점은 ApplicationContext 객체가 생성되는 시점이며 기본적으로 singleton scope 입니다.</p><p><code>localhost:8080/mvc</code>의 요청경로에 맞는 컨트롤러를 @Bean 컴포넌트 스캔을 통하여 해당 경로를 가지고 있는 컨트롤러를 찾아주게 됩니다.  만약 <code>@ResponseBody</code> 가 붙여져 있지 않다면 해당 모델에 값을 넘겨줄 수도 있고, String을 반환하게 되면 데이터를 넘겨주는것이 아니라 해당 View의 Path값에 맞게  모델값과 함께 반환시켜주게 됩니다.</p><p>간단한 예제로는</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/mvc"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"name"</span>, <span class="string">"kgh"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"root"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>형식을 들 수 있습니다. 모델값을 가져와 거기에 <code>&lt;Key,value&gt;</code> 형식으로 값을 넣어주고 반환값을 String으로 한 <code>'root' View Path</code>를 반환시켜주게 됩니다. 즉, 컨트롤러에서 리턴 값으로 문자를 반환하면 <code>뷰 리졸버( viewResolver )</code>가 화면을 찾아서 처리를 진행합니다.</p><blockquote><p>@ResponseBody를 붙여주면 무슨일이 발생할까요?</p></blockquote><p><code>@ResponseBody</code>의 역할은 <code>HTTP BODY</code>문자내용을 반환하는 <code>api</code>라고 할 수 있습니다. 즉, 기존에 <code>@ResponseBody</code>가 없는 경우에 <code>viewResolver</code> 대신에 <code>httpMessageConverter</code>가 동작하여 문자일 경우에는 <code>StringHttpMessageConverter</code> 객체일 경우에는 <code>MappingJackson2HttpMessageConverter</code>로 이루어져있습니다. 클라이언트의 HTTP Accept헤더와 서버 컨트롤러의 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 동작되게 됩니다. 기본으로 동작되는 데이터반환형식은 Default는 JSON형식으로 동작되게 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/mvc"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloString</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"kgh"</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;responsebody&quot;&gt;&lt;a href=&quot;#responsebody&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#responsebody&quot;&gt;&lt;/a&gt; @ResponseB
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/categories/spring/"/>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/tags/spring/"/>
    
      <category term="ResponseBody" scheme="http://gwanhyeon.github.io/tags/responsebody/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Gradle 빠르게 설정하기</title>
    <link href="http://gwanhyeon.github.io/Spring-20201231-springboot-gradle-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"/>
    <id>http://gwanhyeon.github.io/Spring-20201231-springboot-gradle-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/</id>
    <published>2020-12-31T09:57:27.000Z</published>
    <updated>2020-12-31T10:04:22.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="seupeuringbuteueseo-gradle-bbareuge-seoljeonghagi"><a href="#seupeuringbuteueseo-gradle-bbareuge-seoljeonghagi" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#스프링부트에서-gradle-빠르게-설정하기"></a> 스프링부트에서 Gradle 빠르게 설정하기</h1><p><code>IntellJ</code> 로 프로젝트를 생성하고나면 IntellJ에서 Gradle을 통해서 파일들을 컴파일하는것을 알 수 있습니다.<br>하지만, 이 방식은 실행속도에 있어서 많은 차이점을 가져다주게 됩니다.</p><blockquote><p>이것을 어떻게 변경할 수 있을까요?</p></blockquote><p>Java진영에서 직접 컴파일을 실행시킬 수 있도록 처리해주는 것이 빠른 속도를 가져올 수 있습니다.<br><code>MacOS</code> 기준 왼쪽 상단에 <code>IntellJ IDEA</code>를 클릭하시고<br><code>Preferences Build -&gt; Execution -&gt; Deployment Build Tools Gradle</code> 의 위치에서 다음과 같이 설정을 진행합니다.</p><p>또 다른 방식으로는 Shift를 두번눌러서 전체 검색을 통해서 <code>Deployment Build Tools Gradle</code>을 입력하시면 해당 설정하는 곳으로 바로 이동하실 수 있습니다.</p><ul><li><code>Build and run using: Gradle -&gt; IntelliJ IDEA</code></li><li><code>Run tests using: Gradle -&gt; IntelliJ IDEA</code></li></ul><p>모두 Gradle로 되어있는 것을 IntellJ IDEA로 변경을 진행하면 조금 더 빠른 환경에서 개발을 진행할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;seupeuringbuteueseo-gradle-bbareuge-seoljeonghagi&quot;&gt;&lt;a href=&quot;#seupeuringbuteueseo-gradle-bbareuge-seoljeonghagi&quot; class=&quot;header-anchor
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/categories/spring/"/>
    
    
      <category term="SpringBoot" scheme="http://gwanhyeon.github.io/tags/springboot/"/>
    
      <category term="Gradle" scheme="http://gwanhyeon.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 프로젝트 환경설정</title>
    <link href="http://gwanhyeon.github.io/Spring-20201231-springboot-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"/>
    <id>http://gwanhyeon.github.io/Spring-20201231-springboot-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/</id>
    <published>2020-12-31T09:35:01.000Z</published>
    <updated>2020-12-31T10:03:23.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot-peurojegteu-hwangyeongseoljeonghagi"><a href="#springboot-peurojegteu-hwangyeongseoljeonghagi" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#springboot-프로젝트-환경설정하기"></a> Springboot 프로젝트 환경설정하기</h1><p>이번시간부터 스프링부트 프로젝트생성부터 스프링 개념에 대해서 정리를 진행하려고합니다.</p><p>프로젝트 생성을 위한 환경은 다음과 같습니다.</p><ul><li><code>Intellj IDEA</code></li><li><code>Springboot 2.4.1 버전</code></li><li><code>Gradle</code></li><li><code>Java 11</code></li></ul><p>스프링 프로젝트를 진행하기 위해서는 <a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a> 에서 생성하는 방법과<br>인텔리제이 프로젝트 생성에서 만들 수 있는 방법이 있습니다.</p><blockquote><p>build Gradle의 전체 설정</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'2.4.1'</span></span><br><span class="line">    id <span class="string">'io.spring.dependency-management'</span> version <span class="string">'1.0.10.RELEASE'</span></span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.kgh'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="string">'11'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-thymeleaf'</span></span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">    runtimeOnly <span class="string">'com.h2database:h2'</span>            </span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>springboot-starter-we, spring-boot-starter 에는 다음과 같은 의존성 라이브러리가 추가됩니다.</p></blockquote><ul><li>spring-boot-starter-tomcat 톰캣</li><li>spring-webmvc 스프링 웹 MVC</li><li>spring-boot -&gt; spring-core</li><li>spring-boot-starter-logging -&gt; logback, slf4j</li></ul><p>springboot-starter-web은 다음과 같은 라이브러리를 포함하고 있기때문에 따로 톰캣설정과 MVC에 대한 설정을 따로 해줄 필요가 없습니다. 즉, 매우 편리하게 설정들을 진행해준다는 장점이 있습니다.</p><blockquote><p>테스트 라이브러리 의존성 라이브러리는 다음과 같습니다.</p></blockquote><p><code>junit: 테스트 프레임워크</code><br><code>mockito: Mock 라이브러리</code><br><code>assertj: 테스트코드를 손쉽게 작성할 수 있도록 도와줍니다.</code><br><code>spring-test: 스프링 통합 테스트 지원</code></p><p>이러한 역할을 한다는것을 알고 계신후 위의 코드를 작성후 프로젝트를 생성한 뒤 Run을 통해서 <code>localhost:8080</code>에 접속하시면<br>에러가 발생하는 화면이 나오는것을 확인하실 수 있는데 그러면 <code>정상적으로 서버가 가동</code>된 것입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;springboot-peurojegteu-hwangyeongseoljeonghagi&quot;&gt;&lt;a href=&quot;#springboot-peurojegteu-hwangyeongseoljeonghagi&quot; class=&quot;header-anchor&quot;&gt;1. &lt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/categories/spring/"/>
    
    
      <category term="환경설정" scheme="http://gwanhyeon.github.io/tags/%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/"/>
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/tags/spring/"/>
    
      <category term="IntelliJ" scheme="http://gwanhyeon.github.io/tags/intellij/"/>
    
  </entry>
  
  <entry>
    <title>IntellJ Error: java: invalid source release: 11</title>
    <link href="http://gwanhyeon.github.io/Spring-20201123-java-compile-error/"/>
    <id>http://gwanhyeon.github.io/Spring-20201123-java-compile-error/</id>
    <published>2020-11-23T10:42:25.000Z</published>
    <updated>2020-11-23T11:17:12.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje"><a href="#munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h1><p>IntellJ에서 JDK 버전이 다른 프로젝트를 진행하는 경우가 생기가 되었습니다. 이때, 현재 사용중인 1.8.0_161 JDK버전과의 충돌이 발생하였습니다. <code>IntellJ Error: java: invalid source release: 11</code>의 에러가 발생하였습니다. 따라서 해당 에러를 해결하기 위해서 처음에 시도한 방식은 다음과 같습니다.</p><blockquote><ol><li>Fix Language Level</li></ol></blockquote><p><code>File -&gt; Project Structure -&gt; Project Settings -&gt; Project</code> 에서 Language level을 8로 수정하였습니다.</p><blockquote><ol start="2"><li>Fix Java Compiler</li></ol></blockquote><p>Preference -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Java Compiler에서 Project bytecode version을 8로 수정하고 Target bytecode version을 1.8로 수정하였습니다.</p><p>하지만, 이 방식대로 진행하였지만 여전히 <code>java: invalid source release: 11</code> 라는 에러가 발생하였습니다.</p><h1 id="haegyeol-bangbeob"><a href="#haegyeol-bangbeob" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#해결-방법"></a> 해결 방법</h1><h3 id="1-java-jdk-11-seolci"><a href="#1-java-jdk-11-seolci" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#1-java-jdk-11-설치"></a> 1. Java JDK 11 설치</h3><blockquote><p>brew java 11 설치</p></blockquote><p>JDK 1.8버전과 호환이 맞지 않는다고 생각하여 JDK Homebrew를 통하여 Java 11 버전을 설치하게 되었습니다.</p><blockquote><p>homebrew 설치</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><p>해당 명령어를 통해 homebrew를 설치를 진행하였습니다.</p><blockquote><p>OpenJdk 저장소 추가</p></blockquote><p>OpenJdk저장소를 추가시켜주었습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap AdoptOpenJDK/openjdk</span><br></pre></td></tr></table></figure><blockquote><p>자바 11버전 설치</p></blockquote><p>제가 설치할 자바버전은 11버전이기 때문에</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install adoptopenjdk8</span><br></pre></td></tr></table></figure><p>명령어를 통해 설치를 진행하였습니다.</p><blockquote><p>java version</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>해당 명령어를 통해 <code>Java 11버전</code> 설치를 완료하였습니다.</p><blockquote><p>java JDK 설치 경로</p></blockquote><p>이제, 제가 맨 처음에 불러왔던 프로젝트 기본 JDK설정을 자바 11로 설정하였으며 Mac기준 설정경로는<br><code>Macintosh HD -&gt; Library -&gt; Java -&gt; JavaVirtualMachines -&gt; adoptopenjdk-11.jdk -&gt; contents -&gt; home</code> 으로 진행하였습니다.</p><h3 id="2-lombok-peulreogeuin-seolci-mic-annotationprocessor-seoljeong"><a href="#2-lombok-peulreogeuin-seolci-mic-annotationprocessor-seoljeong" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#2-lombok-플러그인-설치-및-annotationprocessor-설정"></a> 2. Lombok 플러그인 설치 및 annotationProcessor 설정</h3><p>하지만, 이번에도 <code>cannot find symbol</code> 라는 에러가 발생하게 되었으며 이 문제를 해결하기 위해 다음과 같은 방법을 사용하였습니다.</p><blockquote><p>lombok plugin 설치</p></blockquote><p><code>롬복 관련 플러그인</code>이 설치되지 않아 발생하는 문제라 판단되어 <code>롬복을 설치</code>해주었습니다.</p><blockquote><p>annotationProcessor Enable</p></blockquote><p><code>annotationProcessor은</code> <code>어노테이션의 코드베이스를 검사, 수정 또는 생성하는데 사용</code>됩니다. 따라서, 해당 설정을 같이 진행해주었습니다.</p><p><code>Preference -&gt; Build,Execution,Deployment -&gt; Annotation Processers에서 Enable annotation processing</code> 에 대한 체킹을 처리하여주었고 해당 <code>annotationProcesser</code>가 <code>Gradle</code>에서 올바르게 인식이 가능하도록 <code>Build.gradle</code>파일에 소스코드를 추가시켜주었습니다.</p><p>그리고, build.gradle에서</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">annotationProcessor 'org.projectlombok:lombok'</span><br></pre></td></tr></table></figure><p>을 추가하고 <code>gradle synchronized</code>설정을 다시 진행해주니 해당 오류를 해결 할 수 있었습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje&quot;&gt;&lt;a href=&quot;#munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제&quot;&gt;&lt;/a&gt; 문제&lt;/h1&gt;
&lt;p&gt;IntellJ에서 JDK 버전이 다른 프로
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/categories/spring/"/>
    
    
      <category term="annotationProcessor" scheme="http://gwanhyeon.github.io/tags/annotationprocessor/"/>
    
      <category term="JDK" scheme="http://gwanhyeon.github.io/tags/jdk/"/>
    
      <category term="Spring" scheme="http://gwanhyeon.github.io/tags/spring/"/>
    
      <category term="IntellJ" scheme="http://gwanhyeon.github.io/tags/intellj/"/>
    
      <category term="Error" scheme="http://gwanhyeon.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>운영체제 프로세스 스레드 메모리 구조</title>
    <link href="http://gwanhyeon.github.io/OS-20201116-OS-Process-Thread/"/>
    <id>http://gwanhyeon.github.io/OS-20201116-OS-Process-Thread/</id>
    <published>2020-11-16T07:48:50.000Z</published>
    <updated>2020-11-16T10:26:37.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="peurogeuraem-program"><a href="#peurogeuraem-program" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#프로그램program"></a> 프로그램(Program)</h1><p>어떤 <code>작업을 위해 실행할 수 있는 파일</code>로 정의할 수 있습니다.</p><h1 id="peuroseseu-process"><a href="#peuroseseu-process" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#프로세스process"></a> 프로세스(Process)</h1><blockquote><p>의미</p></blockquote><p><code>사전적 의미</code>로는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램 또는 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적 개체)<br>즉, 운영체제로 부터 시스템 자원을 할당받는 작업의 단위이며 실행된 프로그램을 의미한다.</p><blockquote><p>할당 시스템 자원</p></blockquote><p>CPU시간, 운영시 필요한 주소공간 <code>Code, Data, Stack, Heap</code>의 구조로 되어있는 독립된 <code>메모리 영역</code></p><blockquote><p>특징</p></blockquote><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRYwhbEyPQiBjioNBtK0ftojMhvhyy343NGsg&amp;usqp=CAU" alt="프로세스 메모리 영역"></p><p>프로세스는 각각 도립된 <code>메모리 영역(Code, Data, Stack, Heap)구조</code>를 할당받게 되며 프로세스당 <code>최소 1개의 메인스레드</code>를 가지고 있습니다.<br>각 프로세스는 별도의 주소 공간에서 실행되며, <code>한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다.</code><br>만약, 한 프로세스가 다른 프로세스의 자원에 접근하려면 <code>프로세스간의 통신(IPC, inter-process communication)</code>을 사용해야합니다.<br>하나의 예로 <code>pipe, file, socket</code></p><h1 id="seuredeu-thread"><a href="#seuredeu-thread" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#스레드thread"></a> 스레드(thread)</h1><blockquote><p>의미</p></blockquote><p><code>프로세스 내에서 실행되는 여러 흐름의 단위</code>이며 프로세스의 특정한 수행 경로입니다. <code>즉, 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다.</code></p><blockquote><p>특징</p></blockquote><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQ9Lpf4DJh4AV-l6t6jOsbntASGR76jfIc1qg&amp;usqp=CAU" alt="스레드 메모리 영역"></p><p>스레드는 프로세스 내에서 각각 <code>Stack만 할당</code>받고 <code>Code, Data, Heap영역은 공유</code>됩니다. 그리고, <code>한 프로세스 내에서 동작되는 여러 실행의 흐름</code>이며 <code>프로세스내의 주소공간이나 자원(Heap) 등과 같은 프로세스 내에 스레드끼리 공유하면서 실행</code>이 됩니다. 같은 프로세스 안에 있는 <code>여러 스레드들은 같은 힙 공간을 공유</code>하지만 <code>프로세스는 다른 프로세스의 메모리에 직접 접근은 불가능합니다.</code><br>각각의 스레드는 별도의 <code>레지스터</code>와 <code>스택</code>을 갖고 있지만 <code>힙 메모리</code>는 서로 읽고 쓸 수 있습니다. 또한, <code>한 스레드가 프로세스 자원을 변경하면 다른 이웃 스레드(Sibling thread)도 변경된 사항을 확인 할 수 있습니다.</code></p><h1 id="meolti-peuroseseu-multi-process"><a href="#meolti-peuroseseu-multi-process" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#멀티-프로세스multi-process"></a> 멀티 프로세스(Multi Process)</h1><blockquote><p>멀티프로세싱 의미</p></blockquote><p>하나의 응용프로그램을 여러 프로세스로 구성하여 <code>각 프로세스</code>가 하나의 <code>Task를 수행</code>하는것을 일컫는 말.</p><blockquote><p>특징</p></blockquote><p>여러 개의 자식프로세스 중 하나의 문제가 발생하면 <code>그 자식프로세스만 영향</code>을 받으며 그 외에는 다른 영향을 끼치지 않습니다.<br><code>Context Switching 오버헤드</code>가 발생할 수 있는데, 그 과정에서 <code>캐시 메모리 등 무거운 작업이 진행과 Task수행에 있어서 시간 소모 및 오버헤드가 발생</code>하게 됩니다.<br><code>프로세스</code>는 <code>각각의 독립된 메모리 영역</code>을 <code>할당</code>받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어 <code>Context Switching</code>이 발생하면 <code>캐시에 있는 모든 데이터를 리셋</code>하고 <code>다시 캐시 정보를 불러와야 합니다.</code><br><code>프로세스</code>는 <code>각각의 독립된 메모리 영역을 할당</code>받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 <code>변수를 공유 할 수 없습니다.</code></p><h1 id="context-switching"><a href="#context-switching" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#context-switching"></a> Context Switching</h1><p>CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는데 이 과정을 <code>Context Switching</code>이라 합니다. <code>즉, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했든 프로세스의 상태를 복구하는 작업</code>을 일컫는 말입니다.</p><h1 id="meolti-seuredeu-multi-thread"><a href="#meolti-seuredeu-multi-thread" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#멀티-스레드multi-thread"></a> 멀티 스레드(Multi Thread)</h1><blockquote><p>멀티 스레딩</p></blockquote><p>하나의 응용프로그램을 여러개의 스레드로 구성하고 각 스레드로 하여금 <code>하나의 작업을 처리</code>하도록 하는것입니다.<br>WIndow, Linux 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 <code>멀티스레딩을 기본</code>으로 하고있습니다.<br>대표적인 멀티스레딩의 예는 <code>웹서버</code>를 들 수 있습니다.</p><blockquote><p>특징</p></blockquote><p><code>장점</code>으로는 <code>시스템 자원 소모 감소로 자원의 효율성</code>을 가져다 줄 수 있습니다. 프로세스를 생성하여 자원을 할당하는 <code>시스템 콜이 줄어들어 효율적으로 자원을 관리</code> 할 수 있습니다.<br><code>시스템 처리량</code>이 증가되어 <code>처리비용</code>을 감소시킬 수 있습니다. 스레드간 데이터를 주고 받는것이 간단해지고 <code>시스템 자원의 소모</code>가 줄어들게 됩니다. 스레드 사이의 작업량이 작아 <code>Context Switching</code>이 빠르고 간단한 통신방법으로 인한 프로그램 응답시간을 단축시킬 수 있습니다. <code>즉, 스레드는 프로세스내의 Stack영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적게 됩니다.</code></p><p><code>단점</code>으로는 주의 깊은 설계가 요구되고 디버깅이 까다롭게 됩니다. 그리고 단일 프로세스 시스템을 사용할 경우 효과를 기대하기 어렵고 다른 프로세스에서 스레드를 제어할 수 없습니다. 즉, 프로세스 밖에서 스레드를 제어하기에는 어려움이 나타나게 됩니다.</p><p>멀티 스레딩의 가장 큰 문제점인 <code>자원의 공유 동기화 문제</code>가 나타날 수 있으며 하나의 스레드에 문제가 발생하면 <code>전체 프로세스가 영향</code>을 받게됩니다.</p><h1 id="meoltipeuroseseu-vs-meoltiseuredeu"><a href="#meoltipeuroseseu-vs-meoltiseuredeu" class="header-anchor">7. </a><a class="markdownIt-Anchor" href="#멀티프로세스-vs-멀티스레드"></a> 멀티프로세스 VS 멀티스레드</h1><blockquote><p>비교</p></blockquote><p>프로그램을 여러개 키는것보다 하나의 프로그램안에서 작업을 해결하는것이 <code>효율성</code>이 더 좋으며 여러 프로세스의 작업을 단일 프로세스에서 여러스레드로 나눠가면서 하는 이유는 여러가지가 있습니다.</p><blockquote><p>특징</p></blockquote><p><code>대표적인 장점은</code> <code>첫번째,</code> <code>자원의 효율성을 증대</code>시켜 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 프로세스간의 Context Switching시 단순히 CPU 레지스터 교체뿐만아니라 RAM, CPU사이의 캐시메모리에 대한 데이터까지 초기화되므로 오버헤드가 크게 발생할 수 있습니다.<br>그리고 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드간의 데이터를 주고 받는것이 간단해지고 시스템 자원 소모가 줄어들게됩니다.<br><code>두번째,</code> <code>처리 비용 감소 및 응답 시간 단축</code>이 가능합니다. 스레드는 Stack영역을 제외한 모든 메모리를 공유하기 때문에 프로세스간의 통신(IPC)보다 스레드간 통신비용이 적으므로 작업들간의 통신 부담이 줄어들게됩니다. 그리고, 프로세스간의 전환 속도보다 스레드간의 전환속도가 더 빠릅니다.</p><blockquote><p>동기화 문제</p></blockquote><p>스레드간의 자원 공유는 전역 변수 데이터세그먼트를 이용하므로 함께 상용할때 충돌이 발생할 가능성이 높습니다.</p><h1 id="pcb-process-control-block"><a href="#pcb-process-control-block" class="header-anchor">8. </a><a class="markdownIt-Anchor" href="#pcbprocess-control-block"></a> PCB(Process Control Block)</h1><blockquote><p>PCB<br><code>프로세스 제어블록(PCB)는</code> 특정한 프로세스를 관리 할 필요가 있는 정보를 포함하는 운영체제 <code>커널의 자료구조</code>이며 <code>운영체제가 프로세스를 표현</code>한 것이라 할 수 있습니다.<br>운영 체제가 <code>프로세스 스케줄링을 위해 프로세스에 관한 모든 정보</code>를 가지고 있는 데이터베이스를 <code>PCB</code>라고 합니다. 운영체제에서 프로세스는 PCB로 나타내어지며 PCB는 프로세스의 주요 정보를 가지고 있습니다. <code>각 프로세스가 생성될 때 마다 고유의 PCB가 생성되고 프로세스가 완료되면 PCB는 제거됩니다.</code></p></blockquote><blockquote><p>특징</p></blockquote><p><code>프로세스는</code> <code>CPU를 점유하여 작업을 처리하다가도 상태가 전이되면 진행하던 작업 내용을 모두 정리하고 CPU를 반환</code>해야하는데 진행하던 작업들을 저장하지않으면 추후에 어떤작업을 해야할지에 대한 <code>정보를 알 수 없습니다.</code></p><p><code>즉</code>, <code>프로세스는</code> <code>CPU가 처리하던 작업의 내용들을 자신의 PCB에 저장</code>하고 <code>그 후에 다시 CPU를 점유</code>하여 작업을 수행해야할 때 <code>PCB로 부터 해당 정보들을 CPU에 넘겨와서 계속해서 하던 작업을 진행</code>할 수 있습니다.</p><blockquote><p>PCB에서 제공하는 정보</p></blockquote><p><img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2142EF505714CBD520" alt="Process Control Block"></p><ul><li><code>1)프로세스 식별자(Process ID)</code></li><li><code>2)프로세스 상태(Process State)</code> : 생성(create), 준비(ready), 실행 (running), 대기(waiting), 완료(terminated) 상태가 있습니다.</li><li><code>3)프로그램 계수기(Program Counter)</code> : 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다</li><li><code>4)CPU 레지스터 및 일반 레지스터</code></li><li><code>5)CPU 스케줄링 정보</code> : 우선 순위, 최종 실행시각, CPU 점유시간 등</li><li><code>6)메모리 관리 정보</code> : 해당 프로세스의 주소 공간 등</li><li><code>7)프로세스 계정 정보</code> : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등</li><li><code>8)입출력 상태 정보</code> : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등</li><li><code>9)포인터</code> : 부모프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;peurogeuraem-program&quot;&gt;&lt;a href=&quot;#peurogeuraem-program&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#프로그램program&quot;&gt;
      
    
    </summary>
    
    
      <category term="OS" scheme="http://gwanhyeon.github.io/categories/os/"/>
    
    
      <category term="프로세스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/"/>
    
      <category term="스레드" scheme="http://gwanhyeon.github.io/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"/>
    
      <category term="멀티프로세스" scheme="http://gwanhyeon.github.io/tags/%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/"/>
    
      <category term="멀티스레드" scheme="http://gwanhyeon.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C/"/>
    
      <category term="PCB" scheme="http://gwanhyeon.github.io/tags/pcb/"/>
    
      <category term="ContextSwitching" scheme="http://gwanhyeon.github.io/tags/contextswitching/"/>
    
  </entry>
  
  <entry>
    <title>릿코드 maximum subarray</title>
    <link href="http://gwanhyeon.github.io/Leetcode-20201115-leetcode-maximum-subarray/"/>
    <id>http://gwanhyeon.github.io/Leetcode-20201115-leetcode-maximum-subarray/</id>
    <published>2020-11-15T12:42:42.000Z</published>
    <updated>2020-11-16T13:37:31.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riskodeu-maximum-subarray"><a href="#riskodeu-maximum-subarray" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#릿코드-maximum-subarray"></a> <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">릿코드 maximum-subarray</a></h1><h1 id="munje"><a href="#munje" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h3 id="example-1"><a href="#example-1" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#example-1"></a> Example 1:</h3><p>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p><h3 id="example-2"><a href="#example-2" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#example-2"></a> Example 2:</h3><p>Input: nums = [1]<br>Output: 1</p><h3 id="example-3"><a href="#example-3" class="header-anchor">2.3. </a><a class="markdownIt-Anchor" href="#example-3"></a> Example 3:</h3><p>Input: nums = [0]<br>Output: 0</p><h3 id="example-4"><a href="#example-4" class="header-anchor">2.4. </a><a class="markdownIt-Anchor" href="#example-4"></a> Example 4:</h3><p>Input: nums = [-1]<br>Output: -1<br>Example 5:</p><p>Input: nums = [-2147483647]<br>Output: -2147483647</p><p>Constraints:</p><p>1 &lt;= nums.length &lt;= 2 * 104<br>-231 &lt;= nums[i] &lt;= 231 - 1</p><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>값 나열시 하나의 규칙을 처음에 찾아보면서 dp를 사용하면 되겠다 생각하였습니다.</li></ul><blockquote><p>완전탐색</p></blockquote><ul><li>완전탐색의 경우 2중 포문을 사용하여 모든 경우 탐색하였는데 O(N)의 경우 시간초과</li></ul><blockquote><p>DP(dynamic programming)</p></blockquote><ul><li>DP의 경우 작은부분을 점차 늘려가면서 부분집합의 최댓값을 찾아주면 최종적으로 dp[length-1]에는 최적화된 값을 찾을 수 있습니다.(Bottom up)</li></ul><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_maximum_subarray_kgh</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        maxSubArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        maxSubArrayBruteforce(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        maxSubArrayBruteforce(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">2147483647</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            nums[i] = Math.max(nums[i], nums[i]+ nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArrayBruteforce</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">2147483647</span>;      <span class="comment">// 기존에 -1 넣었는데 입력이 -2147483647 예외 처리해주기 위해서 초기화</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;nums.length; j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                    max = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;riskodeu-maximum-subarray&quot;&gt;&lt;a href=&quot;#riskodeu-maximum-subarray&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#릿코드
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://gwanhyeon.github.io/categories/leetcode/"/>
    
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="DP" scheme="http://gwanhyeon.github.io/tags/dp/"/>
    
      <category term="릿코드" scheme="http://gwanhyeon.github.io/tags/%EB%A6%BF%EC%BD%94%EB%93%9C/"/>
    
      <category term="부분집합의 합" scheme="http://gwanhyeon.github.io/tags/%EB%B6%80%EB%B6%84%EC%A7%91%ED%95%A9%EC%9D%98-%ED%95%A9/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 방문길이</title>
    <link href="http://gwanhyeon.github.io/Programmers-20201115-Programmers-length-of-visit/"/>
    <id>http://gwanhyeon.github.io/Programmers-20201115-Programmers-length-of-visit/</id>
    <published>2020-11-15T12:38:46.000Z</published>
    <updated>2020-11-15T12:46:48.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="peurogeuraemeoseu-bangmungili"><a href="#peurogeuraemeoseu-bangmungili" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#프로그래머스-방문길이"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/49994" target="_blank" rel="noopener">프로그래머스 방문길이</a></h1><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><blockquote><p>맵 시작점</p></blockquote><ul><li>음수의 값을 사용하기 싫었기 때문에 전체의 맵을 10x10으로 생각하여 시작점은 (5,5)에서 시작한다고 가정하였습니다.</li></ul><blockquote><p>간선 체크</p></blockquote><ul><li>간선보다는 정점을 체킹하는 형식으로 진행하였으나 중복점을 체킹하기가 어려워 간선풀이로 변경 Set자료구조를 사용하여 처리하였습니다.</li><li>시작 x, y 도착 tmp_x tmp_y 양방향을 HashSet에 넣어주면서 하나의 문자열을 간선처럼 생각하여 넣어주었습니다.</li></ul><blockquote><p>방향체크</p></blockquote><ul><li>방문 체크는 북, 남, 동, 서 4방향으로 진행하면서 간선을 체크하였습니다.</li></ul><blockquote><p>벽에 부딪혔을 때</p></blockquote><ul><li>벽에 부딪힌 경우는 방향을 이동하고나서 다시 제자리로 돌려주는 로직을 넣어주었습니다.</li></ul><blockquote><p>시간복잡도<br>O(dirs.length() + Hashset add()1) 즉, 상수를 무시하므로 O(N)</p></blockquote><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">programmers_</span>방문길이<span class="title">_kgh</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] check;</span><br><span class="line">    <span class="keyword">static</span> HashSet&lt;String&gt; hs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        solution(<span class="string">"ULURRDLLU"</span>);</span><br><span class="line">        solution(<span class="string">"LULLLLLLU"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(String dirs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dirs.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dirs.charAt(i) == <span class="string">'U'</span>)&#123;</span><br><span class="line">                idx = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dirs.charAt(i) == <span class="string">'D'</span>)&#123;</span><br><span class="line">                idx = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dirs.charAt(i) == <span class="string">'R'</span>)&#123;</span><br><span class="line">                idx = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dirs.charAt(i) == <span class="string">'L'</span>)&#123;</span><br><span class="line">                idx = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp_x = x;</span><br><span class="line">            <span class="keyword">int</span> tmp_y = y;</span><br><span class="line">            x = x + dir[idx][<span class="number">0</span>];</span><br><span class="line">            y = y + dir[idx][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set으로 고유값 저장</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">10</span> &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">                hs.add(x+<span class="string">""</span>+y+<span class="string">""</span>+tmp_x+<span class="string">""</span>+tmp_y);</span><br><span class="line">                hs.add(tmp_x+<span class="string">""</span>+tmp_y+<span class="string">""</span>+x+<span class="string">""</span>+y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 벽 부딪히는 경우</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                x = x - dir[idx][<span class="number">0</span>];</span><br><span class="line">                y = y - dir[idx][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hs.forEach(value -&gt;&#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(value);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">// 간선으로 처리하였으므로 / 2(양방향 -&gt; 단방향 개수)</span></span><br><span class="line">        answer = hs.size()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;peurogeuraemeoseu-bangmungili&quot;&gt;&lt;a href=&quot;#peurogeuraemeoseu-bangmungili&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="프로그래머스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="Set자료구조" scheme="http://gwanhyeon.github.io/tags/set%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"/>
    
      <category term="간선" scheme="http://gwanhyeon.github.io/tags/%EA%B0%84%EC%84%A0/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 배달</title>
    <link href="http://gwanhyeon.github.io/Programmers-20201114-Programmers-delivery/"/>
    <id>http://gwanhyeon.github.io/Programmers-20201114-Programmers-delivery/</id>
    <published>2020-11-14T13:27:38.000Z</published>
    <updated>2020-11-14T13:39:34.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="peurogeuraemeoseu-baedal"><a href="#peurogeuraemeoseu-baedal" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#프로그래머스-배달"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/12978" target="_blank" rel="noopener">프로그래머스 배달</a></h1><h3 id="munje-seolmyeong"><a href="#munje-seolmyeong" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제-설명"></a> 문제 설명</h3><p>N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다.</p><p>위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.<br>마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.</p><p><img src="https://res.cloudinary.com/dpxurmkij/image/upload/c_scale,w_250/v1494901794/%EB%B0%B0%EB%8B%AC_1_uxun8t.png" alt="Image1"></p><h3 id="jehansahang"><a href="#jehansahang" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#제한사항"></a> 제한사항</h3><p>마을의 개수 N은 1 이상 50 이하의 자연수입니다.<br>road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.<br>road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.<br>road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.<br>a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.<br>두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.<br>한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.<br>K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.<br>임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.<br>1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.</p><h3 id="ibculryeog-ye"><a href="#ibculryeog-ye" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#입출력-예"></a> 입출력 예</h3><p>N    road    K    result<br>5    [[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]]    3    4<br>6    [[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]]    4    4</p><p>입출력 예 설명</p><h3 id="ibculryeog-ye-1"><a href="#ibculryeog-ye-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#입출력-예-1"></a> 입출력 예 #1</h3><p>문제의 예시와 같습니다.</p><h3 id="ibculryeog-ye-2"><a href="#ibculryeog-ye-2" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#입출력-예-2"></a> 입출력 예 #2</h3><p>주어진 마을과 도로의 모양은 아래 그림과 같습니다.<br>1번 마을에서 배달에 4시간 이하가 걸리는 마을은 [1, 2, 3, 5] 4개이므로 4를 return 합니다.<br><img src="https://res.cloudinary.com/dpxurmkij/image/upload/c_scale,w_250/v1494911214/%EB%B0%B0%EB%8B%AC_3_njc7kq.png" alt="Image2"></p><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>그래프문제는 <code>자료구조를 인접행렬이나 인접리스트</code>로 접근해야될 것을 생각하여 <code>DFS나 BFS 알고리즘</code>을 사용해야한다는 생각을 가지고 있어야합니다.</li><li>각 노드의 가중치값이 최솟값이 될 수 있어야하기 때문에 <code>우선순위큐</code>를 사용하여 작은순서대로 처리하였습니다.</li></ul><blockquote><p>우선순위큐(Priority Queue)</p></blockquote><p>Pair클래스에 Comparable implements를 하여 compareTo함수를 사용하여 우선순위큐의 조건을 바로 사용할 수 있도록 하였습니다.</p><p><strong>오름차순 정렬</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair pair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value - pair.value; (오름차순)</span><br><span class="line">    <span class="keyword">return</span> pair.value - <span class="keyword">this</span>.value; (내림차순)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>가장 작은 가중치값을 찾아야하므로 비교를 위해 모든값을 최대값으로 초기화하여 <code>check변수</code>에 <code>Integer.MAX_VALUE</code>값을 할당하였습니다.</p><blockquote><p>노드의 가중치값을 어떻게 비교할까요?</p></blockquote><p>현재 노드의 거리, 현재까지의 거리를 더한값을 현재 각 노드의 거리 저장값과 비교하여 <code>더 작을 경우 값을 갱신</code>시켜줍니다.</p><blockquote><p>거리의 합이 K값의 이하의 값을 처리할때는 어떻게 할까요?</p></blockquote><p><code>체크된 거리값들이 &lt;= K 의 범위</code>를 만족하는 값들만 <code>answer를 카운팅</code> 시켜줍니다.</p><blockquote><p>시간복잡도</p></blockquote><p>조건: V: 정점, E:간선<br>시간복잡도: <code>모든 정점을 방문 O(V)</code>, 우선순위큐 트리형식으로 값을 삽입/삭제 <code>O(logE)</code><br>즉, <code>O(V * log E)의 시간복잡도</code>를 같습니다.</p><blockquote><p>인접리스트 VS 인접행렬</p></blockquote><p><code>인접리스트</code> 시간복잡도: <code>O(V+E)</code><br><code>인접행렬</code> 시간복잡도: <code>O(V^2)</code></p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><blockquote><p>다익스트라</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">programmers_</span>배달<span class="title">_kgh</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PriorityQueue&lt;Pair&gt; pq;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Pair&gt;&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(solution(<span class="number">5</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>&#125;&#125;,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] road, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(check, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=N; i++)&#123;</span><br><span class="line">            arr.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;road.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = road[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = road[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> value = road[i][<span class="number">2</span>];</span><br><span class="line">            arr.get(x).add(<span class="keyword">new</span> Pair(y,value));</span><br><span class="line">            arr.get(y).add(<span class="keyword">new</span> Pair(x,value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;check.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check[i] &lt;= K)&#123;</span><br><span class="line">                answer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        check[x] = <span class="number">0</span>;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> Pair(x, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            Pair pair = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> from_y = pair.y;</span><br><span class="line">            <span class="keyword">int</span> from_value = pair.value;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.get(from_y).size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to_y = arr.get(from_y).get(i).y;</span><br><span class="line">                <span class="keyword">int</span> to_value = arr.get(from_y).get(i).value;</span><br><span class="line">                <span class="comment">//System.out.println(check[from_y] + to_value);</span></span><br><span class="line">                <span class="keyword">if</span>(check[to_y] &gt; check[from_y] + to_value)&#123;</span><br><span class="line">                    check[to_y] = check[from_y] + to_value;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> Pair(to_y, to_value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pair</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Pair(<span class="keyword">int</span> y, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair pair)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 오름차순 정렬</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value - pair.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;peurogeuraemeoseu-baedal&quot;&gt;&lt;a href=&quot;#peurogeuraemeoseu-baedal&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#프로그래머
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="인접리스트" scheme="http://gwanhyeon.github.io/tags/%EC%9D%B8%EC%A0%91%EB%A6%AC%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="우선순위큐" scheme="http://gwanhyeon.github.io/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/"/>
    
      <category term="다익스트라" scheme="http://gwanhyeon.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"/>
    
      <category term="힙" scheme="http://gwanhyeon.github.io/tags/%ED%9E%99/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 불량사용자</title>
    <link href="http://gwanhyeon.github.io/Programmers-20201112-Programmers-bad-user/"/>
    <id>http://gwanhyeon.github.io/Programmers-20201112-Programmers-bad-user/</id>
    <published>2020-11-12T07:27:34.000Z</published>
    <updated>2020-11-12T07:42:58.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="peurogeuraemeoseu-kakao-bulryangsayongja"><a href="#peurogeuraemeoseu-kakao-bulryangsayongja" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#프로그래머스-카카오-불량사용자"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/64064" target="_blank" rel="noopener">프로그래머스 카카오 불량사용자</a></h1><h2 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h2><h3 id="munje-seolmyeong"><a href="#munje-seolmyeong" class="header-anchor">1.1.1. </a><a class="markdownIt-Anchor" href="#문제-설명"></a> 문제 설명</h3><p>개발팀 내에서 이벤트 개발을 담당하고 있는 무지는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 프로도 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 ‘<em>’ 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 '</em>’ 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 ‘*’ 문자를 사용하였습니다.<br>무지와 프로도는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다.</p><p>예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면</p><p>응모자 아이디<br>frodo<br>fradi<br>crodo<br>abc123<br>frodoc<br>다음과 같이 불량 사용자 아이디 목록이 전달된 경우,</p><p>불량 사용자<br>fr<em>d</em><br>abc1**<br>불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다.</p><p>제재 아이디<br>frodo<br>abc123<br>제재 아이디<br>fradi<br>abc123<br>이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.</p><h3 id="jehansahang"><a href="#jehansahang" class="header-anchor">1.1.2. </a><a class="markdownIt-Anchor" href="#제한사항"></a> [제한사항]</h3><p>user_id 배열의 크기는 1 이상 8 이하입니다.<br>user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.<br>응모한 사용자 아이디들은 서로 중복되지 않습니다.<br>응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.<br>banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다.<br>banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.<br>불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 ‘<em>’ 로만 이루어져 있습니다.<br>불량 사용자 아이디는 '</em>’ 문자를 하나 이상 포함하고 있습니다.<br>불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.<br>제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.</p><h3 id="ibculryeog-ye"><a href="#ibculryeog-ye" class="header-anchor">1.1.3. </a><a class="markdownIt-Anchor" href="#입출력-예"></a> [입출력 예]</h3><p>user_id    banned_id    result<br>[“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]    [“fr<em>d</em>”, “abc1**”]    2<br>[“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]    [“<em>rodo&quot;, &quot;<em>rodo&quot;, &quot;</em></em>**<em><em>&quot;]    2<br>[“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]    [&quot;fr</em>d</em>”, “<em>rodo&quot;, &quot;</em>*****”, “******”]    3<br>입출력 예에 대한 설명</p><h3 id="ibculryeog-ye-1"><a href="#ibculryeog-ye-1" class="header-anchor">1.1.4. </a><a class="markdownIt-Anchor" href="#입출력-예-1"></a> 입출력 예 #1</h3><p>문제 설명과 같습니다.</p><h3 id="ibculryeog-ye-2"><a href="#ibculryeog-ye-2" class="header-anchor">1.1.5. </a><a class="markdownIt-Anchor" href="#입출력-예-2"></a> 입출력 예 #2</h3><p>다음과 같이 두 가지 경우가 있습니다.</p><p>제재 아이디<br>frodo<br>crodo<br>abc123<br>제재 아이디<br>frodo<br>crodo<br>frodoc</p><h3 id="ibculryeog-ye-3"><a href="#ibculryeog-ye-3" class="header-anchor">1.1.6. </a><a class="markdownIt-Anchor" href="#입출력-예-3"></a> 입출력 예 #3</h3><p>다음과 같이 세 가지 경우가 있습니다.<br>제재 아이디<br>frodo<br>crodo<br>abc123<br>frodoc<br>제재 아이디<br>fradi<br>crodo<br>abc123<br>frodoc<br>제재 아이디<br>fradi<br>frodo<br>abc123<br>frodoc</p><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>응모자 아이디 중에서 불량 사용자 아이디목록이 전달 된 경우 당첨에서 제외되어야할 아이디목록의 경우의 수를 반환하는 문제입니다.</li><li>정규표현식을 사용하여 불량아이디의 목록중에 <code>*</code> 표시가 되어 있는 값을 <code>.</code> 으로 변경해줍니다. 정규표현식에서 <code>.</code>의 표현은  <code>.</code> 임의의 한 문자(<code>필수입력, 문자의 종류 가리지 않음</code>)을 나타내기 때문에 어떠한 문자가 와도 가능함을 표현합니다.</li></ul><p>처음 <code>DFS로 모든 경우를 탐색</code>을 진행합니다. 불량아이디 목록이 가능한 경우를 찾기 위해서 입니다. 즉, 제제아이디를 찾기 위하여 DFS를 수행합니다.<br><code>idx는 0</code>부터 수행하는데 현재까지 수행한 <code>idx값이 불량 아이디 목록의 길이</code>와 같으면 <code>Basement 조건</code>을 주어 종료시켜줍니다.</p><p>이제, 유저 아이디 목록중에서 정규표현식의 조건에 매칭되는 문자를 찾아주면서 DFS를 진행하다보면 해당 check[i]가 true인 경우는 제제아이디의 값과 일치합니다.</p><p><code>StringBuilder</code>를 사용하여 <code>check[i] = true</code>인 인덱스의 값을 더해주면서 더해준 값을 중복되지 않는 값을 체크하기 위해서 HashSet에 넣어주게 됩니다. 이제 <code>모든 DFS</code>를 수행하고 <code>HashSet 사이즈 값을 반환</code> 시켜주면 제제 아이디로 처리되는 개수를 확인 할 수 있습니다.</p><p>정규표현식을 사용하면 쉽게 풀리는 문제였습니다.<br><a href="https://postitforhooney.tistory.com/entry/JavaRegex-%EC%9E%90%EB%B0%94-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0-%EC%98%88%EC%A0%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0" target="_blank" rel="noopener">정규표현식 참고 예제 </a></p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> HashSet&lt;String&gt; hs;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(String[] user_id, String[] banned_id)</span> </span>&#123;</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">boolean</span>[user_id.length];</span><br><span class="line">        hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dfs(user_id, banned_id, <span class="number">0</span>);</span><br><span class="line">        answer = hs.size();</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String[] user_id, String[] banned_id, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// basement</span></span><br><span class="line">        <span class="keyword">if</span>(idx == banned_id.length)&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;user_id.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">                    sb.append(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hs.contains(sb.toString()))&#123;</span><br><span class="line">                hs.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;user_id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String rex = banned_id[idx].replace(<span class="string">"*"</span>, <span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">if</span>(user_id[i].matches(rex))&#123;</span><br><span class="line">                check[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(user_id, banned_id, idx+<span class="number">1</span>);</span><br><span class="line">                check[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;peurogeuraemeoseu-kakao-bulryangsayongja&quot;&gt;&lt;a href=&quot;#peurogeuraemeoseu-kakao-bulryangsayongja&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="문자열" scheme="http://gwanhyeon.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"/>
    
      <category term="정규표현식" scheme="http://gwanhyeon.github.io/tags/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 에라토스테네스의 체, 소수, 소인수분해</title>
    <link href="http://gwanhyeon.github.io/Algorithm-20201029-Algorithm-Eratosthenes/"/>
    <id>http://gwanhyeon.github.io/Algorithm-20201029-Algorithm-Eratosthenes/</id>
    <published>2020-10-29T11:43:23.000Z</published>
    <updated>2020-10-29T12:48:38.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sosu-prime-number"><a href="#sosu-prime-number" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#소수prime-number"></a> 소수(Prime Number)</h1><h2 id="sosuyi-jeongyi"><a href="#sosuyi-jeongyi" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#소수의-정의"></a> 소수의 정의</h2><p><code>소수란</code> 약수가 1과 자기 자신밖에 없는수를 일컫는 말입니다.</p><h2 id="sosuyi-teugjing"><a href="#sosuyi-teugjing" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소수의-특징"></a> 소수의 특징</h2><ol><li>N이 소수가 되려면 <code>2&lt;= N &lt;= N-1</code> 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안됩니다.<br>그 이유는 N의 약수중에서 가장 큰것은 N/2보다 작거나 같기 때문입니다.</li><li><code>N = a * b</code> 로 나타낼 수 있는데, <code>a가 작을 수록 b값이 크게</code> 됩니다.</li><li>가능한 a 중에서 가장 작은 값은 2이기 때문에 b는 <code>N/2</code>를 넘지 않습니다.</li><li>두 수 a와 b차이가 가장 작은 경우는 루트 N이기 때문에 <code>루트 N</code>까지만 검사를 진행하면 됩니다.</li><li>어떤 수 N이 소수인지 아닌지 알아내는데 걸리는 시간 복잡도는 <code>O(루트N)</code>이었다.</li><li><code>N= 백만일 경우: 루트 N=1000, N=1억인 경우: 루트 N=10000</code></li></ol><blockquote><p>만약, <code>1부터 1,000,000</code>까지 모든 소수를 구하는데 걸리는 시간복잡도는 어떻게 될까요?</p></blockquote><p>각각의 수에 대해서 소수 인지 아닌지를 검사해야합니다. <code>판별</code>만 하는데 사용되는 <code>시간복잡도: O(루트N)</code><br>수는 <code>총 N개</code>이기 때문에 <code>모든 소수</code>를 구하는데 걸리는 <code>시간복잡도는 N*O(루트N)</code>의 시간이 소요됩니다.<br>즉 <code>N이 1,000,000 백만</code>이라고 가정하였을때 시간복잡도는 <code>1,000,000 * 1,000 = 1,000,000,000 = 10억 = 10초</code>라는 시간이 걸리게 됩니다. 이는 1초에 1억을 연산하는 시간복잡도를 생각하였을때 큰 시간이 필요하게 됩니다.</p><blockquote><p>소수의 예시</p></blockquote><p>1-100까지의 소수<br><code>2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</code></p><blockquote><p>소수 판별 기본 함수</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">prime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>num값이 i로 나누어 떨어지는 값</code>이 <code>0일 경우</code> 소수가 아닙니다.</p><blockquote><p>소수 루트 N까지 진행하는 함수</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">prime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i*i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>루트 i&lt;=N은 i&lt;= N<em>N과 같이 나타내 수 있으며 즉, 루트 N은 i</em>i, i^2으로 나타낼 수 있다.<br>어떤 수 N이 소수인지 아닌지 <code>판별</code>만 하는데 걸리는 <code>시간복잡도는 O(루트 N)</code> 입니다.<br><code>모든 소수</code>를 구하게 되면 <code>N * O(루트N)</code>의 시간 복잡도를 갖는다는것에 유의해야합니다.</p><ul><li>지워지지 않은 수를 찾을 때 n이 아니라 <code>sqrt(n)</code> 까지만 찾습니다. i의 배수들을 지울 때 2 * i 에서 시작하는 것이 아니라 <code>i * i</code> 에서 시작한다. <code>2 * i에서 2의 배수 들은 모두 지워졌을 것이고 3 * i 는 3의 배수를 지울 때 이미 지워졌을 것입니다.</code></li></ul><h1 id="eratoseuteneseuyi-ce-sieve-of-eratosthenes"><a href="#eratoseuteneseuyi-ce-sieve-of-eratosthenes" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#에라토스테네스의-체sieve-of-eratosthenes"></a> 에라토스테네스의 체(Sieve of Eratosthenes)</h1><h2 id="eratoseuteneseuyi-ce-jeongyi"><a href="#eratoseuteneseuyi-ce-jeongyi" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#에라토스테네스의-체-정의"></a> 에라토스테네스의 체 정의</h2><p>위에서 확인한 바와 같이 <code>1~1,000,000</code>까지 <code>모든 소수를 구하기 위해서는 많은 시간이 소요</code>되는것을 확인하였습니다. 이것을 해결하기 위해서 <code>에라토스테네스의 체</code>를 사용하면 해결 할 수 있습니다.</p><blockquote><p>에라토스테네스의 체 원리</p></blockquote><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="에라토스테네스의 체 원리"></p><p><strong>1. 2부터 N까지 모든 수를 써놓는다.</strong><br><strong>2. 아직 지워지지않은 수 중에서 가장 작은수를 찾는다.</strong><br><strong>3. 그 수는 소수이다.</strong><br><strong>4. 이제 그 수의 배수를 모두 지웁니다.</strong></p><blockquote><p>과정</p></blockquote><p><strong>1. 지워지지 않은 수 중에서 가장 작은 수는 2이다.</strong><br><strong>2. 2는 소수이고 2의 배수를 모두 지웁니다.</strong><br><strong>3. 3의 배수를 지웁니다.</strong><br><strong>4. 5의 배수를 지웁니다.</strong><br><strong>5. 7의 배수를 지웁니다.</strong><br><strong>6. 11의 배수는 이미 지워져있습니다. 이미 2,3,5,7의 배수를 지우는 과정에서 지워졌기때문입니다.</strong><br><strong>7. 11*11은 특히 121로 100을 넘어가기 때문에 더이상 수행할 필요가 없게 됩니다. 따라서, 남아 있는 모든 수가 소수가 되게 됩니다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*소수 저장*/</span></span><br><span class="line"><span class="keyword">int</span>[] prime = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line"><span class="comment">/*소수의 개수를 저장하기 위한 변수*/</span></span><br><span class="line"><span class="keyword">int</span> prime_num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*소수가 지워졌으면 true*/</span></span><br><span class="line"><span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">101</span>];</span><br><span class="line"><span class="comment">/*100까지의 소수*/</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(check[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    prime[prime_num++] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i; j&lt;=n; j+=i)&#123;</span><br><span class="line">        check[j] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 잘보면 i*i 대신 i+i 부터 시작하는것을 볼 수 있는데, 그 이유는 <code>i가 백만일 경우 i*i</code>를 하게되면 범위를 넘어서게 됩니다. 예를 들면 <code>백만 * 백만 일 경우 10^12</code>가 되기 때문에 <code>오버플로우</code>에 대해서 생각을 할 수 있어야합니다. <code>총 10^12</code>까지 진행되므로 <code>int형 자료형의 범위인 21억</code>까지 진행하기가 힘들 것으로 판단할 수 있어야합니다. 그리고, <code>long의 범위로 변경</code>하여 진행하여야합니다.</p><p><code>int 자료형: 2,147,483,646</code><br><code>long 자료형: 9,223,372,036,854,775,806</code></p><p>따라서, 21억 이상을 표현하려면 long형이 필요하다는것을 알 수 있어야합니다.</p><p>이것을 자바로 표현하였을때는 <code>Long.parseLong</code> 함수를 사용하여 long의 범위를 Long의 형태로 바꾸어줄 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long.parseLong(<span class="string">"9999962000357"</span>);</span><br></pre></td></tr></table></figure><h1 id="soinsu-bunhae-prime-factorization"><a href="#soinsu-bunhae-prime-factorization" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#소인수-분해prime-factorization"></a> 소인수 분해(prime factorization)</h1><h2 id="soinsubunhae-jeongyi"><a href="#soinsubunhae-jeongyi" class="header-anchor">3.1. </a><a class="markdownIt-Anchor" href="#소인수분해-정의"></a> 소인수분해 정의</h2><blockquote><p>소인수분해란(prime factorization, integer factorization)?</p></blockquote><p>합성수를 소수의 곱으로 나타내는 방법을 말합니다. 소수의 곱으로 나타낼 수 있는 값을 <code>합성수</code>라고 합니다.<br>즉, <code>N이 4</code>일 경우 <code>소수 2를 두번곱</code>해서 만들 수 있는 값이 되는 것입니다. <code>N이 합성수가 되고 2는 소수가 되게 됩니다.</code></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/2/2b/PrimeDecompositionExample.png" alt="소인수분해 그림"></p><p>다음 아래는 합성수의 소인수 분해의 예시를 가져왔습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>＝<span class="number">2</span>×<span class="number">2</span></span><br><span class="line"><span class="number">6</span>＝<span class="number">2</span>×<span class="number">3</span></span><br><span class="line"><span class="number">8</span>＝<span class="number">2</span>×<span class="number">2</span>×<span class="number">2</span></span><br><span class="line"><span class="number">9</span>＝<span class="number">3</span>×<span class="number">3</span></span><br><span class="line"><span class="number">10</span>＝<span class="number">2</span>×<span class="number">5</span></span><br><span class="line"><span class="number">12</span>＝<span class="number">2</span>×<span class="number">2</span>×<span class="number">3</span></span><br><span class="line"><span class="number">14</span>＝<span class="number">2</span>×<span class="number">7</span></span><br><span class="line"><span class="number">15</span>＝<span class="number">3</span>×<span class="number">5</span></span><br><span class="line"><span class="number">16</span>＝<span class="number">2</span>×<span class="number">2</span>×<span class="number">2</span>×<span class="number">2</span></span><br><span class="line"><span class="number">18</span>＝<span class="number">2</span>×<span class="number">3</span>×<span class="number">3</span></span><br><span class="line"><span class="number">20</span>＝<span class="number">2</span>×<span class="number">2</span>×<span class="number">5</span></span><br><span class="line"><span class="number">21</span>＝<span class="number">3</span>×<span class="number">7</span></span><br><span class="line"><span class="number">22</span>＝<span class="number">2</span>×<span class="number">11</span></span><br></pre></td></tr></table></figure><p>아래문제는 직접 만들어본 문제입니다.</p><h2 id="habseongsuga-jueojimyeon-sosuyi-gobeuro-natanael-su-issneun-susjareul-guhasio-dan-1-lt-n-lt-1-000-000"><a href="#habseongsuga-jueojimyeon-sosuyi-gobeuro-natanael-su-issneun-susjareul-guhasio-dan-1-lt-n-lt-1-000-000" class="header-anchor">3.2. </a><a class="markdownIt-Anchor" href="#합성수가-주어지면-소수의-곱으로-나타낼-수-있는-숫자를-구하시오-단-1-n-1000000"></a> 합성수가 주어지면 소수의 곱으로 나타낼 수 있는 숫자를 구하시오. 단, 1&lt;= N &lt;= 1,000,000</h2><blockquote><p>자료형 접근</p></blockquote><p>소인수분해 가정에서 가장 중요하게 생각해야하는점은 i*i를 통해 소수의 값을 가져올때가 문제가 됩니다.<br><code>만약 i = 1,000,000일 경우 i * i = 1,000,000,000,000 약 10^12</code>까지 진행이 됩니다. 이럴 경우 int자료형으로는 접근할 수 없고,<code>long타입</code>을 사용해야겠다고 생각을 해야합니다.<br>위에서 말씀드린바와 같이 아래의 자료형의 범위를 갖게 됩니다. 21억 이상 표현하기 위해서는 long형을 사용합니다.</p><p><code>int 자료형: 2,147,483,646</code><br><code>long 자료형: 9,223,372,036,854,775,806</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long num = Long.parseLong(&quot;9999962000357&quot;);</span><br><span class="line">long num_tmp = Long.parseLong(&quot;9999962000357&quot;);</span><br></pre></td></tr></table></figure><p>해당 long의 범위를 구하기 위해서 위와 같이 표현하였습니다.</p><blockquote><p>소인수 분해의 원리</p></blockquote><p><code>2~N까지의 값</code>중에서 <code>N % i 의 값이 0</code> 일때 해당 몫의 값으로 다시 N에 넣어주면서 진행하는것을 뜻합니다. 결국 <code>i의 값이 소인수 분해의 값이고 N&gt;1클 경우 마지막의 값을 출력</code>시킬 수 있습니다.</p><p>반드시, <code>sqrt 루트</code>까지 진행하는데 에라토스테네스의체를 진행하면 <code>기존의 N배수는 지워졌을 것</code>이기때문에 Sqrt(N)까지만 진행해도 됩니다… 이것을 코드로 나타내면 <code>i=2; i*i ≤ N; i++</code>으로 나타낼 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">2</span>; i*i&lt;=num; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        num = num / i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num == num_tmp)&#123;</span><br><span class="line">    System.out.println(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>num == num_tmp</code>의 코드는 기존의 num값이 <code>num % i == 0인 값이 없다는 것</code>을 뜻하고 <code>즉, 소인수 되는 수를 찾을 수 없을때 -1</code>을 출력하는 코드입니다. 그리고 해당 <code>num의 값이 1보다 큰 값을 가지고 있으면 해당 마지막 인수를 출력</code>시켜주는 부분입니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">3.3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 소인수분해 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> num = Long.parseLong(<span class="string">"9999962000357"</span>);</span><br><span class="line">        <span class="keyword">long</span> num_tmp = Long.parseLong(<span class="string">"9999962000357"</span>);</span><br><span class="line">        HashMap&lt;String,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        long타입을 표현하기 위해서는 Long.parseLong으로 선언한다.</span></span><br><span class="line"><span class="comment">        최적화 방안</span></span><br><span class="line"><span class="comment">        - 지워지지 않은 수를 찾을 때 n이 아니라 sqrt(n) 까지만 찾는다.</span></span><br><span class="line"><span class="comment">        - i의 배수들을 지울 때 2 * i 에서 시작하는 것이 아니라 i * i 에서 시작한다. 2 * i에서 2의 배수 들은 모두 지워졌을 것이고 3 * i 는 3의 배수를 지울 때 이미 지워졌을 테니까.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">2</span>; i*i&lt;=num; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                num = num / i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == num_tmp)&#123;</span><br><span class="line">            System.out.println(<span class="string">"-1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sosu-prime-number&quot;&gt;&lt;a href=&quot;#sosu-prime-number&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#소수prime-number&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://gwanhyeon.github.io/categories/algorithm/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="소수" scheme="http://gwanhyeon.github.io/tags/%EC%86%8C%EC%88%98/"/>
    
      <category term="수학" scheme="http://gwanhyeon.github.io/tags/%EC%88%98%ED%95%99/"/>
    
      <category term="에라토스테네스의체" scheme="http://gwanhyeon.github.io/tags/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4/"/>
    
      <category term="소인수분해" scheme="http://gwanhyeon.github.io/tags/%EC%86%8C%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4/"/>
    
  </entry>
  
  <entry>
    <title>백준 연속합 1912</title>
    <link href="http://gwanhyeon.github.io/BOJ-20201027-BOJ-continuous-sum/"/>
    <id>http://gwanhyeon.github.io/BOJ-20201027-BOJ-continuous-sum/</id>
    <published>2020-10-27T05:47:44.000Z</published>
    <updated>2020-10-27T06:59:36.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-yeonsoghab-1912-munje"><a href="#baegjun-yeonsoghab-1912-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-연속합-1912-문제"></a> <a href="https://www.acmicpc.net/problem/1912" target="_blank" rel="noopener">백준 연속합 1912 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.</p><p>예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 답을 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>10<br>10 -4 3 1 5 6 -35 12 21 -1</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>33</p><h3 id="yeje-ibryeog-2"><a href="#yeje-ibryeog-2" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#예제-입력-2"></a> 예제 입력 2</h3><p>10<br>2 1 -4 3 4 -4 6 5 -5 1</p><h3 id="yeje-culryeog-2"><a href="#yeje-culryeog-2" class="header-anchor">1.7. </a><a class="markdownIt-Anchor" href="#예제-출력-2"></a> 예제 출력 2</h3><p>14</p><h3 id="yeje-ibryeog-3"><a href="#yeje-ibryeog-3" class="header-anchor">1.8. </a><a class="markdownIt-Anchor" href="#예제-입력-3"></a> 예제 입력 3</h3><p>5<br>-1 -2 -3 -4 -5</p><h3 id="yeje-culryeog-3"><a href="#yeje-culryeog-3" class="header-anchor">1.9. </a><a class="markdownIt-Anchor" href="#예제-출력-3"></a> 예제 출력 3</h3><p>-1</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>연속합 문제를 풀때 맨 처음에 생각한 방법은 DFS로 각각의 경우를 모두 구해서 합을 구하는 방식으로 구현하였습니다.<br>하지만, 4%쯤 되서 시간초과가 발생하는 불상사가 생기게 되었습니다. 문제를 다시 읽어보니 N의 제한이 <code>n(1 ≤ n ≤ 100,000)</code> 까지 였기때문에 <code>1초에 10억번연산을 수행해야하는 경우가 생길 수 있다고 판단</code>하였습니다.</li></ul><p>따라서, DFS로 구현하기에는 복잡도 면에서 무리가 있다고 생각하여 <code>메모이제이션(DP)</code>를 이용하였습니다.</p><p>테스트 케이스를 잘 살펴보면 이전의 합이 음수일때는 <code>가장 큰값</code>을 구할 수가 없습니다. 그리고, <code>(이전의 합 + 현재의 합)이 음수</code>일 경우도 최댓값을 구할 수가 없습니다.</p><p>따라서, 이것을 DP의 조건으로 생각하여 진행하였습니다.</p><blockquote><p>입력</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    dp[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>맨 처음의 최댓값을 dp[0]으로 기준을 잡고 bottom-up방식으로 구현을 진행하였습니다.</p><blockquote><p>DP 조건</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[i] + dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; dp[i-<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    dp[i] = dp[i-<span class="number">1</span>] + dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DP의 조건을 살펴보면 두가지</code>로 나눌 수 있습니다.</p><ol><li>처음 이전의 합이 음수라면 선택하지 않고 현재부터 다시 선택합니다. 즉, 이전의 합이 양수일때만 진행한다는 뜻입니다.</li><li>이전의 합과 현재의 수를 더한 값이 음수라면 선택하지 않습니다.</li></ol><blockquote><p>최댓값 선택</p></blockquote><p>만약 max값이 dp값보다 작을 경우 현재의 합을 max값으로 갱신시켜줍니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(max &lt; dp[i])&#123;</span><br><span class="line">    max = dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><blockquote><p>시간초과 브루트포스</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 연속합1912 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; answer;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> max = -<span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        n = Integer.parseInt(br.readLine());</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            arr[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dfs(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n || idx &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=idx; i&lt;cnt; i++)&#123;</span><br><span class="line">            ans += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; max)&#123;</span><br><span class="line">                max = ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(idx,cnt+<span class="number">1</span>);</span><br><span class="line">        dfs(idx+<span class="number">1</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DP</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 연속합1912<span class="title">DP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        n = Integer.parseInt(br.readLine());</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] + dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; dp[i-<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; dp[i])&#123;</span><br><span class="line">                max = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        첫번째 경우 dp[i-1] &gt; 0</span></span><br><span class="line"><span class="comment">          이전의 합이 음수라면 선택하지 않습니다.</span></span><br><span class="line"><span class="comment">        두번째 경우 dp[i] + dp[i-1] &gt; 0</span></span><br><span class="line"><span class="comment">          이전의 합과 현재의 수를 더한 값이 음수라면 선택하지 않습니다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-yeonsoghab-1912-munje&quot;&gt;&lt;a href=&quot;#baegjun-yeonsoghab-1912-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
      <category term="DP" scheme="http://gwanhyeon.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>백준 Mootube 15591</title>
    <link href="http://gwanhyeon.github.io/BOJ-20210108-boj-mootube/"/>
    <id>http://gwanhyeon.github.io/BOJ-20210108-boj-mootube/</id>
    <published>2020-10-27T05:23:18.000Z</published>
    <updated>2021-01-07T16:19:05.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-mootube-15591-munje"><a href="#baegjun-mootube-15591-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-mootube-15591-문제"></a> <a href="https://www.acmicpc.net/problem/15591" target="_blank" rel="noopener">백준 MOOTUBE 15591 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>농부 존은 남는 시간에 MooTube라 불리는 동영상 공유 서비스를 만들었다. MooTube에서 농부 존의 소들은 재밌는 동영상들을 서로 공유할 수 있다. 소들은 MooTube에 1부터 N까지 번호가 붙여진 N (1 ≤ N ≤ 5,000)개의 동영상을 이미 올려 놓았다. 하지만, 존은 아직 어떻게 하면 소들이 그들이 좋아할 만한 새 동영상을 찾을 수 있을지 괜찮은 방법을 떠올리지 못했다.</p><p>농부 존은 모든 MooTube 동영상에 대해 “연관 동영상” 리스트를 만들기로 했다. 이렇게 하면 소들은 지금 보고 있는 동영상과 연관성이 높은 동영상을 추천 받을 수 있을 것이다.</p><p>존은 두 동영상이 서로 얼마나 가까운 지를 측정하는 단위인 “USADO”를 만들었다. 존은 N-1개의 동영상 쌍을 골라서 직접 두 쌍의 USADO를 계산했다. 그 다음에 존은 이 동영상들을 네트워크 구조로 바꿔서, 각 동영상을 정점으로 나타내기로 했다. 또 존은 동영상들의 연결 구조를 서로 연결되어 있는 N-1개의 동영상 쌍으로 나타내었다. 좀 더 쉽게 말해서, 존은 N-1개의 동영상 쌍을 골라서 어떤 동영상에서 다른 동영상으로 가는 경로가 반드시 하나 존재하도록 했다. 존은 임의의 두 쌍 사이의 동영상의 USADO를 그 경로의 모든 연결들의 USADO 중 최솟값으로 하기로 했다.</p><p>존은 어떤 주어진 MooTube 동영상에 대해, 값 K를 정해서 그 동영상과 USADO가 K 이상인 모든 동영상이 추천되도록 할 것이다. 하지만 존은 너무 많은 동영상이 추천되면 소들이 일하는 것이 방해될까 봐 걱정하고 있다! 그래서 그는 K를 적절한 값으로 결정하려고 한다. 농부 존은 어떤 K 값에 대한 추천 동영상의 개수를 묻는 질문 여러 개에 당신이 대답해주기를 바란다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>입력의 첫 번째 줄에는 N과 Q가 주어진다. (1 ≤ Q ≤ 5,000)</p><p>다음 N-1개의 줄에는 농부 존이 직접 잰 두 동영상 쌍의 USADO가 한 줄에 하나씩 주어진다. 각 줄은 세 정수 pi, qi, ri (1 ≤ pi, qi ≤ N, 1 ≤ ri ≤ 1,000,000,000)를 포함하는데, 이는 동영상 pi와 qi가 USADO ri로 서로 연결되어 있음을 뜻한다.</p><p>다음 Q개의 줄에는 농부 존의 Q개의 질문이 주어진다. 각 줄은 두 정수 ki와 vi(1 ≤ ki ≤ 1,000,000,000, 1 ≤ vi ≤ N)을 포함하는데, 이는 존의 i번째 질문이 만약 K = ki라면 동영상 vi를 보고 있는 소들에게 몇 개의 동영상이 추천될 지 묻는 것이라는 것을 뜻한다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>Q개의 줄을 출력한다. i번째 줄에는 농부 존의 i번째 질문에 대한 답변이 출력되어야 한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>4 3<br>1 2 3<br>2 3 2<br>2 4 4<br>1 2<br>4 1<br>3 1</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>3<br>0<br>2</p><h3 id="hinteu"><a href="#hinteu" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#힌트"></a> 힌트</h3><p>농부 존은 1번 동영상과 2번 동영상이 USADO 3을 가지고, 2번 동영상과 3번 동영상이 USADO 2를 가지고, 2번 동영상과 4번 동영상이 USADO 4를 가진다고 했다. 이것에 기반해서 1번 동영상과 3번 동영상의 USADO는 min(3,2)=2가 되고, 1번 동영상과 4번 동영상의 USADO는 min(3,4)=3이 되고, 3번 동영상과 4번 동영상의 USADO는 min(2,4)=2가 된다.</p><p>농부 존은 K=1일 때 2번 동영상, K=3일 때 1번 동영상, K=4일 때 1번 동영상을 보면 각각 몇 개의 동영상이 추천될까 궁금해하고 있다. K=1일 때 2번 동영상에서 추천되는 동영상은 1, 3, 4번 동영상이다. K=4일 때 1번 동영상으로부터 추천되는 동영상은 없다. 그러나 K=3일때는 1번 동영상에서 2번 동영상과 4번 동영상이 추천된다.</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><p>문제를 살펴보면 <code>K값은 유사도</code>를 뜻하고 <code>K값이상으로 연결된 노드만 동영상을 추천</code>시킬 수 있습니다. <code>인접된 노드들과의 관계에서 정답</code>을 구해야하므로 <code>인접리스트</code>로 풀어야겠다는 생각을 하게 되었습니다.</p><p>가장 먼저 인접리스트를 생성시켜서 모든 값들을 넣어주고 <code>(유사도, 출발시작 노드)</code>의 값을 바탕으로 BFS를 진행해줍니다. 모든 경우에 대해서 매번 다르게 수행해야하므로 check를 모두 초기화시키면서 진행합니다. 즉, 해당노드에서 <code>시작되는 노드와 연결된 값</code>을 모두 찾아줍니다. 그리고 <code>유사도값 이상</code>인 <code>가중치값</code>을 가진 값들을 찾아주면 됩니다.</p><p>노드에 대한 체크는 <code>check변수</code>로 해당 노드를 방문했는지를 체크해주고 해당 인접리스트에 가지고 있는 <code>value의 값이 k이상일때만</code> 다음 노드를 방문할 수 있게 해줍니다. 해당 조건을 만족한다면 answer의 값을 카운팅 시켜주면 동영상 추천이 가능한 노드의 개수를 구할 수 있게 됩니다. <code>결론적으로 인접리스트와 BFS를 활용한 문제</code>였으며 문제가 길고 복잡해보였지만 생각을 조금만 달리한다면 쉽게 풀 수 있던 문제였습니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">baekjoon_Mootube15591_kgh</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Pair&gt;&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">        n = Integer.parseInt(st.nextToken());</span><br><span class="line">        q = Integer.parseInt(st.nextToken());</span><br><span class="line">        initListNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> value = Integer.parseInt(st.nextToken());</span><br><span class="line">            arr.get(x).add(<span class="keyword">new</span> Pair(y,value));</span><br><span class="line">            arr.get(y).add(<span class="keyword">new</span> Pair(x,value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;q; i++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> k = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> v = Integer.parseInt(st.nextToken());</span><br><span class="line">            bfs(k, v);          <span class="comment">// k이상의 유사도, 시작노드</span></span><br><span class="line">            System.out.println(answer);</span><br><span class="line">            answer=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, n).forEach(i -&gt; arr.add(<span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5001</span>];</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        check[v] = <span class="keyword">true</span>;</span><br><span class="line">        q.add(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node = q.remove();</span><br><span class="line">            <span class="comment">// 연결된 노드에 있는것들을 모두 가져와서 체크</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.get(node).size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = arr.get(node).get(i).y;</span><br><span class="line">                <span class="keyword">int</span> value = arr.get(node).get(i).value;</span><br><span class="line">                <span class="comment">// 방문하지 않은 노드이고, 가중치값이 k보다 크거나 같을 경우만 진행한다. 그 외의 경우에는 진행하지 않는다. 조건을 만족 X</span></span><br><span class="line">                <span class="keyword">if</span> (!check[y] &amp;&amp; value &gt;= k) &#123;</span><br><span class="line">                    q.add(y);</span><br><span class="line">                    check[y] = <span class="keyword">true</span>;</span><br><span class="line">                    answer++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-mootube-15591-munje&quot;&gt;&lt;a href=&quot;#baegjun-mootube-15591-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
      <category term="인접리스트" scheme="http://gwanhyeon.github.io/tags/%EC%9D%B8%EC%A0%91%EB%A6%AC%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>백준 색종이 2563</title>
    <link href="http://gwanhyeon.github.io/BOJ-20201027-BOJ-colored-paper/"/>
    <id>http://gwanhyeon.github.io/BOJ-20201027-BOJ-colored-paper/</id>
    <published>2020-10-27T05:23:18.000Z</published>
    <updated>2020-10-27T05:30:37.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-saegjongi-2563-munje"><a href="#baegjun-saegjongi-2563-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-색종이-2563-문제"></a> <a href="https://www.acmicpc.net/problem/2563" target="_blank" rel="noopener">백준 색종이 2563 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.<br><img src="https://www.acmicpc.net/upload/images/IcZB4bH8h7wwEY6z7qyoqNXkMsh.png" alt="그림 1"></p><p>예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>3<br>3 7<br>15 7<br>5 2</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><h2 id="260"><a href="#260" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#260"></a> 260</h2><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>해당 가로,세로 크기가 각각 100인 정사각형의 모양의 흰색도화지 위에 가로,세로 크기가 10인 정사각형의 모양의 검은 색종이를 붙여 해당 검은색종이의 넓이를 구하는 문제입니다.</li></ul><blockquote><p>접근방법</p></blockquote><p>이 문제를 접근할때 검은색부분의 넓이를 모두 구해서 더해주는것으로 생각하고 진행하였습니다. 입력으로 총 N개의 검은색 정사각형의 왼쪽하단점이 주어지기 때문에 각 정사각형별로 가로 x, 세로 y라고 생각하였을때 x+10, y+10까지의 영역을 모두 더해주면 되겠다고 생각하였습니다.</p><p>그리고, 겹치는 부분에 있어서는 map라는 변수를 하나 선언하여 map의 값이 0이 일때만 넓이를 계산해주고 한번 넓이를 계산 해준곳은 1로 만들어주어서 체크해주었습니다. 즉, 겹치는 부분은 단 한번만 넓이를 더할 수 있게 처리하였습니다.</p><blockquote><p>정사각형의 넓이<br>정사각형의 넓이를 구할때 x ~ x+10, y ~ y+10까지 모두 값을 구해주게 되면 정사각형의 넓이를 구할 수 있습니다.</p></blockquote><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 색종이2563 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y= Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;x+<span class="number">10</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=y; j&lt;y+<span class="number">10</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                        map[i][j] = <span class="number">1</span>;</span><br><span class="line">                        sum+=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-saegjongi-2563-munje&quot;&gt;&lt;a href=&quot;#baegjun-saegjongi-2563-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
  </entry>
  
  <entry>
    <title>백준 빗물 14719</title>
    <link href="http://gwanhyeon.github.io/BOJ-20201026-BOJ-rain-water/"/>
    <id>http://gwanhyeon.github.io/BOJ-20201026-BOJ-rain-water/</id>
    <published>2020-10-26T12:05:30.000Z</published>
    <updated>2020-10-26T12:18:52.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-bismul-14719-munje"><a href="#baegjun-bismul-14719-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-빗물-14719-문제"></a> <a href="https://www.acmicpc.net/problem/14719" target="_blank" rel="noopener">백준 빗물 14719 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.<br><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/1.png" alt="빗물 그림1"><br><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/2.png" alt="빗물 그림2"></p><p>비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)</p><p>두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.</p><p>따라서 블록 내부의 빈 공간이 생길 수 없다. 또 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.</p><p>빗물이 전혀 고이지 않을 경우 0을 출력하여라.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>4 4<br>3 0 1 4</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>5</p><h3 id="yeje-ibryeog-2"><a href="#yeje-ibryeog-2" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#예제-입력-2"></a> 예제 입력 2</h3><p>4 8<br>3 1 2 3 4 1 1 2</p><h3 id="yeje-culryeog-2"><a href="#yeje-culryeog-2" class="header-anchor">1.7. </a><a class="markdownIt-Anchor" href="#예제-출력-2"></a> 예제 출력 2</h3><p>5</p><h3 id="yeje-ibryeog-3"><a href="#yeje-ibryeog-3" class="header-anchor">1.8. </a><a class="markdownIt-Anchor" href="#예제-입력-3"></a> 예제 입력 3</h3><p>3 5<br>0 0 0 2 0</p><h3 id="yeje-culryeog-3"><a href="#yeje-culryeog-3" class="header-anchor">1.9. </a><a class="markdownIt-Anchor" href="#예제-출력-3"></a> 예제 출력 3</h3><p>0</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li><p>2차원 세계 블록에서 빗물이 얼만큼 고이는지를 확인하는 문제이다. 이 문제는 이전에 풀어보았던 창고다각형 문제와 비슷하다.<br><a href="https://www.acmicpc.net/problem/2304" target="_blank" rel="noopener">백준 창고다각형 2304 문제</a><br><a href="https://gwanhyeon.github.io/warehouse-polygon/">창고다각형 2304 문제 풀이</a></p></li><li><p>이 문제에서 가장 중요한 점은 2차원 세계블록에서 블록내부의 빈 공간이 생길 수 없도록 빗물이 얼마나 고이는지를 확인하면 된다. 빗물이 고이지 않았으면 0, 고였으면 1로 처리해준다. 즉, 블록의 면적을 구할 수 있다.</p></li></ul><blockquote><ol><li>블록의 최대 높이의 인덱스 구하기</li></ol></blockquote><p><code>블록의 높이가 가장 높은 인덱스의 값</code>을 구해주어야 합니다. 그 이유는 <code>지붕의 높이가 가장 높은 인덱스의 값</code>을 기준으로 <code>빗물을 고이게 만들어</code>야하기 때문입니다.</p><blockquote><ol start="2"><li>블록의 높이가 있는 가장 작은 인덱스와 큰 인덱스 구하기</li></ol></blockquote><p>블록의 높이가 있는 가장 작은 인덱스와 큰 인덱스를 구해주어야 하는이유는 <code>블록의 최대 높이의 인덱스를 기준으로 좌측</code>, <code>우측의 최대로 가질 수 있는 블록의면적</code>을 구해야하기 때문입니다.</p><blockquote><p>문제 풀이</p></blockquote><ol><li>map이라는 배열을 하나 선언합니다. <code>배열의 인덱스값에는 블록의 인덱스값이 들어가게 되고 값에는 블록의 높이</code>가 들어가게 됩니다.</li><li>값을 입력 받는것과 동시에 블록의 높이를 가진 인덱스의 최댓값과 최솟값을 <code>Math.max(), Math.min()</code> 함수를 사용하여 구해주게 됩니다.</li><li>그리고, 지붕의 최댓값을 가지는 인덱스의값을 구해줍니다. 현재 <code>입력받은 인덱스의 값(블록의 높이)가 현재 블록의 높이 보다 클 경우 해당 인덱스 값을 갱신</code>시켜주게 됩니다.</li><li><code>좌측의 경우, 우측의 경우를 나누어서 블록의 만드는 값을 더해주면서 진행</code>해줍니다.</li></ol><blockquote><p>좌측</p></blockquote><p>좌측의 경우 블록의 높이를 가지는 <code>인덱스의 최솟값~블록의 높이가 가장 큰 블록의 인덱스값</code> 까지 값을 순회하면서 h의 값을 갱신하면서 순회하는 값의 높이가 더 클 경우에 sum의 값을 더해주게 됩니다.<br>예를 들면, 높이가 (2,1), (2,3)의 경우를 비교해보겠습니다.<br><code>높이가 idx=0 h= 2, idx=1 h= 1</code>일 경우 현재 <code>idx=0의 높이가 idx=1보다 더 크므로</code>, <code>Math.max()</code> 함수를 사용하여 <code>더 큰 h값으로 sum</code>의 값을 더해주면서 진행합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// left -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">    h = Math.max(h, map[i]);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>우측</p></blockquote><p>우측의 경우는 블록의 높이를 가지는 <code>인덱스의 최댓값~블록의 높이가 가장 큰 블록의 인덱스값</code>까지 값을 순회하면서 h의 값 역시 최댓값으로 sum에 값을 더해줍니다. 그 이유는 위와 같습니다.</p><p>최종적으로 <code>sum의 값에는 좌측에서의 최대로 가질 수 있는 높이값, 우측에서 최대로 가질 수 있는 높이값</code>을 가지고 있습니다. 하지만, 아직 구해지지않은 값은 <code>max_hight_idx의 값</code> 즉, 가장 높은 블록의 값을 더해지지않은 상태이기 때문에 <code>map[max_hight_idx]</code>의 값으로 최종 결과값을 출력시켜주게 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// right -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">   h = Math.max(h, map[i]);</span><br><span class="line">   sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>블록의 빗물만 구하는 방법<br>기존의 지붕의 높이에 기둥을 넣은 부분의 면적을 구하려면 기존의 블록의 채워진 모든 블록+빗물의 면적에서 - 블록의 값을 빼주면 현재 채워진 빗물의 양(면적)을 확인할 수 있습니다.<br><a href="https://www.acmicpc.net/problem/2304" target="_blank" rel="noopener">백준 창고다각형 2304 문제</a>와 유사한 문제입니다.</p></blockquote><p>결과적으로  <code>모든 영역의 넓이에서 - 각 영역의 기존의 값</code>을 빼준다면 빗물이 채워진 부분의 넓이를 구할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left_sum</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">    left_sum += map[i];</span><br><span class="line">    h = Math.max(map[i], h);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right_sum</span></span><br><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">    right_sum += map[i];</span><br><span class="line">    h = Math.max(map[i], h);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런형식으로 값을 구할 수 있겠습니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 빗물14719 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> map[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(st.nextToken());</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_hight_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i;</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">            map[x] = y;</span><br><span class="line">            max_idx = Math.max(max_idx, x);</span><br><span class="line">            min_idx = Math.min(min_idx, x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[x] &gt; map[max_hight_idx])&#123;</span><br><span class="line">                max_hight_idx = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left_sum</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">            left_sum += map[i];</span><br><span class="line">            h = Math.max(map[i], h);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// right_sum</span></span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">            right_sum += map[i];</span><br><span class="line">            h = Math.max(map[i], h);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> answer = sum - (left_sum + right_sum);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-bismul-14719-munje&quot;&gt;&lt;a href=&quot;#baegjun-bismul-14719-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#백
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
  </entry>
  
  <entry>
    <title>백준 창고 다각형 2304</title>
    <link href="http://gwanhyeon.github.io/BOJ-20201026-BOJ-warehouse-polygon/"/>
    <id>http://gwanhyeon.github.io/BOJ-20201026-BOJ-warehouse-polygon/</id>
    <published>2020-10-26T11:22:40.000Z</published>
    <updated>2020-10-27T06:51:45.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>창고 다각형의 면적이 최소가 되는 값을 찾아내는 문제입니다.</li></ul><p>이 문제에서 가장 중요한 점은 좌측과 우측으로 오면서 <code>순차적으로 진행되는 높이보다 값이 같거나 커야합니다.</code> 그래야지 지붕을 만들때 물이 고이지 않도록 만들 수 있게 됩니다.<br>문제의 조건을 살펴보면 <code>지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다. 지붕의 가장자리는 땅에 닿아야 한다.</code> 라는 조건을 가지고 있고 지붕의 최대 높이의 인덱스 구하기 지붕의 높이가 가장 높은 인덱스의 값을 구해주어야 합니다.<br>그 이유는 지붕의 높이가 <code>가장 높은 인덱스의 값을 기준으로 지붕</code>을 만들어야하기 때문입니다. 높이가 10이 되기 때문에 지붕의 최대 높이의 인덱스는 8이 됩니다.</p><p>지붕의 높이가 있는 <code>가장 작은 인덱스와 큰 인덱스 구하기</code> 지붕의 높이가 있는 <code>가장 작은 인덱스와 큰 인덱스</code>를 구해주어야 하는이유는 지붕의 최대 높이의 인덱스를 기준으로 <code>좌측, 우측</code>의 최대로 가질 수 있는 <code>지붕의 면적</code>을 구해야하기 때문입니다. 지붕의 높이를 가진 <code>가장 작은 인덱스를 2와 높이 4, 가장 큰 인덱스를 16과 8</code>를 가지게 됩니다.</p><blockquote><p>문제 풀이</p></blockquote><p>map이라는 배열을 하나 선언합니다. <code>배열의 인덱스값</code>에는 <code>지붕의 인덱스값</code>이 들어가게 되고 <code>값에는 지붕의 높이</code>가 들어가게 됩니다.<br>예) map[2] = 4, map[16] = 8 값을 입력 받는것과 동시에 지붕의 높이를 가진 인덱스의 최댓값과 최솟값을 <code>Math.max(),Math.min()</code> 함수를 사용하여 구해주게 됩니다.<br>그리고, 지붕의 최댓값을 가지는 인덱스의값을 구해줍니다. 현재 입력받은 <code>인덱스의 값(지붕의 높이)</code>가 현재 지붕의 높이 보다 클<br>경우 해당 인덱스 값을 갱신시켜주게 됩니다.</p><p>좌측의 경우, 우측의 경우를 나누어서 지붕을 만드는 값을 더해주면서 진행해줍니다.</p><blockquote><p>좌측</p></blockquote><p>지붕의 높이를 가지는 인덱스의 <code>최솟값~지붕의 높이</code>가 <code>가장 큰 지붕의 인덱스값 까지 값</code>을 순회하면서 h의 값을 갱신하면서 순회하는 값의 높이가 더 클 경우에 sum의 값을 더해주게 됩니다.</p><p>예를 들면, 높이가 (2,1), (2,3)의 경우를 비교해보겠습니다. 높이가 <code>idx=0 h= 2, idx=1 h= 1일 경우</code> 현재 idx=0의 높이가 idx=1보다 더 크므로, <code>Math.max()</code> 함수를 사용하여 더 큰 h값으로 sum의 값을 더해주면서 진행합니다. 그 이유는 현재 h값이 더 작을 경우 값을 더하게 되면 어떤 기둥의 윗면과 닿거나 옆면에 닿아야한다 라는 조건에 위배되기 때문입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// left -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">    h = Math.max(h, map[i]);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>우측<br>우측 우측의 경우는 지붕의 높이를 가지는 <code>인덱스의 최댓값~지붕의 높이</code>가 <code>가장 큰 지붕의 인덱스값</code>까지 값을 순회하면서 h의 값 역시 최댓값으로 sum에 값을 더해줍니다. 그 이유는 위와 같습니다. <code>최종적으로 sum의 값에는 좌측에서의 최대로 가질 수 있는 높이값, 우측에서 최대로 가질 수 있는 높이값을 가지고 있습니다.</code><br>하지만, 아직 구해지지않은 값은 max_hight_idx의 값 즉, <code>가장 높은 지붕의 값을 더해지지않은 상태이기 때문에 map[max_hight_idx]의 값으로 최종 결과값을 출력시켜주게 됩니다.</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// right -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">   h = Math.max(h, map[i]);</span><br><span class="line">   sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>응용하는 경우</p></blockquote><p>만약에, 현재 문제를 다른경우로 생각해보면 <code>기존의 지붕의 높이에 기둥을 넣은 부분의 면적</code>을 구하려면 어떻게 구할 수 있을까요? 즉, 채워진 부분의 넓이를 구하는 문제를 구할수도 있습니다. <a href="https://www.acmicpc.net/problem/1912" target="_blank" rel="noopener">백준 빗물 14719 문제</a> 과 유사한 문제입니다.</p><p>네 맞습니다. 방금까지 우리구한 모든 영역의 넓이에서 - 각 영역의 기존의 값을 빼준다면 채워진 부분의 넓이를 구할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;map.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; max_hight_idx)&#123;</span><br><span class="line">        left_sum += map[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=map.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; max_hight_idx)&#123;</span><br><span class="line">        right_sum += map[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런형식으로 값을 구할 수 있겠습니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 창고다각형2304 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 인덱스 가장작은값, 큰값 구하고 기둥중에서 높이가 가장 큰 인덱스를 구한다.</span></span><br><span class="line">        <span class="keyword">int</span> max_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_hight_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">            map[x] = y;</span><br><span class="line">            max_idx = Math.max(max_idx, x);</span><br><span class="line">            min_idx = Math.min(min_idx, x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[x] &gt; map[max_hight_idx])&#123;</span><br><span class="line">                max_hight_idx = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left -&gt; max_hight_idx</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">            h = Math.max(h, map[i]);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// right -&gt; max_hight_idx</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">            h = Math.max(h, map[i]);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;map.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; max_hight_idx)&#123;</span><br><span class="line">                left_sum += map[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=map.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max_hight_idx)&#123;</span><br><span class="line">                right_sum += map[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map[max_hight_idx] + sum);</span><br><span class="line">        <span class="comment">//System.out.println("left painting: "+ left_sum + " right painting : " + right_sum + " max painting :" + map[max_hight_idx]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;keompyutingjeog-sago&quot;&gt;&lt;a href=&quot;#keompyutingjeog-sago&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#컴퓨팅적-사고&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
  </entry>
  
  <entry>
    <title>백준 텀 프로젝트 9466</title>
    <link href="http://gwanhyeon.github.io/BOJ-20201022-BOJ-term-project/"/>
    <id>http://gwanhyeon.github.io/BOJ-20201022-BOJ-term-project/</id>
    <published>2020-10-22T14:08:19.000Z</published>
    <updated>2020-10-23T07:46:17.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-teom-peurojegteu-9466-munje"><a href="#baegjun-teom-peurojegteu-9466-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-텀-프로젝트-9466-문제"></a> <a href="https://www.acmicpc.net/problem/9466" target="_blank" rel="noopener">백준 텀 프로젝트 9466 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>이번 가을학기에 ‘문제 해결’ 강의를 신청한 학생들은 텀 프로젝트를 수행해야 한다. 프로젝트 팀원 수에는 제한이 없다. 심지어 모든 학생들이 동일한 팀의 팀원인 경우와 같이 한 팀만 있을 수도 있다. 프로젝트 팀을 구성하기 위해, 모든 학생들은 프로젝트를 함께하고 싶은 학생을 선택해야 한다. (단, 단 한 명만 선택할 수 있다.) 혼자 하고 싶어하는 학생은 자기 자신을 선택하는 것도 가능하다.</p><p>학생들이(s1, s2, …, sr)이라 할 때, r=1이고 s1이 s1을 선택하는 경우나, s1이 s2를 선택하고, s2가 s3를 선택하고,…, sr-1이 sr을 선택하고, sr이 s1을 선택하는 경우에만 한 팀이 될 수 있다.</p><p>예를 들어, 한 반에 7명의 학생이 있다고 하자. 학생들을 1번부터 7번으로 표현할 때, 선택의 결과는 다음과 같다.</p><p>1    2    3    4    5    6    7<br>3    1    3    7    3    4    6<br>위의 결과를 통해 (3)과 (4, 7, 6)이 팀을 이룰 수 있다. 1, 2, 5는 어느 팀에도 속하지 않는다.</p><p>주어진 선택의 결과를 보고 어느 프로젝트 팀에도 속하지 않는 학생들의 수를 계산하는 프로그램을 작성하라.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫 줄에는 학생의 수가 정수 n (2 ≤ n ≤ 100,000)으로 주어진다. 각 테스트 케이스의 둘째 줄에는 선택된 학생들의 번호가 주어진다. (모든 학생들은 1부터 n까지 번호가 부여된다.)</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>각 테스트 케이스마다 한 줄에 출력하고, 각 줄에는 프로젝트 팀에 속하지 못한 학생들의 수를 나타내면 된다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>2<br>7<br>3 1 3 7 3 4 6<br>8<br>1 2 3 4 5 6 7 8</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>3<br>0</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><blockquote><p>문제 해석</p></blockquote><p>텀 프로젝트 수행시 자기자신이 혼자 팀일 수도 있으며, 한 팀만 있을 수도 있을 때 텀 프로젝트를 구성하는 문제입니다.<br>이 문제에서 가장 중요한 점은 <code>학생들이(s1, s2, ..., sr)이라 할 때, r=1이고 s1이 s1을 선택하는 경우나, s1이 s2를 선택하고, s2가 s3를 선택하고,..., sr-1이 sr을 선택하고, sr이 s1을 선택하는 경우에만 한 팀이 될 수 있다.</code> 라는 조건입니다.</p><blockquote><p>그래프</p></blockquote><p>예시 문제에서 주어진 그래프는 다음과 같이 생성되어 있습니다.<br><code>1-2-3-5 3-3 4-6-7</code><br><code>총 2개의 연결요소에서 3-3 하나의 사이클, 4-6-7의 사이클이 존재</code>하는 것을 알 수 있습니다. <code>사이클이 존재</code>한다는 것은 즉, 팀을 구성한 것과 같습니다. <code>이 사이클이 존재하는 팀을 제외하고 나머지 인원의 개수</code>를 구하시면 됩니다.</p><blockquote><p>접근 방식</p></blockquote><p>맨 처음에 문제를 접근하였을때 인접리스트로 사이클을 구하는것처럼 처리해주고, 연결점이 같을때 <code>(3,3 x=y) cnt값을 처리해주면 되지 않을까</code> 라는 생각을 하게 되었습니다. 하지만 이렇게 하게되면 <code>시작점과 하나의 사이클이 연결되는 지점을 찾기가 어려웠습니다.</code></p><p>따라서, DFS를 사용한 재귀호출방식을 다시 고민해보기 시작하였습니다.</p><p>예시에서 주어진 <code>3 1 3 7 3 4 6의 예시를 이용하여 설명을 진행하겠습니다.</code></p><blockquote><p><code>3-&gt;3</code> 경우</p></blockquote><p>자기자신을 가리키기 하나의 팀으로 완성이 가능합니다.</p><blockquote><p><code>4-&gt;7-&gt;6-&gt;4</code>의 경우를 살펴보겠습니다.</p></blockquote><p>DFS구현시<br>DFS( 시작 변수 , 1-N 정점 cnt, 출발지점을 저장하기 위한 변수)로 재귀를 구현하였습니다.</p><p><code>check = 몇번째 노드를 방문했는지 개수 저장 startVertex = 해당 사이클에서 시작점 저장 cnt = 몇번쨰 노드 방문 개수 A = 1번부터 N까지의 노드가 가리키는 값 저장</code></p><blockquote><p>정점이 4인경우</p></blockquote><p>시작은 dfs(4,1,4)를 호출합니다.<br>check[4] = 1, startVertex[4] = 1</p><blockquote><p>정점이 7인 경우</p></blockquote><p>4가 7을 가리키기 때문에 <code>dfs(7, 2, 4)</code>를 호출합니다.<br>check[7] = 2, startVertex[7] = 4</p><blockquote><p>정점이 6인 경우</p></blockquote><p>7이 6을 가리키기 때문에 <code>dfs(6, 3, 4)</code>를 호출합니다.<br>check[6] = 3, startVertex[6] = 4</p><blockquote><p>정점이 4인 경우</p></blockquote><p>6은 4를 가리키기 때문에 <code>dfs(4, 4, 4)</code>를 호출합니다.</p><p>즉, 시작점과 끝점이 같아지는 경우입니다. 하나의 싸이클이 생성된것을 확인하실 수 있습니다.</p><p>이때, 체크해야할 부분은 세가지 입니다.</p><ol><li>방문하였던 정점인지 아닌지 확인</li></ol><ul><li><code>시작정점과 같지 않은지 확인</code>을 합니다. <code>시작정점과 같지 않으면 해당 재귀를 종료</code>합니다.</li><li>시작정점과 같으면 몇번째 지점에 방문한 점인지 리턴을 해주게 됩니다. 이때 <code>cnt-check[i]</code>의 값을 리턴해주게 되는데 이 값을 리턴해주게 되는 이유는 <code>처음시작점부터 노드를 지나 다시 처음시작점</code>으로 돌아왔을때 <code>총 4번의 과정</code>을 지나가게됩니다. 이때 현재 check[4]에 저장된 값은 1의 값을 나타냅니다. <code>노드를 들어온 순서</code>를 나타내는 값입니다. 즉, 4번의 과정은 3개의 노드들로 이루어진것이므로 <code>현재노드의 점을 빼주게 됩니다.</code> 즉, <code>cnt - check[4]=1</code> 으로 <code>총 3명</code>이 함께 <code>텀 프로젝트</code>를 진행하게 됩니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> cnt, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(check[x] != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(step != startVertex[x])&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(check[x]);</span><br><span class="line">          <span class="keyword">return</span> cnt-check[x];</span><br><span class="line">      &#125;</span><br><span class="line">      check[x] = cnt;</span><br><span class="line">      startVertex[x] = step;</span><br><span class="line">      <span class="keyword">return</span> dfs(A[x], cnt+<span class="number">1</span>, step);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>결론</p></blockquote><p>최종적으로 모든 DFS를 호출하고나면 텀 프로젝트 인원 3명 + 개인이 진행 1명 = 총 4명이 되고 전체 학생들의 수는 n = 7이 되기때문에 7-4 = 3명이 되게 됩니다. 7명의 학생중에 3명을 제외한 나머지 학생들은 텀프로젝트를 진행할 수 있다는 뜻입니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermProject9466</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] A;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] startVertex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st;</span><br><span class="line">        t = Integer.parseInt(br.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">            check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">            A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">            startVertex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">                A[x] = y;</span><br><span class="line">                check[x] = <span class="number">0</span>;</span><br><span class="line">                startVertex[x] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans += dfs(i,<span class="number">1</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(n-ans);</span><br><span class="line">            Arrays.fill(check,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> cnt, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[x] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(step != startVertex[x])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt-check[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        check[x] = cnt;</span><br><span class="line">        startVertex[x] = step;</span><br><span class="line">        <span class="keyword">return</span> dfs(A[x], cnt+<span class="number">1</span>, step);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-teom-peurojegteu-9466-munje&quot;&gt;&lt;a href=&quot;#baegjun-teom-peurojegteu-9466-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
      <category term="순열" scheme="http://gwanhyeon.github.io/tags/%EC%88%9C%EC%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>백준 반복 순열 2331</title>
    <link href="http://gwanhyeon.github.io/BOJ-20201022-BOJ-repeat-permutation/"/>
    <id>http://gwanhyeon.github.io/BOJ-20201022-BOJ-repeat-permutation/</id>
    <published>2020-10-22T10:46:11.000Z</published>
    <updated>2020-10-22T11:04:08.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-banbog-sunyeol-2331-munje"><a href="#baegjun-banbog-sunyeol-2331-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-반복-순열-2331-문제"></a> <a href="https://www.acmicpc.net/problem/2331" target="_blank" rel="noopener">백준 반복 순열 2331 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>다음과 같이 정의된 수열이 있다.</p><p>D[1] = A<br>D[n] = D[n-1]의 각 자리의 숫자를 P번 곱한 수들의 합<br>예를 들어 A=57, P=2일 때, 수열 D는 {57, 74(=5<sup>2+7</sup>2=25+49), 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, …}이 된다. 그 뒤에는 앞서 나온 수들(57부터가 아니라 58부터)이 반복된다.</p><p>이와 같은 수열을 계속 구하다 보면 언젠가 이와 같은 반복수열이 된다. 이때, 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 구하는 프로그램을 작성하시오. 위의 예에서는 {57, 74, 65, 61}의 네 개의 수가 남게 된다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 A(1 ≤ A ≤ 9999), P(1 ≤ P ≤ 5)가 주어진다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>57 2</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>4</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>이번 반복순열 문제는 중복되는 구간을 제외한 나머지영역의 개수를 구하는 문제입니다.</li><li>처음에 접근시에 인접리스트로 문제를 풀이하였었는데 <code>9%에서 런타임에러</code>로 계속 터지는 상황이 발생하여 <code>처음부터 로직을 구현</code>하게 되었습니다.</li><li>생각한 결과로 단순히 <code>DFS</code>로 중복이 cnt값을 <code>1~1,000,000</code>까지 값을 진행하다가 <code>순열의 값을 인덱스로 한 값을 cnt값으로 변경</code>하면서 진행하였습니다.</li></ul><blockquote><p>알고리즘 풀이</p></blockquote><p>예를 들어, 수열 D는 {57, 74(=5<sup>2+7</sup>2=25+49), 65, 61, <code>37, 58, 89, 145, 42, 20, 4, 16</code>, <code>37, …</code>}식으로 진행됩니다. 이때 37부터 값이 반복되고 있는 상황을 알 수 있습니다. <code>check[37]은 이미 5라는 값을 가지고 있겠지요?</code></p><p><code>check[57] = 1 check[74] = 2 check[65] = 3 check[61] = 4 check[37] = 5</code><br>의 형태로 저장되는 상황일 것입니다. 따라서 반복되는 <code>두번째시점의 37의 구간에서 37이 가지고 있는 값-1을 반환</code>하게 된다면 <code>중복이 나오기전의 시점의 개수</code>를 찾아낼 수 있습니다.</p><blockquote><p>아래는 DFS함수 코드의 일부를 가져왔습니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check[a] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> check[a]-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    check[a] = cnt;</span><br><span class="line">    <span class="keyword">int</span> b = getNextNumber(a, p);</span><br><span class="line">    <span class="keyword">return</span> dfs(b, p, cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>37로 예를 들어 check[37]은 이미 할당</code>되어있는 값이므로 <code>중복되는 시점</code>입니다. 따라서 <code>현재 값이 할당된 cnt값의 -1</code>은 <code>중복되지 않은 값의 개수</code>를 알 수 있습니다.</p><ul><li>나머지는 <code>한자리 숫자의 합을 구해주는 getNextNumber()함수</code>로 계속해서 값을 진행하게 하였습니다. 그리고 <code>dfs를 호출</code>해주면서 <code>이미 값을 가지고 있으면 해당값을 리턴하여 종료</code>하게 하였습니다.</li></ul><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 반복수열2331 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextNumber</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += Math.pow(a%<span class="number">10</span>, p);</span><br><span class="line">            a /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 예: check[37]은 이미 할당되어있는 값이므로 중복되는 시점이다. 따라서 현재 값이 할당된 cnt값의 -1은 중복되지 않은 값의 개수를 알 수 있다.</span></span><br><span class="line">        <span class="keyword">if</span> (check[a] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> check[a]-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check[a] = cnt;</span><br><span class="line">        <span class="keyword">int</span> b = getNextNumber(a, p);</span><br><span class="line">        <span class="keyword">return</span> dfs(b, p, cnt+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> p = sc.nextInt();</span><br><span class="line">        System.out.println(dfs(a, p, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-banbog-sunyeol-2331-munje&quot;&gt;&lt;a href=&quot;#baegjun-banbog-sunyeol-2331-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
      <category term="순열" scheme="http://gwanhyeon.github.io/tags/%EC%88%9C%EC%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>백준 순열 사이클 10451</title>
    <link href="http://gwanhyeon.github.io/BOJ-20201022-BOJ-permutation-cycle/"/>
    <id>http://gwanhyeon.github.io/BOJ-20201022-BOJ-permutation-cycle/</id>
    <published>2020-10-22T05:37:35.000Z</published>
    <updated>2020-10-22T06:03:21.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="baegjun-sunyeol-saikeul-10451-munje"><a href="#baegjun-sunyeol-saikeul-10451-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-순열-사이클-10451-문제"></a> <a href="https://www.acmicpc.net/problem/10451" target="_blank" rel="noopener">백준 순열 사이클 10451 문제</a></h2><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>1부터 N까지 정수 N개로 이루어진 순열을 나타내는 방법은 여러 가지가 있다. 예를 들어, 8개의 수로 이루어진 순열 (3, 2, 7, 8, 1, 4, 5, 6)을 배열을 이용해 표현하면  와 같다. 또는, Figure 1과 같이 방향 그래프로 나타낼 수도 있다.</p><p>순열을 배열을 이용해  로 나타냈다면, i에서 πi로 간선을 이어 그래프로 만들 수 있다.</p><p>Figure 1에 나와있는 것 처럼, 순열 그래프 (3, 2, 7, 8, 1, 4, 5, 6) 에는 총 3개의 사이클이 있다. 이러한 사이클을 “순열 사이클” 이라고 한다.</p><p>N개의 정수로 이루어진 순열이 주어졌을 때, 순열 사이클의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 순열의 크기 N (2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 순열이 주어지며, 각 정수는 공백으로 구분되어 있다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>각 테스트 케이스마다, 입력으로 주어진 순열에 존재하는 순열 사이클의 개수를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>2<br>8<br>3 2 7 8 1 4 5 6<br>10<br>2 1 3 4 5 6 7 9 10 8</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>3<br>7</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>해당 문제는 그래프문제입니다. 그래프문제로 해당 순열으로 주어졌을때 순열 사이클의 개수를 구해주면 됩니다.</li></ul><p>문제에서 나와있듯이 <code>(3, 2, 7, 8, 1, 4, 5, 6)</code>의 배열을 이용하여 입력된 값들과 방향그래프로 만들어 낼 수 있습니다. <code>문제의 뜻을 이해하셨나요?</code></p><p>네 만약 8개의 수로 이루어져있을 경우 <code>(1,2,3,4,5,6,7,8)</code> <code>정점(Vertex)</code>을 가지게 됩니다. 순서대로 들어온 입력 값들을 <code>해당 정점들과 연결해주면 순열 그래프</code>가 나온다는 말입니다.</p><blockquote><p>순열과 그래프를 연결하기</p></blockquote><p><code>1번 Vertex - Value 3 2번 Vertex - Value 2 3번 Vertex - Value 7 4번 Vertex - Value 8 5번 Vertex - Value 1 6번 Vertex - Value 4 7번 Vertex - Value 5 8번 Vertex - Value 6</code></p><p>하나의 그래프 형태에서 <code>순열사이클의 개수</code>를 구하는것이 <code>포인트</code>입니다. 즉 ,<code>연결요소를 이루는 집합이 몇개</code>인지를 찾으면 됩니다. 따라서, 하나의 정점들과 연결된 그래프들은 모두 <code>Check</code>를 시키게 될 것이고, 이때 DFS를 이용하여 인접 리스트로 값을 처리하였고 한번 순회시 <code>Cnt+1</code>값을 처리하여 <code>순열 사이클의 개수</code>를 구할 수 있도록 하였습니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 순열사이클10451 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; A;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        t = Integer.parseInt(br.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = Integer.parseInt(br.readLine());</span><br><span class="line">            check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">            StringTokenizer st;</span><br><span class="line">            A = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                A.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> x = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">                A.get(x).add(y);</span><br><span class="line">                A.get(y).add(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!check[i])&#123;</span><br><span class="line">                    dfs(i);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cnt);</span><br><span class="line">            Arrays.fill(check,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        check[x] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.get(x).size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = A.get(x).get(i);</span><br><span class="line">            <span class="keyword">if</span>(!check[y])&#123;</span><br><span class="line">                dfs(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;baegjun-sunyeol-saikeul-10451-munje&quot;&gt;&lt;a href=&quot;#baegjun-sunyeol-saikeul-10451-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
      <category term="순열" scheme="http://gwanhyeon.github.io/tags/%EC%88%9C%EC%97%B4/"/>
    
  </entry>
  
</feed>
