<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Ethan Kim IT Blog</title>
  
  <subtitle>Ethan Kim IT Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gwanhyeon.github.io/"/>
  <updated>2020-10-27T06:04:28.604Z</updated>
  <id>http://gwanhyeon.github.io/</id>
  
  <author>
    <name>Ethan Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 연속합 1912</title>
    <link href="http://gwanhyeon.github.io/continuous-sum/"/>
    <id>http://gwanhyeon.github.io/continuous-sum/</id>
    <published>2020-10-27T05:47:44.000Z</published>
    <updated>2020-10-27T06:04:28.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-yeonsoghab-1912-munje"><a href="#baegjun-yeonsoghab-1912-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-연속합-1912-문제"></a> <a href="https://www.acmicpc.net/problem/1912" target="_blank" rel="noopener">백준 연속합 1912 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.</p><p>예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 답을 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>10<br>10 -4 3 1 5 6 -35 12 21 -1</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>33</p><h3 id="yeje-ibryeog-2"><a href="#yeje-ibryeog-2" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#예제-입력-2"></a> 예제 입력 2</h3><p>10<br>2 1 -4 3 4 -4 6 5 -5 1</p><h3 id="yeje-culryeog-2"><a href="#yeje-culryeog-2" class="header-anchor">1.7. </a><a class="markdownIt-Anchor" href="#예제-출력-2"></a> 예제 출력 2</h3><p>14</p><h3 id="yeje-ibryeog-3"><a href="#yeje-ibryeog-3" class="header-anchor">1.8. </a><a class="markdownIt-Anchor" href="#예제-입력-3"></a> 예제 입력 3</h3><p>5<br>-1 -2 -3 -4 -5</p><h3 id="yeje-culryeog-3"><a href="#yeje-culryeog-3" class="header-anchor">1.9. </a><a class="markdownIt-Anchor" href="#예제-출력-3"></a> 예제 출력 3</h3><p>-1</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>연속합 문제를 풀때 맨 처음에 생각한 방법은 DFS로 각각의 경우를 모두 구해서 합을 구하는 방식으로 구현하였습니다.<br>하지만, 4%쯤 되서 시간초과가 발생하는 불상사가 생기게 되었습니다. 문제를 다시 읽어보니 N의 제한이 <code>n(1 ≤ n ≤ 100,000)</code> 까지 였기때문에 1초에 10억번연산을 수행해야하는 경우가 생길 수 있다고 판단하였습니다.</li></ul><p>따라서, DFS로 구현하기에는 복잡도 면에서 무리가 있다고 생각하여 메모이제이션(DP)를 이용하였습니다.</p><p>테스트 케이스를 잘 살펴보면 이전의 합이 음수일때는 가장 큰값을 구할 수가 없습니다. 그리고, (이전의 합 + 현재의 합)이 음수일 경우도 최댓값을 구할 수가 없습니다.</p><p>따라서, 이것을 DP의 조건으로 생각하여 진행하였습니다.</p><blockquote><p>입력</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    dp[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>맨 처음의 최댓값을 dp[0]으로 기준을 잡고 bottom-up방식으로 구현을 진행하였습니다.</p><blockquote><p>DP 조건</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[i] + dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; dp[i-<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    dp[i] = dp[i-<span class="number">1</span>] + dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DP의 조건을 살펴보면 두가지로 나눌 수 있습니다.</p><ol><li>처음 이전의 합이 음수라면 선택하지 않고 현재부터 다시 선택합니다. 즉, 이전의 합이 양수일때만 진행한다는 뜻입니다.</li><li>이전의 합과 현재의 수를 더한 값이 음수라면 선택하지 않습니다.</li></ol><blockquote><p>최댓값 선택<br>만약 max값이 dp값보다 작을 경우 현재의 합을 max값으로 갱신시켜줍니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(max &lt; dp[i])&#123;</span><br><span class="line">    max = dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 연속합1912<span class="title">DP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        n = Integer.parseInt(br.readLine());</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] + dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; dp[i-<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; dp[i])&#123;</span><br><span class="line">                max = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        첫번째 경우 dp[i-1] &gt; 0</span></span><br><span class="line"><span class="comment">          이전의 합이 음수라면 선택하지 않습니다.</span></span><br><span class="line"><span class="comment">        두번째 경우 dp[i] + dp[i-1] &gt; 0</span></span><br><span class="line"><span class="comment">          이전의 합과 현재의 수를 더한 값이 음수라면 선택하지 않습니다.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-yeonsoghab-1912-munje&quot;&gt;&lt;a href=&quot;#baegjun-yeonsoghab-1912-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
      <category term="DP" scheme="http://gwanhyeon.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>백준 색종이 2563</title>
    <link href="http://gwanhyeon.github.io/colored-paper/"/>
    <id>http://gwanhyeon.github.io/colored-paper/</id>
    <published>2020-10-27T05:23:18.000Z</published>
    <updated>2020-10-27T05:30:37.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-saegjongi-2563-munje"><a href="#baegjun-saegjongi-2563-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-색종이-2563-문제"></a> <a href="https://www.acmicpc.net/problem/2563" target="_blank" rel="noopener">백준 색종이 2563 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.<br><img src="https://www.acmicpc.net/upload/images/IcZB4bH8h7wwEY6z7qyoqNXkMsh.png" alt="그림 1"></p><p>예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>3<br>3 7<br>15 7<br>5 2</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><h2 id="260"><a href="#260" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#260"></a> 260</h2><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>해당 가로,세로 크기가 각각 100인 정사각형의 모양의 흰색도화지 위에 가로,세로 크기가 10인 정사각형의 모양의 검은 색종이를 붙여 해당 검은색종이의 넓이를 구하는 문제입니다.</li></ul><blockquote><p>접근방법</p></blockquote><p>이 문제를 접근할때 검은색부분의 넓이를 모두 구해서 더해주는것으로 생각하고 진행하였습니다. 입력으로 총 N개의 검은색 정사각형의 왼쪽하단점이 주어지기 때문에 각 정사각형별로 가로 x, 세로 y라고 생각하였을때 x+10, y+10까지의 영역을 모두 더해주면 되겠다고 생각하였습니다.</p><p>그리고, 겹치는 부분에 있어서는 map라는 변수를 하나 선언하여 map의 값이 0이 일때만 넓이를 계산해주고 한번 넓이를 계산 해준곳은 1로 만들어주어서 체크해주었습니다. 즉, 겹치는 부분은 단 한번만 넓이를 더할 수 있게 처리하였습니다.</p><blockquote><p>정사각형의 넓이<br>정사각형의 넓이를 구할때 x ~ x+10, y ~ y+10까지 모두 값을 구해주게 되면 정사각형의 넓이를 구할 수 있습니다.</p></blockquote><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 색종이2563 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y= Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;x+<span class="number">10</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=y; j&lt;y+<span class="number">10</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                        map[i][j] = <span class="number">1</span>;</span><br><span class="line">                        sum+=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-saegjongi-2563-munje&quot;&gt;&lt;a href=&quot;#baegjun-saegjongi-2563-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
  </entry>
  
  <entry>
    <title>백준 빗물 14719</title>
    <link href="http://gwanhyeon.github.io/rain-water/"/>
    <id>http://gwanhyeon.github.io/rain-water/</id>
    <published>2020-10-26T12:05:30.000Z</published>
    <updated>2020-10-26T12:18:52.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-bismul-14719-munje"><a href="#baegjun-bismul-14719-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-빗물-14719-문제"></a> <a href="https://www.acmicpc.net/problem/14719" target="_blank" rel="noopener">백준 빗물 14719 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.<br><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/1.png" alt="빗물 그림1"><br><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/2.png" alt="빗물 그림2"></p><p>비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)</p><p>두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.</p><p>따라서 블록 내부의 빈 공간이 생길 수 없다. 또 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.</p><p>빗물이 전혀 고이지 않을 경우 0을 출력하여라.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>4 4<br>3 0 1 4</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>5</p><h3 id="yeje-ibryeog-2"><a href="#yeje-ibryeog-2" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#예제-입력-2"></a> 예제 입력 2</h3><p>4 8<br>3 1 2 3 4 1 1 2</p><h3 id="yeje-culryeog-2"><a href="#yeje-culryeog-2" class="header-anchor">1.7. </a><a class="markdownIt-Anchor" href="#예제-출력-2"></a> 예제 출력 2</h3><p>5</p><h3 id="yeje-ibryeog-3"><a href="#yeje-ibryeog-3" class="header-anchor">1.8. </a><a class="markdownIt-Anchor" href="#예제-입력-3"></a> 예제 입력 3</h3><p>3 5<br>0 0 0 2 0</p><h3 id="yeje-culryeog-3"><a href="#yeje-culryeog-3" class="header-anchor">1.9. </a><a class="markdownIt-Anchor" href="#예제-출력-3"></a> 예제 출력 3</h3><p>0</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li><p>2차원 세계 블록에서 빗물이 얼만큼 고이는지를 확인하는 문제이다. 이 문제는 이전에 풀어보았던 창고다각형 문제와 비슷하다.<br><a href="https://www.acmicpc.net/problem/2304" target="_blank" rel="noopener">백준 창고다각형 2304 문제</a><br><a href="https://gwanhyeon.github.io/warehouse-polygon/">창고다각형 2304 문제 풀이</a></p></li><li><p>이 문제에서 가장 중요한 점은 2차원 세계블록에서 블록내부의 빈 공간이 생길 수 없도록 빗물이 얼마나 고이는지를 확인하면 된다. 빗물이 고이지 않았으면 0, 고였으면 1로 처리해준다. 즉, 블록의 면적을 구할 수 있다.</p></li></ul><blockquote><ol><li>블록의 최대 높이의 인덱스 구하기</li></ol></blockquote><p><code>블록의 높이가 가장 높은 인덱스의 값</code>을 구해주어야 합니다. 그 이유는 <code>지붕의 높이가 가장 높은 인덱스의 값</code>을 기준으로 <code>빗물을 고이게 만들어</code>야하기 때문입니다.</p><blockquote><ol start="2"><li>블록의 높이가 있는 가장 작은 인덱스와 큰 인덱스 구하기</li></ol></blockquote><p>블록의 높이가 있는 가장 작은 인덱스와 큰 인덱스를 구해주어야 하는이유는 <code>블록의 최대 높이의 인덱스를 기준으로 좌측</code>, <code>우측의 최대로 가질 수 있는 블록의면적</code>을 구해야하기 때문입니다.</p><blockquote><p>문제 풀이</p></blockquote><ol><li>map이라는 배열을 하나 선언합니다. <code>배열의 인덱스값에는 블록의 인덱스값이 들어가게 되고 값에는 블록의 높이</code>가 들어가게 됩니다.</li><li>값을 입력 받는것과 동시에 블록의 높이를 가진 인덱스의 최댓값과 최솟값을 <code>Math.max(), Math.min()</code> 함수를 사용하여 구해주게 됩니다.</li><li>그리고, 지붕의 최댓값을 가지는 인덱스의값을 구해줍니다. 현재 <code>입력받은 인덱스의 값(블록의 높이)가 현재 블록의 높이 보다 클 경우 해당 인덱스 값을 갱신</code>시켜주게 됩니다.</li><li><code>좌측의 경우, 우측의 경우를 나누어서 블록의 만드는 값을 더해주면서 진행</code>해줍니다.</li></ol><blockquote><p>좌측</p></blockquote><p>좌측의 경우 블록의 높이를 가지는 <code>인덱스의 최솟값~블록의 높이가 가장 큰 블록의 인덱스값</code> 까지 값을 순회하면서 h의 값을 갱신하면서 순회하는 값의 높이가 더 클 경우에 sum의 값을 더해주게 됩니다.<br>예를 들면, 높이가 (2,1), (2,3)의 경우를 비교해보겠습니다.<br><code>높이가 idx=0 h= 2, idx=1 h= 1</code>일 경우 현재 <code>idx=0의 높이가 idx=1보다 더 크므로</code>, <code>Math.max()</code> 함수를 사용하여 <code>더 큰 h값으로 sum</code>의 값을 더해주면서 진행합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// left -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">    h = Math.max(h, map[i]);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>우측</p></blockquote><p>우측의 경우는 블록의 높이를 가지는 <code>인덱스의 최댓값~블록의 높이가 가장 큰 블록의 인덱스값</code>까지 값을 순회하면서 h의 값 역시 최댓값으로 sum에 값을 더해줍니다. 그 이유는 위와 같습니다.</p><p>최종적으로 <code>sum의 값에는 좌측에서의 최대로 가질 수 있는 높이값, 우측에서 최대로 가질 수 있는 높이값</code>을 가지고 있습니다. 하지만, 아직 구해지지않은 값은 <code>max_hight_idx의 값</code> 즉, 가장 높은 블록의 값을 더해지지않은 상태이기 때문에 <code>map[max_hight_idx]</code>의 값으로 최종 결과값을 출력시켜주게 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// right -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">   h = Math.max(h, map[i]);</span><br><span class="line">   sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>블록의 빗물만 구하는 방법<br>기존의 지붕의 높이에 기둥을 넣은 부분의 면적을 구하려면 기존의 블록의 채워진 모든 블록+빗물의 면적에서 - 블록의 값을 빼주면 현재 채워진 빗물의 양(면적)을 확인할 수 있습니다.<br><a href="https://www.acmicpc.net/problem/2304" target="_blank" rel="noopener">백준 창고다각형 2304 문제</a>와 유사한 문제입니다.</p></blockquote><p>결과적으로  <code>모든 영역의 넓이에서 - 각 영역의 기존의 값</code>을 빼준다면 빗물이 채워진 부분의 넓이를 구할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left_sum</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">    left_sum += map[i];</span><br><span class="line">    h = Math.max(map[i], h);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right_sum</span></span><br><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">    right_sum += map[i];</span><br><span class="line">    h = Math.max(map[i], h);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런형식으로 값을 구할 수 있겠습니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 빗물14719 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> map[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(st.nextToken());</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_hight_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i;</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">            map[x] = y;</span><br><span class="line">            max_idx = Math.max(max_idx, x);</span><br><span class="line">            min_idx = Math.min(min_idx, x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[x] &gt; map[max_hight_idx])&#123;</span><br><span class="line">                max_hight_idx = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left_sum</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">            left_sum += map[i];</span><br><span class="line">            h = Math.max(map[i], h);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// right_sum</span></span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">            right_sum += map[i];</span><br><span class="line">            h = Math.max(map[i], h);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> answer = sum - (left_sum + right_sum);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-bismul-14719-munje&quot;&gt;&lt;a href=&quot;#baegjun-bismul-14719-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#백
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
  </entry>
  
  <entry>
    <title>백준 창고 다각형 2304</title>
    <link href="http://gwanhyeon.github.io/warehouse-polygon/"/>
    <id>http://gwanhyeon.github.io/warehouse-polygon/</id>
    <published>2020-10-26T11:22:40.000Z</published>
    <updated>2020-10-27T06:51:45.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>창고 다각형의 면적이 최소가 되는 값을 찾아내는 문제입니다.</li></ul><p>이 문제에서 가장 중요한 점은 좌측과 우측으로 오면서 <code>순차적으로 진행되는 높이보다 값이 같거나 커야합니다.</code> 그래야지 지붕을 만들때 물이 고이지 않도록 만들 수 있게 됩니다.<br>문제의 조건을 살펴보면 <code>지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다. 지붕의 가장자리는 땅에 닿아야 한다.</code> 라는 조건을 가지고 있고 지붕의 최대 높이의 인덱스 구하기 지붕의 높이가 가장 높은 인덱스의 값을 구해주어야 합니다.<br>그 이유는 지붕의 높이가 <code>가장 높은 인덱스의 값을 기준으로 지붕</code>을 만들어야하기 때문입니다. 높이가 10이 되기 때문에 지붕의 최대 높이의 인덱스는 8이 됩니다.</p><p>지붕의 높이가 있는 <code>가장 작은 인덱스와 큰 인덱스 구하기</code> 지붕의 높이가 있는 <code>가장 작은 인덱스와 큰 인덱스</code>를 구해주어야 하는이유는 지붕의 최대 높이의 인덱스를 기준으로 <code>좌측, 우측</code>의 최대로 가질 수 있는 <code>지붕의 면적</code>을 구해야하기 때문입니다. 지붕의 높이를 가진 <code>가장 작은 인덱스를 2와 높이 4, 가장 큰 인덱스를 16과 8</code>를 가지게 됩니다.</p><blockquote><p>문제 풀이</p></blockquote><p>map이라는 배열을 하나 선언합니다. <code>배열의 인덱스값</code>에는 <code>지붕의 인덱스값</code>이 들어가게 되고 <code>값에는 지붕의 높이</code>가 들어가게 됩니다.<br>예) map[2] = 4, map[16] = 8 값을 입력 받는것과 동시에 지붕의 높이를 가진 인덱스의 최댓값과 최솟값을 <code>Math.max(),Math.min()</code> 함수를 사용하여 구해주게 됩니다.<br>그리고, 지붕의 최댓값을 가지는 인덱스의값을 구해줍니다. 현재 입력받은 <code>인덱스의 값(지붕의 높이)</code>가 현재 지붕의 높이 보다 클<br>경우 해당 인덱스 값을 갱신시켜주게 됩니다.</p><p>좌측의 경우, 우측의 경우를 나누어서 지붕을 만드는 값을 더해주면서 진행해줍니다.</p><blockquote><p>좌측</p></blockquote><p>지붕의 높이를 가지는 인덱스의 <code>최솟값~지붕의 높이</code>가 <code>가장 큰 지붕의 인덱스값 까지 값</code>을 순회하면서 h의 값을 갱신하면서 순회하는 값의 높이가 더 클 경우에 sum의 값을 더해주게 됩니다.</p><p>예를 들면, 높이가 (2,1), (2,3)의 경우를 비교해보겠습니다. 높이가 <code>idx=0 h= 2, idx=1 h= 1일 경우</code> 현재 idx=0의 높이가 idx=1보다 더 크므로, <code>Math.max()</code> 함수를 사용하여 더 큰 h값으로 sum의 값을 더해주면서 진행합니다. 그 이유는 현재 h값이 더 작을 경우 값을 더하게 되면 어떤 기둥의 윗면과 닿거나 옆면에 닿아야한다 라는 조건에 위배되기 때문입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// left -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">    h = Math.max(h, map[i]);</span><br><span class="line">    sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>우측<br>우측 우측의 경우는 지붕의 높이를 가지는 <code>인덱스의 최댓값~지붕의 높이</code>가 <code>가장 큰 지붕의 인덱스값</code>까지 값을 순회하면서 h의 값 역시 최댓값으로 sum에 값을 더해줍니다. 그 이유는 위와 같습니다. <code>최종적으로 sum의 값에는 좌측에서의 최대로 가질 수 있는 높이값, 우측에서 최대로 가질 수 있는 높이값을 가지고 있습니다.</code><br>하지만, 아직 구해지지않은 값은 max_hight_idx의 값 즉, <code>가장 높은 지붕의 값을 더해지지않은 상태이기 때문에 map[max_hight_idx]의 값으로 최종 결과값을 출력시켜주게 됩니다.</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// right -&gt; max_hight_idx</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">   h = Math.max(h, map[i]);</span><br><span class="line">   sum += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>응용하는 경우</p></blockquote><p>만약에, 현재 문제를 다른경우로 생각해보면 <code>기존의 지붕의 높이에 기둥을 넣은 부분의 면적</code>을 구하려면 어떻게 구할 수 있을까요? 즉, 채워진 부분의 넓이를 구하는 문제를 구할수도 있습니다. <a href="https://www.acmicpc.net/problem/1912" target="_blank" rel="noopener">백준 빗물 14719 문제</a> 과 유사한 문제입니다.</p><p>네 맞습니다. 방금까지 우리구한 모든 영역의 넓이에서 - 각 영역의 기존의 값을 빼준다면 채워진 부분의 넓이를 구할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;map.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; max_hight_idx)&#123;</span><br><span class="line">        left_sum += map[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=map.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; max_hight_idx)&#123;</span><br><span class="line">        right_sum += map[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런형식으로 값을 구할 수 있겠습니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 창고다각형2304 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 인덱스 가장작은값, 큰값 구하고 기둥중에서 높이가 가장 큰 인덱스를 구한다.</span></span><br><span class="line">        <span class="keyword">int</span> max_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_hight_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">            map[x] = y;</span><br><span class="line">            max_idx = Math.max(max_idx, x);</span><br><span class="line">            min_idx = Math.min(min_idx, x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[x] &gt; map[max_hight_idx])&#123;</span><br><span class="line">                max_hight_idx = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left -&gt; max_hight_idx</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min_idx; i&lt;max_hight_idx; i++)&#123;</span><br><span class="line">            h = Math.max(h, map[i]);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// right -&gt; max_hight_idx</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_idx; i&gt;max_hight_idx; i--)&#123;</span><br><span class="line">            h = Math.max(h, map[i]);</span><br><span class="line">            sum += h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;map.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; max_hight_idx)&#123;</span><br><span class="line">                left_sum += map[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=map.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max_hight_idx)&#123;</span><br><span class="line">                right_sum += map[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map[max_hight_idx] + sum);</span><br><span class="line">        <span class="comment">//System.out.println("left painting: "+ left_sum + " right painting : " + right_sum + " max painting :" + map[max_hight_idx]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;keompyutingjeog-sago&quot;&gt;&lt;a href=&quot;#keompyutingjeog-sago&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#컴퓨팅적-사고&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
      <category term="구현" scheme="http://gwanhyeon.github.io/tags/%EA%B5%AC%ED%98%84/"/>
    
  </entry>
  
  <entry>
    <title>백준 텀 프로젝트 9466</title>
    <link href="http://gwanhyeon.github.io/term-project/"/>
    <id>http://gwanhyeon.github.io/term-project/</id>
    <published>2020-10-22T14:08:19.000Z</published>
    <updated>2020-10-23T07:46:17.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-teom-peurojegteu-9466-munje"><a href="#baegjun-teom-peurojegteu-9466-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-텀-프로젝트-9466-문제"></a> <a href="https://www.acmicpc.net/problem/9466" target="_blank" rel="noopener">백준 텀 프로젝트 9466 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>이번 가을학기에 ‘문제 해결’ 강의를 신청한 학생들은 텀 프로젝트를 수행해야 한다. 프로젝트 팀원 수에는 제한이 없다. 심지어 모든 학생들이 동일한 팀의 팀원인 경우와 같이 한 팀만 있을 수도 있다. 프로젝트 팀을 구성하기 위해, 모든 학생들은 프로젝트를 함께하고 싶은 학생을 선택해야 한다. (단, 단 한 명만 선택할 수 있다.) 혼자 하고 싶어하는 학생은 자기 자신을 선택하는 것도 가능하다.</p><p>학생들이(s1, s2, …, sr)이라 할 때, r=1이고 s1이 s1을 선택하는 경우나, s1이 s2를 선택하고, s2가 s3를 선택하고,…, sr-1이 sr을 선택하고, sr이 s1을 선택하는 경우에만 한 팀이 될 수 있다.</p><p>예를 들어, 한 반에 7명의 학생이 있다고 하자. 학생들을 1번부터 7번으로 표현할 때, 선택의 결과는 다음과 같다.</p><p>1    2    3    4    5    6    7<br>3    1    3    7    3    4    6<br>위의 결과를 통해 (3)과 (4, 7, 6)이 팀을 이룰 수 있다. 1, 2, 5는 어느 팀에도 속하지 않는다.</p><p>주어진 선택의 결과를 보고 어느 프로젝트 팀에도 속하지 않는 학생들의 수를 계산하는 프로그램을 작성하라.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫 줄에는 학생의 수가 정수 n (2 ≤ n ≤ 100,000)으로 주어진다. 각 테스트 케이스의 둘째 줄에는 선택된 학생들의 번호가 주어진다. (모든 학생들은 1부터 n까지 번호가 부여된다.)</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>각 테스트 케이스마다 한 줄에 출력하고, 각 줄에는 프로젝트 팀에 속하지 못한 학생들의 수를 나타내면 된다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>2<br>7<br>3 1 3 7 3 4 6<br>8<br>1 2 3 4 5 6 7 8</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>3<br>0</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><blockquote><p>문제 해석</p></blockquote><p>텀 프로젝트 수행시 자기자신이 혼자 팀일 수도 있으며, 한 팀만 있을 수도 있을 때 텀 프로젝트를 구성하는 문제입니다.<br>이 문제에서 가장 중요한 점은 <code>학생들이(s1, s2, ..., sr)이라 할 때, r=1이고 s1이 s1을 선택하는 경우나, s1이 s2를 선택하고, s2가 s3를 선택하고,..., sr-1이 sr을 선택하고, sr이 s1을 선택하는 경우에만 한 팀이 될 수 있다.</code> 라는 조건입니다.</p><blockquote><p>그래프</p></blockquote><p>예시 문제에서 주어진 그래프는 다음과 같이 생성되어 있습니다.<br><code>1-2-3-5 3-3 4-6-7</code><br><code>총 2개의 연결요소에서 3-3 하나의 사이클, 4-6-7의 사이클이 존재</code>하는 것을 알 수 있습니다. <code>사이클이 존재</code>한다는 것은 즉, 팀을 구성한 것과 같습니다. <code>이 사이클이 존재하는 팀을 제외하고 나머지 인원의 개수</code>를 구하시면 됩니다.</p><blockquote><p>접근 방식</p></blockquote><p>맨 처음에 문제를 접근하였을때 인접리스트로 사이클을 구하는것처럼 처리해주고, 연결점이 같을때 <code>(3,3 x=y) cnt값을 처리해주면 되지 않을까</code> 라는 생각을 하게 되었습니다. 하지만 이렇게 하게되면 <code>시작점과 하나의 사이클이 연결되는 지점을 찾기가 어려웠습니다.</code></p><p>따라서, DFS를 사용한 재귀호출방식을 다시 고민해보기 시작하였습니다.</p><p>예시에서 주어진 <code>3 1 3 7 3 4 6의 예시를 이용하여 설명을 진행하겠습니다.</code></p><blockquote><p><code>3-&gt;3</code> 경우</p></blockquote><p>자기자신을 가리키기 하나의 팀으로 완성이 가능합니다.</p><blockquote><p><code>4-&gt;7-&gt;6-&gt;4</code>의 경우를 살펴보겠습니다.</p></blockquote><p>DFS구현시<br>DFS( 시작 변수 , 1-N 정점 cnt, 출발지점을 저장하기 위한 변수)로 재귀를 구현하였습니다.</p><p><code>check = 몇번째 노드를 방문했는지 개수 저장 startVertex = 해당 사이클에서 시작점 저장 cnt = 몇번쨰 노드 방문 개수 A = 1번부터 N까지의 노드가 가리키는 값 저장</code></p><blockquote><p>정점이 4인경우</p></blockquote><p>시작은 dfs(4,1,4)를 호출합니다.<br>check[4] = 1, startVertex[4] = 1</p><blockquote><p>정점이 7인 경우</p></blockquote><p>4가 7을 가리키기 때문에 <code>dfs(7, 2, 4)</code>를 호출합니다.<br>check[7] = 2, startVertex[7] = 4</p><blockquote><p>정점이 6인 경우</p></blockquote><p>7이 6을 가리키기 때문에 <code>dfs(6, 3, 4)</code>를 호출합니다.<br>check[6] = 3, startVertex[6] = 4</p><blockquote><p>정점이 4인 경우</p></blockquote><p>6은 4를 가리키기 때문에 <code>dfs(4, 4, 4)</code>를 호출합니다.</p><p>즉, 시작점과 끝점이 같아지는 경우입니다. 하나의 싸이클이 생성된것을 확인하실 수 있습니다.</p><p>이때, 체크해야할 부분은 세가지 입니다.</p><ol><li>방문하였던 정점인지 아닌지 확인</li></ol><ul><li><code>시작정점과 같지 않은지 확인</code>을 합니다. <code>시작정점과 같지 않으면 해당 재귀를 종료</code>합니다.</li><li>시작정점과 같으면 몇번째 지점에 방문한 점인지 리턴을 해주게 됩니다. 이때 <code>cnt-check[i]</code>의 값을 리턴해주게 되는데 이 값을 리턴해주게 되는 이유는 <code>처음시작점부터 노드를 지나 다시 처음시작점</code>으로 돌아왔을때 <code>총 4번의 과정</code>을 지나가게됩니다. 이때 현재 check[4]에 저장된 값은 1의 값을 나타냅니다. <code>노드를 들어온 순서</code>를 나타내는 값입니다. 즉, 4번의 과정은 3개의 노드들로 이루어진것이므로 <code>현재노드의 점을 빼주게 됩니다.</code> 즉, <code>cnt - check[4]=1</code> 으로 <code>총 3명</code>이 함께 <code>텀 프로젝트</code>를 진행하게 됩니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> cnt, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(check[x] != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(step != startVertex[x])&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(check[x]);</span><br><span class="line">          <span class="keyword">return</span> cnt-check[x];</span><br><span class="line">      &#125;</span><br><span class="line">      check[x] = cnt;</span><br><span class="line">      startVertex[x] = step;</span><br><span class="line">      <span class="keyword">return</span> dfs(A[x], cnt+<span class="number">1</span>, step);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>결론</p></blockquote><p>최종적으로 모든 DFS를 호출하고나면 텀 프로젝트 인원 3명 + 개인이 진행 1명 = 총 4명이 되고 전체 학생들의 수는 n = 7이 되기때문에 7-4 = 3명이 되게 됩니다. 7명의 학생중에 3명을 제외한 나머지 학생들은 텀프로젝트를 진행할 수 있다는 뜻입니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermProject9466</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] A;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] startVertex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st;</span><br><span class="line">        t = Integer.parseInt(br.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">            check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">            A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">            startVertex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">                A[x] = y;</span><br><span class="line">                check[x] = <span class="number">0</span>;</span><br><span class="line">                startVertex[x] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans += dfs(i,<span class="number">1</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(n-ans);</span><br><span class="line">            Arrays.fill(check,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> cnt, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[x] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(step != startVertex[x])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt-check[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        check[x] = cnt;</span><br><span class="line">        startVertex[x] = step;</span><br><span class="line">        <span class="keyword">return</span> dfs(A[x], cnt+<span class="number">1</span>, step);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-teom-peurojegteu-9466-munje&quot;&gt;&lt;a href=&quot;#baegjun-teom-peurojegteu-9466-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
      <category term="순열" scheme="http://gwanhyeon.github.io/tags/%EC%88%9C%EC%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>백준 반복 순열 2331</title>
    <link href="http://gwanhyeon.github.io/repeat-permutation/"/>
    <id>http://gwanhyeon.github.io/repeat-permutation/</id>
    <published>2020-10-22T10:46:11.000Z</published>
    <updated>2020-10-22T11:04:08.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baegjun-banbog-sunyeol-2331-munje"><a href="#baegjun-banbog-sunyeol-2331-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-반복-순열-2331-문제"></a> <a href="https://www.acmicpc.net/problem/2331" target="_blank" rel="noopener">백준 반복 순열 2331 문제</a></h1><hr><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>다음과 같이 정의된 수열이 있다.</p><p>D[1] = A<br>D[n] = D[n-1]의 각 자리의 숫자를 P번 곱한 수들의 합<br>예를 들어 A=57, P=2일 때, 수열 D는 {57, 74(=5<sup>2+7</sup>2=25+49), 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, …}이 된다. 그 뒤에는 앞서 나온 수들(57부터가 아니라 58부터)이 반복된다.</p><p>이와 같은 수열을 계속 구하다 보면 언젠가 이와 같은 반복수열이 된다. 이때, 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 구하는 프로그램을 작성하시오. 위의 예에서는 {57, 74, 65, 61}의 네 개의 수가 남게 된다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 A(1 ≤ A ≤ 9999), P(1 ≤ P ≤ 5)가 주어진다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>57 2</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>4</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>이번 반복순열 문제는 중복되는 구간을 제외한 나머지영역의 개수를 구하는 문제입니다.</li><li>처음에 접근시에 인접리스트로 문제를 풀이하였었는데 <code>9%에서 런타임에러</code>로 계속 터지는 상황이 발생하여 <code>처음부터 로직을 구현</code>하게 되었습니다.</li><li>생각한 결과로 단순히 <code>DFS</code>로 중복이 cnt값을 <code>1~1,000,000</code>까지 값을 진행하다가 <code>순열의 값을 인덱스로 한 값을 cnt값으로 변경</code>하면서 진행하였습니다.</li></ul><blockquote><p>알고리즘 풀이</p></blockquote><p>예를 들어, 수열 D는 {57, 74(=5<sup>2+7</sup>2=25+49), 65, 61, <code>37, 58, 89, 145, 42, 20, 4, 16</code>, <code>37, …</code>}식으로 진행됩니다. 이때 37부터 값이 반복되고 있는 상황을 알 수 있습니다. <code>check[37]은 이미 5라는 값을 가지고 있겠지요?</code></p><p><code>check[57] = 1 check[74] = 2 check[65] = 3 check[61] = 4 check[37] = 5</code><br>의 형태로 저장되는 상황일 것입니다. 따라서 반복되는 <code>두번째시점의 37의 구간에서 37이 가지고 있는 값-1을 반환</code>하게 된다면 <code>중복이 나오기전의 시점의 개수</code>를 찾아낼 수 있습니다.</p><blockquote><p>아래는 DFS함수 코드의 일부를 가져왔습니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check[a] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> check[a]-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    check[a] = cnt;</span><br><span class="line">    <span class="keyword">int</span> b = getNextNumber(a, p);</span><br><span class="line">    <span class="keyword">return</span> dfs(b, p, cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>37로 예를 들어 check[37]은 이미 할당</code>되어있는 값이므로 <code>중복되는 시점</code>입니다. 따라서 <code>현재 값이 할당된 cnt값의 -1</code>은 <code>중복되지 않은 값의 개수</code>를 알 수 있습니다.</p><ul><li>나머지는 <code>한자리 숫자의 합을 구해주는 getNextNumber()함수</code>로 계속해서 값을 진행하게 하였습니다. 그리고 <code>dfs를 호출</code>해주면서 <code>이미 값을 가지고 있으면 해당값을 리턴하여 종료</code>하게 하였습니다.</li></ul><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 반복수열2331 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextNumber</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += Math.pow(a%<span class="number">10</span>, p);</span><br><span class="line">            a /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 예: check[37]은 이미 할당되어있는 값이므로 중복되는 시점이다. 따라서 현재 값이 할당된 cnt값의 -1은 중복되지 않은 값의 개수를 알 수 있다.</span></span><br><span class="line">        <span class="keyword">if</span> (check[a] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> check[a]-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check[a] = cnt;</span><br><span class="line">        <span class="keyword">int</span> b = getNextNumber(a, p);</span><br><span class="line">        <span class="keyword">return</span> dfs(b, p, cnt+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> p = sc.nextInt();</span><br><span class="line">        System.out.println(dfs(a, p, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;baegjun-banbog-sunyeol-2331-munje&quot;&gt;&lt;a href=&quot;#baegjun-banbog-sunyeol-2331-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
      <category term="순열" scheme="http://gwanhyeon.github.io/tags/%EC%88%9C%EC%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>백준 순열 사이클 10451</title>
    <link href="http://gwanhyeon.github.io/permutation-cycle/"/>
    <id>http://gwanhyeon.github.io/permutation-cycle/</id>
    <published>2020-10-22T05:37:35.000Z</published>
    <updated>2020-10-22T06:03:21.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="baegjun-sunyeol-saikeul-10451-munje"><a href="#baegjun-sunyeol-saikeul-10451-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-순열-사이클-10451-문제"></a> <a href="https://www.acmicpc.net/problem/10451" target="_blank" rel="noopener">백준 순열 사이클 10451 문제</a></h2><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>1부터 N까지 정수 N개로 이루어진 순열을 나타내는 방법은 여러 가지가 있다. 예를 들어, 8개의 수로 이루어진 순열 (3, 2, 7, 8, 1, 4, 5, 6)을 배열을 이용해 표현하면  와 같다. 또는, Figure 1과 같이 방향 그래프로 나타낼 수도 있다.</p><p>순열을 배열을 이용해  로 나타냈다면, i에서 πi로 간선을 이어 그래프로 만들 수 있다.</p><p>Figure 1에 나와있는 것 처럼, 순열 그래프 (3, 2, 7, 8, 1, 4, 5, 6) 에는 총 3개의 사이클이 있다. 이러한 사이클을 “순열 사이클” 이라고 한다.</p><p>N개의 정수로 이루어진 순열이 주어졌을 때, 순열 사이클의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 순열의 크기 N (2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 순열이 주어지며, 각 정수는 공백으로 구분되어 있다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>각 테스트 케이스마다, 입력으로 주어진 순열에 존재하는 순열 사이클의 개수를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>2<br>8<br>3 2 7 8 1 4 5 6<br>10<br>2 1 3 4 5 6 7 9 10 8</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>3<br>7</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>해당 문제는 그래프문제입니다. 그래프문제로 해당 순열으로 주어졌을때 순열 사이클의 개수를 구해주면 됩니다.</li></ul><p>문제에서 나와있듯이 <code>(3, 2, 7, 8, 1, 4, 5, 6)</code>의 배열을 이용하여 입력된 값들과 방향그래프로 만들어 낼 수 있습니다. <code>문제의 뜻을 이해하셨나요?</code></p><p>네 만약 8개의 수로 이루어져있을 경우 <code>(1,2,3,4,5,6,7,8)</code> <code>정점(Vertex)</code>을 가지게 됩니다. 순서대로 들어온 입력 값들을 <code>해당 정점들과 연결해주면 순열 그래프</code>가 나온다는 말입니다.</p><blockquote><p>순열과 그래프를 연결하기</p></blockquote><p><code>1번 Vertex - Value 3 2번 Vertex - Value 2 3번 Vertex - Value 7 4번 Vertex - Value 8 5번 Vertex - Value 1 6번 Vertex - Value 4 7번 Vertex - Value 5 8번 Vertex - Value 6</code></p><p>하나의 그래프 형태에서 <code>순열사이클의 개수</code>를 구하는것이 <code>포인트</code>입니다. 즉 ,<code>연결요소를 이루는 집합이 몇개</code>인지를 찾으면 됩니다. 따라서, 하나의 정점들과 연결된 그래프들은 모두 <code>Check</code>를 시키게 될 것이고, 이때 DFS를 이용하여 인접 리스트로 값을 처리하였고 한번 순회시 <code>Cnt+1</code>값을 처리하여 <code>순열 사이클의 개수</code>를 구할 수 있도록 하였습니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 순열사이클10451 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; A;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        t = Integer.parseInt(br.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = Integer.parseInt(br.readLine());</span><br><span class="line">            check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">            StringTokenizer st;</span><br><span class="line">            A = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                A.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> x = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">                A.get(x).add(y);</span><br><span class="line">                A.get(y).add(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!check[i])&#123;</span><br><span class="line">                    dfs(i);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cnt);</span><br><span class="line">            Arrays.fill(check,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        check[x] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.get(x).size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = A.get(x).get(i);</span><br><span class="line">            <span class="keyword">if</span>(!check[y])&#123;</span><br><span class="line">                dfs(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;baegjun-sunyeol-saikeul-10451-munje&quot;&gt;&lt;a href=&quot;#baegjun-sunyeol-saikeul-10451-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
      <category term="순열" scheme="http://gwanhyeon.github.io/tags/%EC%88%9C%EC%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>그래프 인접행렬, 인접리스트 및 DFS,BFS</title>
    <link href="http://gwanhyeon.github.io/graph-summary/"/>
    <id>http://gwanhyeon.github.io/graph-summary/</id>
    <published>2020-10-21T13:22:04.000Z</published>
    <updated>2020-10-21T16:51:02.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="geuraepeu"><a href="#geuraepeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#그래프"></a> 그래프</h1><p>그래프의 정의를 살펴보면 <code>G=(V,E)</code>가 성립하게 됩니다. <code>G: 그래프, V: 정점, E: 간선</code>을 의미합니다.</p><h1 id="gyeongro"><a href="#gyeongro" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#경로"></a> 경로</h1><p>만약 <code>A-&gt;C, A-&gt;B, C-&gt;B, E-&gt;B, C-&gt;E, C-&gt;D, D-&gt;E</code>의 정점과 간선으로 연결된 그래프가 있다고 생각하겠습니다. 이때 정점 A-&gt;B로 가는 경로는 몇가지 일까요?<br>총 4가지 입니다.</p><ol><li>A-&gt;B</li><li>A-&gt;C-&gt;E-&gt;B</li><li>A-&gt;C-&gt;D-&gt;E-&gt;B</li><li>A-&gt;C-&gt;B<br>의 경로가 나오게 됩니다.</li></ol><h1 id="banghyangi-issneun-geuraepeu"><a href="#banghyangi-issneun-geuraepeu" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#방향이-있는-그래프"></a> 방향이 있는 그래프</h1><p><code>A-&gt;C</code> 로 가는 같은 간선에 방향이 있을경우 이것을 <code>방향이 있는 그래프</code>라고 합니다.</p><h1 id="banghyangi-eobsneun-geuraepeu"><a href="#banghyangi-eobsneun-geuraepeu" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#방향이-없는-그래프"></a> 방향이 없는 그래프</h1><p><code>A-C</code> 로 가는 간선에 방향이 없는 경우를 <code>방향이 없는 그래프</code> 라고 합니다.</p><h1 id="du-jeongjeom-saie-geuraepeu"><a href="#du-jeongjeom-saie-geuraepeu" class="header-anchor">5. </a><a class="markdownIt-Anchor" href="#두-정점-사이에-그래프"></a> 두 정점 사이에 그래프</h1><p>두 정점 사이에 그래프는 <code>간선이 여러개</code> 존재할 수도 있습니다.</p><h1 id="sunhwan-rupeu"><a href="#sunhwan-rupeu" class="header-anchor">6. </a><a class="markdownIt-Anchor" href="#순환-루프"></a> 순환 루프</h1><p>자기자신으로 하는 <code>순환하는 간선</code>이 존재할 수도 있습니다.</p><h1 id="dansun-gyeongrowa-dansun-saikeul"><a href="#dansun-gyeongrowa-dansun-saikeul" class="header-anchor">7. </a><a class="markdownIt-Anchor" href="#단순-경로와-단순-사이클"></a> 단순 경로와 단순 사이클</h1><p>경로/사이클에서 같은 정점을 <code>두번 이상 방문하지 않는 경로/사이클</code>을 뜻합니다. 특별한 말이 없다면 일반적으로 사용할 경로와 사이클을 <code>단순 경로/사이클</code>이라고 합니다.</p><h1 id="casu-degree"><a href="#casu-degree" class="header-anchor">8. </a><a class="markdownIt-Anchor" href="#차수degree"></a> 차수(Degree)</h1><p><code>하나의 정점</code>에 연결되어 있는 <code>간선의 개수</code>를 뜻합니다.<br>예를 들면 <code>1-5, 2-5, 4,5 정점</code>간의 <code>간선으로 이루어진 그래프</code>가 있다고 생각하겠습니다.<br>지금 현재 5번 정점과 연결되어 있는 간선의 개수는 3개가 됩니다. 즉, <code>Degree차수의 값이 3개</code>라고 생각하시면 됩니다.</p><h1 id="gajungci"><a href="#gajungci" class="header-anchor">9. </a><a class="markdownIt-Anchor" href="#가중치"></a> 가중치</h1><p>그래프는 가중치의 값을 갖습니다. <code>정점과 정점사이의 간선에 가중치</code>가 부여될 수도 있는데요. 만약 <code>아무런 표시가 없다면 1</code>이라는 값으로 주어진다고 생각하시면 됩니다.</p><h1 id="geuraepeuyi-pyohyeon-injeobhaengryeol-injeob-riseuteu"><a href="#geuraepeuyi-pyohyeon-injeobhaengryeol-injeob-riseuteu" class="header-anchor">10. </a><a class="markdownIt-Anchor" href="#그래프의-표현인접행렬-인접-리스트"></a> 그래프의 표현(인접행렬, 인접 리스트)</h1><p>그래프의 표현의 종류는 인접행렬과 인접리스트로 나누어지게 됩니다. 해당 설명에서는 <code>i-&gt;j</code> 로 연결된 정점과 간선이 있다고 생각하겠습니다. 이것은 A[i] = j 와 연결된 정점을 행렬이나 링크드 리스트로 나타냅니다.</p><p>인접행렬은 말 그대로 행렬을 사용하여 인접한것이 있는지 없는지를 판단하는 행렬입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[i][j] = A[j][i] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>와 같이 서로 연결되어 있는것들을 행렬형식으로 처리할 수 있습니다.</p><p>인접리스트는 연결리스트를 사용하여 그래프를 표현하는 방식입니다.<br>i-&gt;j 로 연결된 리스트가 있다고 가정하면 이것을 인접리스트로 표현하면 다음과 같습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[i] = &#123;j&#125;</span><br></pre></td></tr></table></figure><p>이렇게 표현할 수 있습니다. 이것의 의미하는 바는 어떻게 될까요? i의 정점에 연결된 j 정점입니다.</p><p>이해를 돕기위해서 1-&gt;2 가중치 1, 1-&gt;3 가중치2 이라고 해보면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">1</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>으로 표현 할 수 있습니다.<br>하지만, 그래프는 가중치가 존재할 수도있겠죠? 이럴때는 어떻게할까요?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">1</span>] = &#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>과 같이 나타낼 수 있습니다.</p><h1 id="injeob-riseuteu-vs-injeob-haengryeol-siganbogjabdo-mic-teugjing"><a href="#injeob-riseuteu-vs-injeob-haengryeol-siganbogjabdo-mic-teugjing" class="header-anchor">11. </a><a class="markdownIt-Anchor" href="#인접-리스트-vs-인접-행렬-시간복잡도-및-특징"></a> 인접 리스트 VS 인접 행렬 시간복잡도 및 특징</h1><p><code>시간복잡도의 차이점</code>으로는 인접 리스트로 표현된 <code>그래프: O(V+E), 인접 행렬로 표현된 그래프: O(V^2)</code>로 나타낼 수 있습니다.</p><p>즉, 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프의 경우 <code>인접 행렬보다 인접 리스트</code>를 사용하는 것이 <code>시간복잡도면</code>에서 뛰어납니다.</p><h1 id="gipi-useon-tamsaeg-dfs"><a href="#gipi-useon-tamsaeg-dfs" class="header-anchor">12. </a><a class="markdownIt-Anchor" href="#깊이-우선-탐색dfs"></a> 깊이 우선 탐색(DFS)</h1><p>DFS는 말 그대로 깊이를 우선탐색하는 기법입니다. 진행시 깊이우선 계속해서 값이 있으면 최대깊이까지 들어가는것을 뜻합니다. 구현은 <code>Stack이나 Recursive</code>를 이용해서 갈 수 있는 만큼 최대 -&gt; 갈수 없으면 이전 정점으로 돌아갑니다.</p><h1 id="neolbi-useon-tamsaeg-bfs"><a href="#neolbi-useon-tamsaeg-bfs" class="header-anchor">13. </a><a class="markdownIt-Anchor" href="#넓이-우선-탐색bfs"></a> 넓이 우선 탐색(BFS)</h1><p>BFS는 <code>하나의 정점에서 갈 수 있는 모든정점을 방문</code>하고 <code>다음 깊이</code>로 들어가게 됩니다.<br>큐를 이용하여 갈 수 있는 <code>정점 모두 Queue -&gt; insert</code>를 해준후  <code>먼저 넣고 -&gt; Queue pop()</code>  의 형식으로 이루어 집니다.</p><p>각각의 그래프 탐색 방식이 다르기 때문에, 구현하는 방법도 너무나도 다릅니다.<br>보통 DFS를 사용하게 되면 <code>Stack을 사용하거나 재귀호출</code>을 이용한 구현을 하게 되며, BFS를 사용하게 된다면 <code>Queue</code>를 이용하는 방식이라고 알고 계셔야합니다.</p><h1 id="injeobriseuteureul-iyonghan-dfs-bfs-puli"><a href="#injeobriseuteureul-iyonghan-dfs-bfs-puli" class="header-anchor">14. </a><a class="markdownIt-Anchor" href="#인접리스트를-이용한-dfsbfs-풀이"></a> 인접리스트를 이용한 DFS,BFS 풀이</h1><p><code>인접행렬과 인접리스트</code> 이용한 백준 <code>DFS BFS 1260번 문제</code>를 예시로 가져와봤습니다.</p><blockquote><p>인접행렬<br>인접행렬을 이용한 풀이입니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Queue는 LinkedList 로 선언되어야한다</span></span><br><span class="line"><span class="comment">DFS 진행시 반드시 ArrayList나 LinkedList에 대한 값을 초기화 시켜주어야한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 인접행렬 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] A;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        n = Integer.parseInt(st.nextToken());</span><br><span class="line">        m = Integer.parseInt(st.nextToken());</span><br><span class="line">        start = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        A = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">            A[x][y] = <span class="number">1</span>;</span><br><span class="line">            A[y][x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//인접행렬시에는 정렬이 필요 없다!! 인접리스트만 필요하다.</span></span><br><span class="line">        <span class="comment">//자식이 여러개라면 노드 번호가 작은 것 먼저 방문하므로 오름차순으로 정렬</span></span><br><span class="line">        dfs(start);</span><br><span class="line">        Arrays.fill(check,<span class="keyword">false</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        bfs(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        check[x] = <span class="keyword">true</span>;</span><br><span class="line">        System.out.print(x + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 인접 행렬</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!check[i] &amp;&amp; A[x][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        check[v] = <span class="keyword">true</span>;</span><br><span class="line">        q.offer(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 인접 행렬</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.poll();</span><br><span class="line">            System.out.print(x + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!check[i] &amp;&amp; A[x][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                    check[i] =<span class="keyword">true</span>;</span><br><span class="line">                    q.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>인접리스트<br>인접리스트를 이용한 풀이입니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Queue는 LinkedList 로 선언되어야한다</span></span><br><span class="line"><span class="comment">DFS 진행시 반드시 ArrayList나 LinkedList에 대한 값을 초기화 시켜주어야한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFSBFS_LIST1260</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; A = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        n = Integer.parseInt(st.nextToken());</span><br><span class="line">        m = Integer.parseInt(st.nextToken());</span><br><span class="line">        start = Integer.parseInt(st.nextToken());</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            A.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">            A.get(x).add(y);</span><br><span class="line">            A.get(y).add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//자식이 여러개라면 노드 번호가 작은 것 먼저 방문하므로 오름차순으로 정렬을 해줬다.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            Collections.sort(A.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(start);</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        System.out.println();</span><br><span class="line">        bfs(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        check[x] = <span class="keyword">true</span>;</span><br><span class="line">        System.out.print(x + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 인접 리스트</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.get(x).size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = A.get(x).get(i);</span><br><span class="line">            <span class="keyword">if</span>(!check[y])&#123;</span><br><span class="line">                dfs(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        check[v] = <span class="keyword">true</span>;</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="comment">// 2. 인접리스트</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.poll();</span><br><span class="line">            System.out.print(x + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.get(x).size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = A.get(x).get(i);</span><br><span class="line">                <span class="keyword">if</span>(!check[y])&#123;</span><br><span class="line">                    check[y] = <span class="keyword">true</span>;</span><br><span class="line">                    q.offer(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;geuraepeu&quot;&gt;&lt;a href=&quot;#geuraepeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#그래프&quot;&gt;&lt;/a&gt; 그래프&lt;/h1&gt;
&lt;p&gt;그래프의 정의를 살펴보면
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://gwanhyeon.github.io/categories/algorithm/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>백준 연결요소의 개수 11724</title>
    <link href="http://gwanhyeon.github.io/connected-component/"/>
    <id>http://gwanhyeon.github.io/connected-component/</id>
    <published>2020-10-21T12:48:55.000Z</published>
    <updated>2020-10-22T05:54:03.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="baegjun-yeongyeolyosoyi-gaesu-11724-munje"><a href="#baegjun-yeongyeolyosoyi-gaesu-11724-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-연결요소의-개수-11724-문제"></a> <a href="https://www.acmicpc.net/problem/11724" target="_blank" rel="noopener">백준 연결요소의 개수 11724 문제</a></h2><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 연결 요소의 개수를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>6 5<br>1 2<br>2 5<br>5 1<br>3 4<br>4 6</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>2</p><h3 id="yeje-ibryeog-2"><a href="#yeje-ibryeog-2" class="header-anchor">1.6. </a><a class="markdownIt-Anchor" href="#예제-입력-2"></a> 예제 입력 2</h3><p>6 8<br>1 2<br>2 5<br>5 1<br>3 4<br>4 6<br>5 4<br>2 4<br>2 3</p><h3 id="yeje-culryeog-2"><a href="#yeje-culryeog-2" class="header-anchor">1.7. </a><a class="markdownIt-Anchor" href="#예제-출력-2"></a> 예제 출력 2</h3><h2 id="1"><a href="#1" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#1"></a> 1</h2><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li><code>그래프 상</code>에서 <code>연결요소의 개수</code>를 구하는 문제입니다. 여기서 가장 중요한점은 <code>각각의 그래프를 연결 요소</code>라고 하는데 <code>나누어진 그래프의 개수를 찾는 문제</code>입니다.</li></ul><p><code>연결요소의 개수</code>를 찾기전에 <code>그래프 개념</code>에 대해서 살펴보고 넘어가겠습니다.<br><a href="https://gwanhyeon.github.io/graph-summary/">그래프 인접행렬, 인접리스트 및 DFS,BFS</a> 해당 포스트에서 <code>인접행렬, 인접리스트와 DFS,BFS의 개념</code>에 대해서 <code>상세히 설명</code>해놓았습니다. 이부분을 참고하시면 어렵지 않게 문제를 푸실 수 있을것 입니다.</p><blockquote><p>문제를 풀기위해서는 필요한 지식은 다음과 같습니다.</p></blockquote><ul><li><code>인접행렬과 인접리스트</code>의 차이를 알 수 있어야합니다.</li><li><code>DFS와 BFS의 차이점</code>을 알고 있어야합니다.</li><li><code>가장 적은 정점부터 방문해야한다는 조건이 있을때는Sort</code>를 진행해야합니다.</li><li><code>DFS, BFS 백준 1260번</code> 문제와 유사하므로 이것이 잘 이해가 가지않으신다면 먼저 풀어보시는것을 권장드립니다.</li><li><code>직접 손으로 그래프</code>를 그리면서 하나하나씩 <code>과정</code>이 어떻게 이루어지는지 알고 계셔야합니다.</li></ul><p>간략히 풀이한 것에 말씀드려보면 <code>(1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2)</code>이라는 조건이 있으므로 각각의 <code>ArrayList&lt;ArrayList&lt;Integer&gt;&gt;</code> 형식의 리스트에 값을 할당하였습니다. 또한, 내가 체크한 부분인지 아닌지를 확인하기 위한 <code>check변수</code>를 선언하여 문제를 해결 하였습니다.<br>결국, <code>check된 부분이 false인 경우</code>에 카운트 값을 하나씩 올려주면서 재귀호출을 하게 된다면 결국엔 <code>그 정점(V)에 포함된 간선(E)의 연결요소의 개수</code>를 알 수 있겠죠?</p><blockquote><p>시간복잡도</p></blockquote><p>시간복잡도는 현재 <code>(1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2)</code> 의 조건을 가지고 있습니다.<br><code>N은 최대 1000</code>까지의 수를 가질 수 있으며, M 같은경우는 <code>(1000*(999-1)/2)</code> 까지의 값을 가집니다.<br>약 <code>500,000 정확히 말해서 499,500까지의 값</code>을 가질 수 있다는 말인데요.</p><p>N의 시간복잡도에 대해서는 <code>O(N^2)까지의 수</code>를 계산 하였을때, <code>1000 * 1000 =&gt; 1,000,000 백만</code>까지 나오게 됩니다. <code>M같은경우</code>는 <code>O(M^2) 약 500,000</code> 이기때문에 <code>O(M^2)</code>을 하게 되면 <code>500,000 * 500,000 =&gt; 250,000,000,000 = 2500억정도</code>의 <code>시간복잡도가 계산</code> 될 수 있기때문에 주의하여야합니다. 시간복잡도는 약 1초에 1억번 컴퓨터가 수행 할 수 있는 시간을 말하는데요.  <code>2500억</code>정도가 나오게된다면 컴퓨터 시간복잡도를 수행하는데 있어서 <code>2500초 정도</code>가 걸린다고 생각하시면 됩니다. 이러한 <code>시간복잡도 또한 무시할 수 없는 알고리즘</code>의 하나이기 때문에 <code>주의를 귀울이셔야 할 것 같습니다.</code></p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BFS DFS두가지 방법으로 사용하기</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 연결요소11724 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] connCheck;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; A = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        n = Integer.parseInt(st.nextToken());</span><br><span class="line">        m = Integer.parseInt(st.nextToken());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            A.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(st.nextToken());</span><br><span class="line">            A.get(x).add(y);</span><br><span class="line">            A.get(y).add(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!check[i])&#123;</span><br><span class="line">                <span class="comment">//dfs(i);</span></span><br><span class="line">                bfs(i);</span><br><span class="line">                answer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(v);</span><br><span class="line">        check[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.get(x).size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = A.get(x).get(i);</span><br><span class="line">                <span class="keyword">if</span>(!check[y])&#123;</span><br><span class="line">                    check[y] = <span class="keyword">true</span>;</span><br><span class="line">                    q.offer(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        check[x] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.get(x).size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = A.get(x).get(i);</span><br><span class="line">            <span class="keyword">if</span>(!check[y])&#123;</span><br><span class="line">                check[y] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;baegjun-yeongyeolyosoyi-gaesu-11724-munje&quot;&gt;&lt;a href=&quot;#baegjun-yeongyeolyosoyi-gaesu-11724-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a clas
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="그래프" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"/>
    
      <category term="BFS" scheme="http://gwanhyeon.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>백준 부등호 2529</title>
    <link href="http://gwanhyeon.github.io/inequality-sign/"/>
    <id>http://gwanhyeon.github.io/inequality-sign/</id>
    <published>2020-10-20T09:38:18.000Z</published>
    <updated>2020-10-20T09:52:09.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="baegjun-budeungho-2529-munje"><a href="#baegjun-budeungho-2529-munje" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#백준-부등호-2529-문제"></a> <a href="https://www.acmicpc.net/problem/2529" target="_blank" rel="noopener">백준 부등호 2529 문제</a></h2><h3 id="munje"><a href="#munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>두 종류의 부등호 기호 ‘&lt;’와 ‘&gt;’가 k개 나열된 순서열  A가 있다. 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다. 예를 들어, 제시된 부등호 순서열 A가 다음과 같다고 하자.</p><p><code>A =&gt; &lt; &lt; &lt; &gt; &lt; &lt; &gt; &lt; &gt;</code></p><p>부등호 기호 앞뒤에 넣을 수 있는 숫자는 0부터 9까지의 정수이며 선택된 숫자는 모두 달라야 한다. 아래는 부등호 순서열 A를 만족시키는 한 예이다.</p><p><code>3 &lt; 4 &lt; 5 &lt; 6 &gt; 1 &lt; 2 &lt; 8 &gt; 7 &lt; 9 &gt; 0</code></p><p>이 상황에서 부등호 기호를 제거한 뒤, 숫자를 모두 붙이면 하나의 수를 만들 수 있는데 이 수를 주어진 부등호 관계를 만족시키는 정수라고 한다. 그런데 주어진 부등호 관계를 만족하는 정수는 하나 이상 존재한다. 예를 들어 3456128790 뿐만 아니라 5689023174도 아래와 같이 부등호 관계 A를 만족시킨다.</p><p><code>5 &lt; 6 &lt; 8 &lt; 9 &gt; 0 &lt; 2 &lt; 3 &gt; 1 &lt; 7 &gt; 4</code></p><p>여러분은 제시된 k개의 부등호 순서를 만족하는 (k+1)자리의 정수 중에서 최댓값과 최솟값을 찾아야 한다. 앞서 설명한 대로 각 부등호의 앞뒤에 들어가는 숫자는 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }중에서 선택해야 하며 선택된 숫자는 모두 달라야 한다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫 줄에 부등호 문자의 개수를 나타내는 정수 k가 주어진다. 그 다음 줄에는 k개의 부등호 기호가 하나의 공백을 두고 한 줄에 모두 제시된다. k의 범위는 2 ≤ k ≤ 9 이다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다. 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다. 모든 입력에 답은 항상 존재하며 출력 정수는 하나의 문자열이 되도록 해야 한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>2<br>&lt; &gt;</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>897<br>021</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>부등호의 개수가 주어지고 0~9까지의 값들을 가지고 해당 부등호 조건들이 만족하는 값들을 찾아 최댓값, 최솟값을 찾는 문제입니다.</li><li>선택된 숫자는 <code>모두 달라야하기때문에</code> 값들을 <code>체킹하는 변수</code>가 필요해 보입니다. 그렇기 때문에 <code>순열</code>을 사용하면 되겠다 라는 생각을 하게 되었습니다.</li><li>K개의 부등호의 개수는 0~9까지의 값중 K+1개를 선택할 수 있는것과 같은 의미입니다.</li></ul><p>입력으로 주어진 부등호 <code>&gt;, &lt;</code>에 따라 값 a,b가 만족하는지 찾는 함수가 필요합니다. 그리고 idx값이 0일때나 부등호가 성립하는경우에만 브루트포스를 사용하여 값을 순회합니다.<code>idx값이 0일때 브루트포스를 순회하는 이유</code>는 맨처음 문자열값이 <code>&quot;&quot;으로 호출을 진행하기 때문에 이것에 대한 예외처리</code>를 해준 것입니다.</p><blockquote><p>문자열 완전탐색 문제는 어떻게 풀까?</p></blockquote><ul><li>문제마다 다를 수 있겠지만 보통 <code>브루트포스 문자열관련 문제가 나오게 되면 DFS호출시 문자열을 더하고 빼주는 형식</code>으로 진행하는 것이 깔끔하고 구현이 더 쉽다고 생각합니다. 맨 처음에 문자열을 더하고 빼주는 형식으로 진행하지 않고 <code>Basement조건이 만족했을때(return 조건)</code> 처리를 하게 되면 복잡함을 느낄 수 있었습니다.</li></ul><blockquote><p>Basement 만족시<br>K+1개를 선택하여 DFS를 통해 모든 조건을 구하였던 문자열 값을 answer에 모든 값을 담아주게 하였습니다.</p></blockquote><blockquote><p>최댓값, 최솟값<br>문제에서 최댓값, 최솟값을 찾는 문제이므로 <code>Collections.sort()</code>함수를 사용하여 <code>맨 앞(index=0), 맨뒤(answer.size()-1)</code>의 값을 출력시켜주면 값을 도출해날 수 있습니다.</p></blockquote><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 부등호문제 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;String&gt; answer;</span><br><span class="line">    <span class="keyword">static</span> String inequality_sign = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> k = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(),<span class="string">" "</span>);</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">        answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            inequality_sign += st.nextToken();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">""</span>, <span class="number">0</span>, k);</span><br><span class="line">        Collections.sort(answer);</span><br><span class="line"></span><br><span class="line">        System.out.println(answer.get(answer.size()-<span class="number">1</span>) + <span class="string">"\n"</span> + answer.get(<span class="number">0</span>) + <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// basement</span></span><br><span class="line">        <span class="keyword">if</span>(idx == k+<span class="number">1</span>)&#123;</span><br><span class="line">            answer.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(idx == <span class="number">0</span> || inequality_check(s.charAt(idx-<span class="number">1</span>), (i+<span class="string">'0'</span>), inequality_sign.charAt(idx-<span class="number">1</span>)))&#123;</span><br><span class="line">                check[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(s+String.valueOf(i), idx+<span class="number">1</span>, k);</span><br><span class="line">                check[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 부등호 체크 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inequality_check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">char</span> cal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cal == <span class="string">'&lt;'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cal == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;baegjun-budeungho-2529-munje&quot;&gt;&lt;a href=&quot;#baegjun-budeungho-2529-munje&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="브루트포스" scheme="http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"/>
    
      <category term="위상정렬" scheme="http://gwanhyeon.github.io/tags/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC/"/>
    
  </entry>
  
  <entry>
    <title>백준 수 이어쓰기1 1748</title>
    <link href="http://gwanhyeon.github.io/number-inheritance1/"/>
    <id>http://gwanhyeon.github.io/number-inheritance1/</id>
    <published>2020-10-19T16:07:15.000Z</published>
    <updated>2020-10-19T16:35:45.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><h2 id="baegjun-su-ieosseugi1-1748-munje"><a href="#baegjun-su-ieosseugi1-1748-munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#백준-수-이어쓰기1-1748-문제"></a> <a href="https://www.acmicpc.net/problem/1748" target="_blank" rel="noopener">백준 수 이어쓰기1 1748 문제</a></h2><h3 id="munje"><a href="#munje" class="header-anchor">1.1.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.</p><p>1234567891011121314151617181920212223…</p><p>이렇게 만들어진 새로운 수는 몇 자리 수일까? 이 수의 자릿수를 구하는 프로그램을 작성하시오.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">1.1.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 N(1≤N≤100,000,000)이 주어진다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">1.1.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 새로운 수의 자릿수를 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">1.1.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>120</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">1.1.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>252</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">1.2. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>1~N까지의 값을 수를 이어서 쓰면 하나의 수를 얻을때 몇자리수인지를 구하는문제입니다.<br>알고리즘 사고를 말하기 앞서, String VS StringBuilder, StringBuffer의 차이를 확인하고 지나가겠습니다.</li></ul><blockquote><p>String VS StringBuilder, StringBuffer<br><code>String 클래스 불변 객체</code>이기 때문에 <code>문자열 연산에서 객체를 계속 생성</code>하므로 성능이 떨어지지만 <code>조회와 멀티스레드 환경</code>에서 <code>큰 이점</code>을 가지고 있습니다.</p></blockquote><p>이에 반해,StringBuffer 클래스와 StringBuilder 클래스는 문자열 연산이 자주 발생할 때 문자열이 변경가능한 객체이므로 이점을 가지고 있습니다.</p><p>즉, <code>StringBuffer와 StringBuilder 차이점은 동기화 지원 유무</code>이고 <code>동기화를 고려하지 않는 환경에서 StringBuilder가 성능이 더 좋고</code>, <code>동기화 멀티스레드 환경</code>에서는 <code>StringBuffer</code>을 사용하는것이 좋습니다.</p><blockquote><p>모든 경우로 가능할까? 브루트 포스?<br>N의 범위를 살펴보면 <code>N(1≤N≤100,000,000)</code> 의 조건을 가지고 있습니다. 1초에 1억까지 연산이 가능하므로 1초안에 처리 될 수 있어야합니다.</p></blockquote><p>즉, <code>모든 경우의 수를 O(N)만큼 진행</code>하면 <code>브루트포스로 진행</code>이 가능하지만, <code>문자열 연산</code>에서 <code>시간복잡도</code>는 <code>O(N) * 10</code>까지 진행될 수 있습니다. 그 이유는 <code>10은 수의 최대 자릿수</code>를 의미하기 때문에 <code>N의 시간복잡도</code>를 넘어버리게 됩니다. <code>문자열 String</code>은 <code>새로운 객체</code>를 계속해서 생성하기때문에 압도적으로 <code>시간복잡도가 증가</code>하는 경우가 될 수 있습니다.</p><p>따라서, 일반적인 브루트포스방법으로는 <code>모든 N까지를 진행하게 되면 시간초과</code>가 나게 됩니다. 그렇기 때문에 <code>다른 방법</code>을 <code>고안</code>할 수 있어야합니다.</p><blockquote><p>다른 방법은 무엇일까?<br>수학적 연산의 방법을 살펴보면 수의 <code>자리수별로 나누어서 문제를 해결</code> 할 수 있습니다.<br>만약 <code>N = 120</code>이라고 생각하면</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>~<span class="number">9</span> 길이 <span class="number">1</span></span><br><span class="line">(<span class="number">9</span>-<span class="number">1</span>+<span class="number">1</span>) * <span class="number">1</span> </span><br><span class="line"><span class="number">10</span>~<span class="number">99</span> 길이 <span class="number">2</span></span><br><span class="line">(<span class="number">99</span>-<span class="number">10</span>+<span class="number">1</span>) * <span class="number">2</span></span><br><span class="line"><span class="number">100</span>~<span class="number">120</span> 길이 <span class="number">3</span></span><br><span class="line">(<span class="number">120</span>-<span class="number">100</span>+<span class="number">1</span>) * <span class="number">3</span></span><br></pre></td></tr></table></figure><p>의 규칙을 찾아낼 수 있습니다. 수의 각 자리별로 나누어서 자리수를 문제를 해결 할 수 있습니다.</p><p><code>결과적으로, (N의자리 최대값 - N자리 최솟값 + 1) * 자리수(N자리수 길이)</code> 으로 자리수를 구할 수 있게됩니다.</p><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">1.3. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">자리수 찾기문제</span></span><br><span class="line"><span class="comment">1234567891011 와같이 수를 이어붙이면 브루트포스로 처리하면 O(N) * 10(자리수)의 시간복잡도가 발생하므로 시간초과가 발생합니다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 수이어쓰기1 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i*<span class="number">10</span>-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; n)&#123;</span><br><span class="line">                j = n;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (<span class="keyword">long</span>)(j - i + <span class="number">1</span>) * len;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="연산" scheme="http://gwanhyeon.github.io/tags/%EC%97%B0%EC%82%B0/"/>
    
  </entry>
  
  <entry>
    <title>백준 체스판 다시칠하기 1018</title>
    <link href="http://gwanhyeon.github.io/chess-repaint/"/>
    <id>http://gwanhyeon.github.io/chess-repaint/</id>
    <published>2020-10-19T05:20:34.000Z</published>
    <updated>2020-10-19T08:17:27.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><h2 id="baegjun-ceseupan-dasicilhagi-1018-munje"><a href="#baegjun-ceseupan-dasicilhagi-1018-munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#백준-체스판-다시칠하기-1018-문제"></a> <a href="https://www.acmicpc.net/problem/1018" target="_blank" rel="noopener">백준 체스판 다시칠하기 1018 문제</a></h2><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><h3 id="munje"><a href="#munje" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M<em>N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8</em>8 크기의 체스판으로 만들려고 한다.</p><p>체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.</p><p>보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8<em>8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8</em>8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">2.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">2.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>8 8<br>WBWBWBWB<br>BWBWBWBW<br>WBWBWBWB<br>BWBBBWBW<br>WBWBWBWB<br>BWBWBWBW<br>WBWBWBWB<br>BWBWBWBW</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">2.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>1</p><h3 id="yeje-ibryeog-2"><a href="#yeje-ibryeog-2" class="header-anchor">2.6. </a><a class="markdownIt-Anchor" href="#예제-입력-2"></a> 예제 입력 2</h3><p>10 13<br>BBBBBBBBWBWBW<br>BBBBBBBBBWBWB<br>BBBBBBBBWBWBW<br>BBBBBBBBBWBWB<br>BBBBBBBBWBWBW<br>BBBBBBBBBWBWB<br>BBBBBBBBWBWBW<br>BBBBBBBBBWBWB<br>WWWWWWWWWWBWB<br>WWWWWWWWWWBWB</p><h3 id="yeje-culryeog-2"><a href="#yeje-culryeog-2" class="header-anchor">2.7. </a><a class="markdownIt-Anchor" href="#예제-출력-2"></a> 예제 출력 2</h3><p>12</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>입력으로 주어진 체스판을 8*8의 크기의 체스판으로 다시 칠하는 경우를 모두 찾는 브루트포스 문제입니다.</li><li>체스판이 White로 시작하는 경우와 Black으로 시작하는 경우 두가지를 나누어서 생각할 수 있어야합니다.</li><li><code>BufferedReader</code>를 사용하여 입력을 처리하였고 <code>StringTokenizer</code>를 사용하여 각각의 입력을 처리하였습니다.</li><li><code>'B' 블랙의 경우 1, 'W' 흰색의 경우 0</code>으로 변경하여 진행하였습니다.</li></ul><blockquote><p>모든 Board를 어떤식으로 순회할 수 있을까요?<br>테스트케이스로 주어진 n = 10, m = 13을 예를 들어서 설명하겠습니다.<br>행같은 경우는 최대 3번, 열은 최대 6번까지 진행이 가능합니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n-<span class="number">8</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m-<span class="number">8</span>; j++)&#123;</span><br><span class="line">      <span class="comment">// first : black,first : white</span></span><br><span class="line">      separate(i,j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 코드가 최대 행,열이 최대 진행가능한 경우를 나타낼 수 있습니다.</p><blockquote><p>그래도 이해가 잘 가지 않으신다면?<br>이해가 잘 가지 않으시면 직접 그림을 그리셔서 주어진 <code>10*13의 체스판위</code>에 <code>8*8의 체스판</code>을 최대 어떻게 이동할 수 있을지 생각해보시면 됩니다.</p></blockquote><blockquote><p>규칙<br>이제 규칙을 찾아내야합니다.</p></blockquote><p>첫번째로 <code>WB, BW</code> 으로 시작하는 두가지경우로 나타낼 수 있습니다. 그리고 (행+열)의 값이 홀수, 짝수에 따라 체스판이 이루어진다는것을 알 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WBWBWBWB</span><br><span class="line">BWBWBWBW</span><br><span class="line">WBWBWBWB</span><br><span class="line">BWBBBWBW</span><br><span class="line">WBWBWBWB</span><br><span class="line">BWBWBWBW</span><br><span class="line">WBWBWBWB</span><br><span class="line">BWBWBWBW</span><br></pre></td></tr></table></figure><p>즉, <code>(행+열)을 더한값이 짝수, 홀수</code>에 따라 체스판의 규칙을 띄는것을 확인할 수 있습니다.<br>짝수일 경우 흰색, 홀수일 경우 검은색이라고 생각하시면 됩니다.<br>흰색이면 검은색으로 값을 증가 시켜주어야하고 , 검은색이라면 흰색으로 값을 증가시켜줍니다. 검은색으로 바꿔야하는 개수와 흰색으로 바꿔야하는 개수중 최소의 값을 찾아주어 <code>최솟값</code>을 처리해주면 됩니다.</p><blockquote><p>실수한 점<br>처음에 WB,BW 두가지 경우를 나누는 것을 생각해보지 않고 한가지의 경우만 생각해서 테스트 케이스는 모두 맞았지만 다른 케이스에서 틀렸습니다가 나오게 되었습니다.</p></blockquote><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 체스판다시칠하기 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> map[][];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> min = <span class="number">80</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(st.nextToken());</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(st.nextToken());</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line">            String val = st.nextToken();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="comment">// black - 0</span></span><br><span class="line">                <span class="keyword">if</span>(val.charAt(j) == <span class="string">'B'</span>)&#123;</span><br><span class="line">                   map[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// white - 1</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    map[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n-<span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m-<span class="number">8</span>; j++)&#123;</span><br><span class="line">                <span class="comment">// first : black,first : white</span></span><br><span class="line">                separate(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separate</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cntBlack = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cntWhite = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;start+<span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = end; j &lt; end+<span class="number">8</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 짝수: white</span></span><br><span class="line">                <span class="keyword">if</span>((i+j) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        cntWhite++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cntBlack++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 홀수: black</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        cntBlack++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cntWhite++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min = min &lt; cntBlack ? min : cntBlack;</span><br><span class="line">        min = min &lt; cntWhite ? min : cntWhite;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="브루트포스" scheme="http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>백준 덩치 7568</title>
    <link href="http://gwanhyeon.github.io/big-body/"/>
    <id>http://gwanhyeon.github.io/big-body/</id>
    <published>2020-10-15T15:03:03.000Z</published>
    <updated>2020-10-15T15:12:47.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><h2 id="baegjun-deongci-munje"><a href="#baegjun-deongci-munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#백준-덩치-문제"></a> <a href="https://www.acmicpc.net/problem/7568" target="_blank" rel="noopener">백준 덩치 문제</a></h2><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><h3 id="munje"><a href="#munje" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x,y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x,y), (p,q)라고 할 때 x&gt;p 그리고 y&gt;q 이라면 우리는 A의 덩치가 B의 덩치보다 &quot;더 크다&quot;고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56,177), (45,165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55,173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, &quot;덩치&quot;로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.</p><p>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 &quot;큰 덩치&quot;의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.</p><p>이름    &lt;몸무게, 키&gt;    덩치 등수<br>A    &lt;55, 185&gt;    2<br>B    &lt;58, 183&gt;    2<br>C    &lt;88, 186&gt;    1<br>D    &lt;60, 175&gt;    2<br>E    &lt;46, 155&gt;    5<br>위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다. 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다. 단, 2 ≤ N ≤ 50, 10 ≤ x,y ≤ 200 이다.</p><h3 id="culryeog"><a href="#culryeog" class="header-anchor">2.3. </a><a class="markdownIt-Anchor" href="#출력"></a> 출력</h3><p>여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.</p><h3 id="yeje-ibryeog-1"><a href="#yeje-ibryeog-1" class="header-anchor">2.4. </a><a class="markdownIt-Anchor" href="#예제-입력-1"></a> 예제 입력 1</h3><p>5<br>55 185<br>58 183<br>88 186<br>60 175<br>46 155</p><h3 id="yeje-culryeog-1"><a href="#yeje-culryeog-1" class="header-anchor">2.5. </a><a class="markdownIt-Anchor" href="#예제-출력-1"></a> 예제 출력 1</h3><p>2 2 1 2 5</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>사람들의 덩치의 등수를 매길때 조건인 (x,y), (p,q)라고 할때 x&gt;p, y&gt;q이라면 A의 덩치가 B의 덩치보다 <code>더크다</code> 라는게 가장 중요한 조건이였습니다. 이 문제는 개인적으로 브루트포스 + 조합이라고 생각합니다.</li><li>각각의 몸무게와 키를 저장시킬 배열을 하나선언하여 주었습니다.</li><li>그리고 check변수를 두개 선언해주었습니다. 두개를 선언해주는 이유는 첫번째 사람이 나머지사람들의 모든 덩치비교, 두번째 사람이 모든 덩치비교 … 이런식으로 모든사람의 덩치를 비교해야합니다. 따라서, 각각의 사람에 따라 덩치큰사람의 개수를 찾아주어야합니다. 그렇기 때문에 타겟이 되는 사람을 체크해줄 변수와 타겟변수와 비교되는 사람들을 체크해줄 변수를 선언해주었습니다.</li><li>각각 타겟이 되는 사람을 순회해주어야하므로 n까지의 모든 경우사람을 DFS돌려주었습니다.</li></ul><blockquote><p>몸무게, 키 비교의 경우</p></blockquote><p>첫번째 사람일 경우 그 나머지사람 모두와 비교, 두번째 사람일 경우 그 나머지 사람들과 모두 …(계속) 비교의 형식으로 진행하였습니다.</p><p>만약 첫번째 사람의 경우는 2~N까지의 사람을 모두 비교해주어야하므로</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(idx == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; a &amp;&amp; d &gt; b)&#123;</span><br><span class="line">        cnt +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>선택된 사람이 한명이고, <code>c &gt; a &amp;&amp; d &gt; b</code> 의 조건을 만족하면 cnt++를 해주었습니다. 그리고나서 모든 DFS의 경우를 빠져나오게 되면 cnt값을 1로 초기화 시켜주었습니다. 문제에서 보면 <code>큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.</code> 라는 조건이 있기때문에 1로 초기화시켜주었습니다. 값을 도출하였을때 -1씩 줄어든 값이 출력되어서 문제를 다시 읽어보니 조건을 찾았습니다.<br>그리고 나서 나머지 사람들을 선택할때는 조합의 경우를 찾아주면서 값을 비교해주었습니다.</p><hr><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 덩치7568 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] value_check;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] weight;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] stature;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; answer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st;</span><br><span class="line">        weight= <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        stature = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        value_check = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            st = <span class="keyword">new</span> StringTokenizer(br.readLine(),<span class="string">" "</span>);</span><br><span class="line">            weight[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">            stature[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            check[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(weight[i],stature[i],<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, n);</span><br><span class="line">            answer.add(cnt);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            check[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;answer.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == answer.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print(answer.get(i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(answer.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> idx, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt; a &amp;&amp; d &gt; b)&#123;</span><br><span class="line">                cnt +=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=idx; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value_check[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            value_check[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(a,b,weight[i],stature[i], idx+<span class="number">1</span> ,n);</span><br><span class="line">            value_check[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="브루트포스" scheme="http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>백준 분해합 2231</title>
    <link href="http://gwanhyeon.github.io/decomposition-sum/"/>
    <id>http://gwanhyeon.github.io/decomposition-sum/</id>
    <published>2020-10-15T13:53:20.000Z</published>
    <updated>2020-10-15T14:04:16.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><h2 id="baegjun-bunhaehab-munje"><a href="#baegjun-bunhaehab-munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#백준-분해합-문제"></a> <a href="https://www.acmicpc.net/problem/2231" target="_blank" rel="noopener">백준 분해합 문제</a></h2><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><h3 id="munje"><a href="#munje" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#문제"></a> 문제</h3><p>어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.</p><p>자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.</p><h3 id="ibryeog"><a href="#ibryeog" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#입력"></a> 입력</h3><p>첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>분해합을 구하기 위해서는 <code>M은 N의 생성자이여야한다.</code> 가 가장 중요한 조건이였습니다.<br>예를 들어보겠습니다.<br>N이 216일 경우 (216+2+1+6) =&gt; 198이 됩니다.<br>즉,198은 225의 분해합입니다.</li></ul><blockquote><p>분해합의 원리<br>각 자리의 수 + 분해합 M의 값 = N이 되는 경우를 찾아주면 되는 문제였습니다.<br>브루트포스를 사용하여 모든경우 i=1~100000까지의 값을 순회하면서 N의 값과 같은 경우를 찾아주었습니다. 정수값을 문자열로 변경하여 각 자리의 값의 합을 저장시킨후 <code>(i의 값 + 각 자리 값의 합)</code> 이 같을 경우 값을 찾아주었습니다.</p></blockquote><blockquote><p>회고<br>처음에 문제의 뜻을 제대로 파악못하였는데 직접 써보면서 하나씩 대입해보니까 쉽게 풀 수 있었던 문제였습니다. 약 40분정도 소요되었던 문제였습니다.</p></blockquote><p>문제에서 주어진 각 분해합의 개념을 잘 파악하고 브루트포스로 값을 찾아주면 쉽게 도출 할 수 있습니다. N의 값과 같은 생성자를 모두 answer 변수에 넣어준 후 <code>Collections.min()</code> 함수를 사용하여 최솟값을 찾아주었습니다.</p><hr><h2 id="soseukodeu"><a href="#soseukodeu" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#소스코드"></a> 소스코드</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 분해합 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            String str = Integer.toString(i);</span><br><span class="line">            <span class="keyword">int</span> str_value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;str.length(); j++) &#123;</span><br><span class="line">                str_value += Integer.parseInt(String.valueOf(str.charAt(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(n,i,i+str_value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(answer.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            min = Collections.min(answer);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> value, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sum == n의 값과 같을 경우 즉, 생성자일 경우</span></span><br><span class="line">        <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">            answer.add(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="브루트포스" scheme="http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 도둑질</title>
    <link href="http://gwanhyeon.github.io/house-steal/"/>
    <id>http://gwanhyeon.github.io/house-steal/</id>
    <published>2020-10-13T13:19:00.000Z</published>
    <updated>2020-10-13T13:31:32.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><h2 id="peurogeuraemeoseu-dodugjil-munje"><a href="#peurogeuraemeoseu-dodugjil-munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#프로그래머스-도둑질-문제"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42897?language=java" target="_blank" rel="noopener">프로그래머스 도둑질 문제</a></h2><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><h3 id="munje-seolmyeong"><a href="#munje-seolmyeong" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#문제-설명"></a> 문제 설명</h3><p>도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.</p><p>각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.</p><p>각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.</p><h3 id="jehansahang"><a href="#jehansahang" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#제한사항"></a> 제한사항</h3><p>이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.<br>money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><p>훔친 비용의 값을 점진적으로 사용하기때문에 DP로 풀면 되겠다 라는 생각을 하게 되었습니다.</p><ul><li>첫번째집을 훔치는 경우 VS 첫번째집을 훔치지 않는 경우<br>훔치는 경우의 수에 따라서 DP를 나누어서 값을 계산하였습니다.</li></ul><blockquote><p>첫번째 집을 훔치는 경우</p></blockquote><p>첫번째집을 훔쳤을 경우에는 <code>dp[0] = 첫번째집의 비용</code>을 저장시켜줍니다.<br>첫번째집을 훔쳤을때에는 인접한 두번째집은 훔칠수 없습니다. 따라서 첫번째집을 훔치는경우는 두번째집을 선택할수없기때문에 두번째집도 지금까지 가장 큰 첫번째집 돈을 넣어줍니다. <code>dp[1] = 첫번째 집의 비용</code></p><p>여기서 length의 범위를 -1을 해주게 되는데 첫번째집을 선택하게 될 경우 마지막에 있는 집은 방문을 하지않는것이 확실하기때문에 -1로 마지막 길이 이전까지만 순회시켜주었습니다.</p><blockquote><p>첫번째 집을 훔치지 않는 경우<br>첫번째 집을 훔치지 않는 경우는 첫번째집은 0의 값을 넣어주게 됩니다.<br><code>dp1[0] = 훔치지 않으므로 0</code><br>두번째 집은 기존의 money[1]의 값을 넣어주게 되면서 이제 모든 비용을 구해주면됩니다.</p></blockquote><p>이제 모든 비용을 구하기 위해서는 값을 누적해서 더해주면서 가장 큰 값으로 업데이트를 시켜줍니다. 즉, <code>최댓값</code>을 구하기 위해서 <code>Math.max()</code> 함수를 사용하였습니다.</p><p>결, <code>dp[길이-2], dp1[길이-1]</code>에 집을 훔쳤을때, 훔치지 않았을때의 최대값이 저장되어 있을 것입니다. 그래서 dp의 비용과 dp1의 최댓값을 다시 구해주어 값을 리턴해주면 원하는 값을 찾을 수 있습니다.</p><blockquote><p>이 문제의 핵심은 인접했을때의 경우의 수와 첫번째 집을 훔친 경우와 훔치지 않는 경우를 찾아내는것이 중요합니다.</p></blockquote><hr><h2 id="puli"><a href="#puli" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 도둑질 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] money = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[money.length];</span><br><span class="line">        <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[money.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//첫번째 집을 훔치는 경우</span></span><br><span class="line">        dp[<span class="number">0</span>] = money[<span class="number">0</span>]; <span class="comment">// 첫번째집의 돈 훔치기</span></span><br><span class="line">        dp[<span class="number">1</span>] = money[<span class="number">0</span>]; <span class="comment">// 첫번째집을 훔치는경우는 두번째집을 선택할수없기때문에 두번째집도 지금까지 가장 큰 첫번째집 돈을 넣어준다.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//첫번째 집을 훔치지 않는 경우</span></span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">0</span>;     <span class="comment">//첫번째집 훔치지않으므로 0</span></span><br><span class="line">        dp1[<span class="number">1</span>] = money[<span class="number">1</span>]; <span class="comment">//두번째집은 훔치는 가격</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;money.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">2</span>] + money[i], dp[i-<span class="number">1</span>]);      <span class="comment">// 1번째 세번째 훔치는 경우</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;money.length; i++)&#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i-<span class="number">2</span>] + money[i], dp1[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Math.max(dp[money.length-<span class="number">2</span>], dp1[money.length-<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="프로그래머스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="dp" scheme="http://gwanhyeon.github.io/tags/dp/"/>
    
      <category term="다이나믹프로그래밍" scheme="http://gwanhyeon.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 큰 수 만들기</title>
    <link href="http://gwanhyeon.github.io/bignumber/"/>
    <id>http://gwanhyeon.github.io/bignumber/</id>
    <published>2020-10-09T08:49:42.000Z</published>
    <updated>2020-10-09T08:57:49.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><h2 id="peurogeuraemeoseu-keunsumandeulgi"><a href="#peurogeuraemeoseu-keunsumandeulgi" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#프로그래머스-큰수만들기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42883" target="_blank" rel="noopener">프로그래머스 큰수만들기</a></h2><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><h3 id="munje-seolmyeong"><a href="#munje-seolmyeong" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#문제-설명"></a> 문제 설명</h3><p>어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.</p><p>예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.</p><p>문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.</p><h3 id="jehan-jogeon"><a href="#jehan-jogeon" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#제한-조건"></a> 제한 조건</h3><p>number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.<br>k는 1 이상 number의 자릿수 미만인 자연수입니다.</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>숫자로 주어진 문자열에서 - k만큼의 수 만큼을 선택하여 가장 큰 수를 골라주면된다.</li><li>이전에 프로그래머스 소수찾기에서 풀었던 것과 유사하긴 하지만 이것이 더 쉽습니다. DFS를 통하여 <code>number.size() - k</code> 개수만큼 숫자를 선택한다</li><li>basement조건은 선택한 개수와 k개의 개수를 제거한 개수와 같을 경우이다.</li><li>basement조건에 걸리게 되면 check된 값들만 문자열 결합을 통해서 값을 만들어준다. 그 이후 그 값들을 정수로 변환시켜서 최댓값을 구해준다.</li><li>모든 최댓값을 구하게 되었으면 to_string()함수를 이용해서 리턴시켜준다.</li></ul><hr><h2 id="puli"><a href="#puli" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> check[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> max_num= <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> number,<span class="keyword">int</span> cnt, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == cnt)&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">                str += number[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = atoi(str.c_str());</span><br><span class="line">        <span class="comment">// v.push_back(atoi(str.c_str()));</span></span><br><span class="line">        <span class="keyword">if</span>(res &gt; max_num)&#123;</span><br><span class="line">            max_num = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; len)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check[i] = <span class="number">1</span>;</span><br><span class="line">        dfs(number, cnt+<span class="number">1</span>, len, k);</span><br><span class="line">        check[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solution</span><span class="params">(<span class="built_in">string</span> number, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = number.size() - k;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    dfs(number,<span class="number">0</span>, len , k);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> to_string(max_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="프로그래머스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="DFS" scheme="http://gwanhyeon.github.io/tags/dfs/"/>
    
      <category term="그리디" scheme="http://gwanhyeon.github.io/tags/%EA%B7%B8%EB%A6%AC%EB%94%94/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 카펫</title>
    <link href="http://gwanhyeon.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B9%B4%ED%8E%AB/"/>
    <id>http://gwanhyeon.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B9%B4%ED%8E%AB/</id>
    <published>2020-10-09T08:06:54.000Z</published>
    <updated>2020-10-09T08:57:53.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><h2 id="peurogeuraemeoseu-kapes-munje"><a href="#peurogeuraemeoseu-kapes-munje" class="header-anchor">1.1. </a><a class="markdownIt-Anchor" href="#프로그래머스-카펫-문제"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42842?language=java" target="_blank" rel="noopener">프로그래머스 카펫 문제</a></h2><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><p>문제 설명<br>Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.</p><p>Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.</p><p>Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p><h3 id="jehansahang"><a href="#jehansahang" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#제한사항"></a> 제한사항</h3><p>갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.<br>노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.<br>카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.</p><hr><h2 id="keompyutingjeog-sago"><a href="#keompyutingjeog-sago" class="header-anchor">2.1. </a><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2><ul><li>이문제의 핵심은 카펫간의 규칙을 찾아내는것이 급선무입니다.</li><li>첫번째 테스트케이스 brown 10, yellow 2 일 경우 가로 일경우 [4,3] 세로일 경우 [3,4]의 값이 반환됩니다. 이것이 뜻하는 바는 yellow가 <code>직사각형이거나 정사각형</code>일 수 있다는것을 뜻하게 됩니다. 즉, <code>노란블록은 정사각형또는 직사각형</code>으로 가능합니다. 그이유는 n &gt; m 카펫의 가로길이는 세로 길이와 같거나 길기때문입니다.</li></ul><blockquote><p>이것을 어떻게 표현할 수 있을까요?<br>yellow = 24 테스트케이스를 살펴봅시다.<br>yellow가 24일 경우 나타낼 수 있는 케이스는(24 * 1, 12 * 2, 8 * 3, 6 * 4)로 표현할 수 있습니다.<br>즉, 노란블록의 총 가로 길이를 a, 세로길이를 b 라고 봤을때 (2a) + (2b) + 4 로 표현할 수 있습니다. 잘 생각해보시면 <code>노란색 위아래</code>로 갈색블록과 <code>노란색 좌우</code>로 갈색블록이기때문에 총 가로길이 2a, 총 세로길이 2b, 전체 카펫의 <code>좌측 상단, 우측상단, 좌측하단, 우측하단</code> 의 개수 총 4개로 표현 할 수 있습니다.</p></blockquote><p>결과적으로, (2a) + (2b) + 4 의 조건이 성립됩니다.</p><p>이에 따라 (2a) + (2b) + 4 의 값이 brown의 개수와 같다는 조건이 성립하면 되겠죠?<br>즉, 현재 a + 2(끝에 두점) , b + 2(끝에 두점)의 값으로 가로,세로의 최종길이를 구할 수 있게됩니다.</p><blockquote><p>요약</p></blockquote><ul><li>카펫의 길이는 n&gt;m의 크기를 만족합니다.</li><li>노란카펫은 직사각형 또는 정사각형을 만족합니다.</li><li>(2a) + (2b) + 4 의 조건이 brown과 같을때 해당 가로,세로의 최종길이입니다.</li></ul><hr><h2 id="puli"><a href="#puli" class="header-anchor">2.2. </a><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2><h3 id="wanjeontamsaeg-puli"><a href="#wanjeontamsaeg-puli" class="header-anchor">2.2.1. </a><a class="markdownIt-Anchor" href="#완전탐색-풀이"></a> 완전탐색 풀이</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 카펫 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> brown = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> yellow = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=yellow; i &gt;= (yellow/i); i--)&#123;</span><br><span class="line">            <span class="comment">// 나눠지는값이 아니면분리 못</span></span><br><span class="line">            <span class="keyword">if</span>(yellow % i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 가로 2배, 세로2배 모서리 4개 추가</span></span><br><span class="line">            <span class="keyword">if</span>(((<span class="number">2</span>*i)+(<span class="number">2</span>*(yellow/i)) + <span class="number">4</span>) == brown)&#123;</span><br><span class="line">                answer[<span class="number">0</span>] = <span class="number">2</span>+i;        <span class="comment">// 가로 + 2 끝점</span></span><br><span class="line">                answer[<span class="number">1</span>] = (<span class="number">2</span>+(yellow/i)); <span class="comment">// 세로 +2 끝점</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer[<span class="number">0</span>] + <span class="string">""</span>+ answer[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="프로그래머스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="완전탐색" scheme="http://gwanhyeon.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 주식가격</title>
    <link href="http://gwanhyeon.github.io/stock-price/"/>
    <id>http://gwanhyeon.github.io/stock-price/</id>
    <published>2020-09-23T10:54:24.000Z</published>
    <updated>2020-09-23T11:01:31.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><p><a href="https://programmers.co.kr/learn/courses/30/lessons/42584?language=java" target="_blank" rel="noopener">프로그래머스 주식가격</a></p><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><p>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.</p><blockquote><p>제한사항<br>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.<br>prices의 길이는 2 이상 100,000 이하입니다.</p></blockquote><h1 id="keompyuting-sago"><a href="#keompyuting-sago" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#컴퓨팅-사고"></a> 컴퓨팅 사고</h1><ul><li>스택으로 진행하는 방법도 있고, 배열로 진행하여도됩니다. 해당 풀이는 배열을 사용하였습니다.</li><li>prices배열에 담긴 값들이 초 단위로 기록되었을때 가격이 <code>몇초간 떨어지지않았는지</code>를 구하는 문제였습니다.</li><li>순수히 배열로만 사용하여 현재 가격과 그 이후에 일어날 시간의 값들을 비교해주었습니다. 현재의 가격이 뒤에 진행될 가격보다 크게 될 경우 <code>뒤에 진행된 시간- 현재의 시간</code>으로 계산하여 해당 조건들을 빠져나오게됩니다. 필요한값은 떨어지는 시점 즉, 현재의 가격보다 낮은값이 나왔을때 해당 조건을 벗어나게 됩니다.</li><li>처음에 주식가격보다 클경우 cnt값을 증가시켜서 arr배열에 담아주었는데, 정확도 면에서 틀린부분이 있었습니다. 기존의 실행은 통과하였으나 다른 테스트케이스를 통과를 하지 못했습니다. 제가 생각하지못한 예외가 있었을것이라고 생각이드는데, 바로 다른방식으로 진행하여 <code>다음에 일어날 시간 - 현재 시간</code>의 조건을 가지고 진행하였습니다.</li></ul><h1 id="soseu-kodeu"><a href="#soseu-kodeu" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#소스-코드"></a> 소스 코드</h1><blockquote><p>잘못생각하였던 풀이</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 주식가격 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;prices.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i] &lt;= prices[j])&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] +<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>올바른 풀이</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 주식가격 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;prices.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i] &gt; prices[j])&#123;</span><br><span class="line">                    arr[i] = j-i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == prices.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    arr[i] = j-i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] +<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="프로그래머스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
  </entry>
  
  <entry>
    <title>프로그래머스 멀쩡한 사각형</title>
    <link href="http://gwanhyeon.github.io/good-shape-sqaure/"/>
    <id>http://gwanhyeon.github.io/good-shape-sqaure/</id>
    <published>2020-09-22T12:30:28.000Z</published>
    <updated>2020-09-22T12:41:26.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><p><a href="https://programmers.co.kr/learn/courses/30/lessons/62048?language=java#" target="_blank" rel="noopener">프로그래머스 멀쩡한 사각형</a></p><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><p>가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.<br>가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요.</p><h1 id="keompyuting-sago"><a href="#keompyuting-sago" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#컴퓨팅-사고"></a> 컴퓨팅 사고</h1><ul><li><code>유클리드 알고리즘</code> 원리. 임의의 <code>두 자연수 a, b</code>가 주어졌을때. 둘중 큰 값이 a라고 가정해보겠습니다. <code>n이 0일때, b가 최대 공약수(GCD)</code>입니다. 즉, 최대공약수(GCD)를 구하는 방식을 알고있어야합니다.<br><code>gcd(greatest common divisor)</code>는 최대공약수의 약자인데요 최대 공약수는 어떻게 구할수 있을까요?</li></ul><blockquote><p>최대공약수 구하기<br>예를 들면 12,8 이라는 숫자가 있다고 가정하겠습니다. 이것의 숫자의 최대 공약수는 어떻게 될까요? 작은숫자이기 때문에 <code>최대공약수는 4</code>라고 하는것을 쉽게 알 수 있을것입니다.<br>하지만 값이 더 커질때는 암산으로 하기에는 힘든감이 있겠죠?<br>일단, <code>12와 8의 값의 최대 공약수</code>를 구해보겠습니다. <code>12를 w, 8을 h</code>라고 가정하겠습니다.<br>최대 공약수는 (h, w%h)의 값으로 구할 수 있습니다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>, <span class="number">8</span></span><br><span class="line"><span class="number">8</span>, <span class="number">4</span>(<span class="number">12</span>를 <span class="number">8</span>로 나눈 나머지)</span><br><span class="line"><span class="number">4</span>, <span class="number">0</span>(<span class="number">8</span>을 <span class="number">4</span>로 나눈나머지)</span><br></pre></td></tr></table></figure><blockquote><p>사각형의 넓이를 구하기<br><code>사각형의 넓이는 너비 * 높이</code>로 구할 수 있습니다.</p></blockquote><blockquote><p>대각선방향으로 자르는 정사각형의 개수는 어떻게 구할 수 있나요?<br><code>전체 사각형 넓이 -(너비 + 높이) + 최대 공약수</code><br>의 값으로 정답을 노출해낼 수 있습니다.</p></blockquote><blockquote><p>W,H의 제한<br><code>W와 H의 제한은 1억이하의 자연수입니다.</code> 따라서 long타입으로 조금 더 넓은 범위로 연산이 가능하게 하였습니다.</p></blockquote><h1 id="soseu-kodeu"><a href="#soseu-kodeu" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#소스-코드"></a> 소스 코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(h, w % h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gcd_num = gcd(w,h);</span><br><span class="line">        <span class="keyword">long</span> squreArea = (<span class="keyword">long</span>)w * (<span class="keyword">long</span>)h;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> answer = squreArea - ((<span class="keyword">long</span>)w + (<span class="keyword">long</span> )h) + gcd_num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="Programmers" scheme="http://gwanhyeon.github.io/categories/programmers/"/>
    
    
      <category term="프로그래머스" scheme="http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="수학" scheme="http://gwanhyeon.github.io/tags/%EC%88%98%ED%95%99/"/>
    
  </entry>
  
  <entry>
    <title>백준 숫자카드 10815</title>
    <link href="http://gwanhyeon.github.io/number-card/"/>
    <id>http://gwanhyeon.github.io/number-card/</id>
    <published>2020-09-22T06:25:26.000Z</published>
    <updated>2020-09-22T06:49:00.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="munje-ringkeu"><a href="#munje-ringkeu" class="header-anchor">1. </a><a class="markdownIt-Anchor" href="#문제-링크"></a> 문제 링크</h1><p><a href="https://www.acmicpc.net/problem/10815" target="_blank" rel="noopener">백준 숫자카드 10815</a></p><h1 id="munje-jogeon"><a href="#munje-jogeon" class="header-anchor">2. </a><a class="markdownIt-Anchor" href="#문제-조건"></a> 문제 조건</h1><blockquote><p>문제<br>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.</p></blockquote><blockquote><p>입력<br>첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.</p></blockquote><p>셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다</p><h1 id="keompyuting-sago"><a href="#keompyuting-sago" class="header-anchor">3. </a><a class="markdownIt-Anchor" href="#컴퓨팅-사고"></a> 컴퓨팅 사고</h1><ul><li>1,2번째 줄에 입력에 상근이가 가지고 있는 카드의 개수를 저장시킵니다.</li><li>3,4번째 줄에 찾고자하는 숫자를 입력합니다.</li></ul><p>처음에 모든 경우의 수를 탐색하게 된다면 <code>-10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.</code> 라는 조건때문에 시간복잡도 상으로 시간초과가 날 것으로 생각하였습니다. 그래서 HashSet과 이분탐색을 진행하여 해당 문제를 풀어보면 시간복잡도면에서 통과할 수 있을것이라는 생각이 들게되었습니다. 해당 포스팅에는 HashSet과 이분탐색을 이용한 풀이를 두가지 방법을 모두 사용해보았습니다.</p><h3 id="hashseteul-sayonghan-puli"><a href="#hashseteul-sayonghan-puli" class="header-anchor">3.1. </a><a class="markdownIt-Anchor" href="#hashset을-사용한-풀이"></a> HashSet을 사용한 풀이</h3><p>문제조건상 반복되는 수가 없다고 하였지만, <code>Map</code>을 사용하기에는 <code>(key, value)</code>가 필요하기 때문에 <code>HashSet</code>을 사용하였습니다. 상근이가 가진 카드를 모두 HashSet에 넣어주게 된다음에 이제 상근이가 <code>찾을 값들을 HashSet에 있는 값과 비교</code>해주면 됩니다. <code>찾았다면 1</code>, <code>찾지못했다면 0을 add</code>시켜주게 되고 <code>ArrayList</code> 자료 구조를 사용하여 최종 결과값을 출력시켜주었습니다.</p><blockquote><p>HashSet의 특징<br>자바 Collection 중 Set의 대표적인 <code>HashSet 클래스</code>입니다. HashSet은 Set 인터페이스의 구현 클래스입니다.  <code>HashSet은 Set의 파생클래스</code>로 Set은 기본적으로 집합으로 중복된 원소를 허용하지 않으며 순서 또한 고려하지 않습니다.</p></blockquote><h3 id="binary-search-ibun-tamsaeg"><a href="#binary-search-ibun-tamsaeg" class="header-anchor">3.2. </a><a class="markdownIt-Anchor" href="#binary-search이분-탐색"></a> Binary Search(이분 탐색)</h3><blockquote><p>이분 탐색이란?<br><code>이진 탐색은</code> 정렬된 데이터의 집합을 <code>이분화 하면서 탐색</code>하는 알고리즘입니다.</p></blockquote><blockquote><p>이분 탐색의 장점<br>정렬이 되어 있어야 이진탐색을 할 수 있습니다.<code>O(logN)</code> 으로 빠르게 탐색할 수 있습니다. <code>O(logN)인 이유는</code> 이진 트리형태로 <code>절반을 줄여가면서 값을 탐색</code>하는 형식이기 때문입니다.<br>이분 탐색의 단점<br>만약 이분탐색에서 값들이 정렬이 되어 있지 않다면 <code>정렬하는데 많은시간이 소요</code>되며 정렬된 데이터가 아니면 <code>이분탐색에 적용할 수 없습니다.</code></p></blockquote><blockquote><p>이진탐색 문제 풀이</p></blockquote><ul><li>상근이가 가진 카드의 값들을 <code>입력</code>을 받습니다.</li><li>상근이가 가진 카드의 값들을 <code>정렬</code>합니다<code>(오름차순정렬)</code></li><li>상근이가 찾고하자는 개수까지 Binary Search함수를 호출합니다. 이때 첫번째 파라미터는 찾고자하는 <code>target</code> 값입니다. 그리고 두번째 파라미터는 상근이가 가지고 있는 카드의 개수입니다.</li></ul><blockquote><p>binary Search함수</p></blockquote><ul><li><code>시작점은 0</code>, <code>끝점은 len-1</code>의 값으로 <code>초기화</code> 시켜줍니다.</li><li>while문으로 end보다 크거나 작을때 까지 계속 루프를 진행합니다.</li><li><code>mid</code>라는 변수를 선언하여 <code>시작점과 끝점을 더한값의 / 2</code>를 연산하여 중간값을 구해주게 됩니다.</li><li>만약 상근이가 가진 카드의 값이 <code>target값 보다 작을 경우</code> 시작점을 <code>start = mid-1</code>점으로 설정하게 됩니다.</li><li>만약 상근이가 가진 카드의 값이 <code>target값 보다 클 경우</code> 끝점을 <code>end = mid-1</code>로 설정하게 됩니다.</li><li>상근이가 <code>가진값과 찾고자하는 값이 같을 경우</code>에는 현재 중간값을 리턴해주게 됩니다. 즉, <code>상근이가 갖고 있는 카드에서 상근이가 찾고자하는 값을 찾은게 됩니다.</code></li><li>해당 binary search함수는 값을 찾았기 때문에 <code>중간값을 리턴</code>해줍니다. 찾았을 경우에는 1을 넣어주게 됩니다.</li><li><code>값을 찾지 못하였을 경우</code>에는 <code>-1을 리턴</code>을 받습니다. 그리고 <code>0을 넣어주게됩니다.</code></li><li>최종적으로 값을 출력시키게 되면 해당되는 <code>값을 찾았는지 못찾았는지의 여부</code>를 확인할 수 있습니다.<code>(0,1)</code></li></ul><h1 id="soseu-kodeu"><a href="#soseu-kodeu" class="header-anchor">4. </a><a class="markdownIt-Anchor" href="#소스-코드"></a> 소스 코드</h1><blockquote><p>Binary Search(이분탐색) 풀이</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 숫자카드 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line">        ArrayList&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            arr[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(br.readLine());</span><br><span class="line">        st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="comment">// none contain</span></span><br><span class="line">            <span class="keyword">if</span>(BinarySearch(x,n) == -<span class="number">1</span>)&#123;</span><br><span class="line">                answer.add(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                answer.add(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : answer) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; target)&#123;</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HashSet 풀이</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 숫자카드 </span>&#123;</span><br><span class="line">    <span class="comment">// HashSet 문제</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; s = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(br.readLine());</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            s.add(Integer.parseInt(st.nextToken()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(br.readLine());</span><br><span class="line">        st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.contains(num))&#123;</span><br><span class="line">                arr.add(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr.add(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : arr) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;munje-ringkeu&quot;&gt;&lt;a href=&quot;#munje-ringkeu&quot; class=&quot;header-anchor&quot;&gt;1. &lt;/a&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#문제-링크&quot;&gt;&lt;/a&gt; 문제 링크&lt;/h1&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/categories/boj/"/>
    
    
      <category term="알고리즘" scheme="http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
      <category term="백준" scheme="http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"/>
    
      <category term="BOJ" scheme="http://gwanhyeon.github.io/tags/boj/"/>
    
      <category term="이분탐색" scheme="http://gwanhyeon.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"/>
    
  </entry>
  
</feed>
