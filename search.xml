<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>이진탐색트리 BST</title>
    <url>/2019/11/23/bst/</url>
    <content><![CDATA[<h1 id="검색트리-search-tree"><a class="markdownIt-Anchor" href="#검색트리-search-tree"></a> 검색트리 Search Tree</h1>
<h3 id="계층적인-구조를-표현"><a class="markdownIt-Anchor" href="#계층적인-구조를-표현"></a> 계층적인 구조를 표현</h3>
<ul>
<li>조직도</li>
<li>디렉토리와 서브디렉토리 구조</li>
<li>가계도</li>
</ul>
<h3 id="트리의-특징"><a class="markdownIt-Anchor" href="#트리의-특징"></a> 트리의 특징</h3>
<ul>
<li>트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됩니다.</li>
<li>맨 위의 노드를 <code>&quot;루트(root)&quot;</code>라고 부릅니다.</li>
<li>노드를 연결하는 선을 <code>&quot;link&quot;, &quot;edge&quot;,&quot;branch&quot;</code></li>
<li><code>부모노드 자식노드</code>로 구성되어있습니다.</li>
<li>루트노드를 제외한 트리의 모든 노드들은 <code>유일한 부모노드</code>를 갖습니다.</li>
<li>부모가 동일한 노드들을 형제 <code>&quot;sibling&quot;</code>관계라고 부릅니다.</li>
<li>자식이 없는 노드들을 <code>&quot;leaf&quot;</code>노드라고 부릅니다.</li>
<li>“leaf” 노드가 아닌것 <code>내부 노드</code>라고 부릅니다.</li>
<li><code>조상-자손 관계</code>가 있다. 부모-자식관계를 확장한것 (ancestor-descendant) 관계</li>
<li>루트는 레벨관계 <code>Level 0 ~ Level N</code> 까지 갖습니다.</li>
</ul>
<ul>
<li>트리의 기본적인 성질
<ul>
<li>노드가 N개인 트리는 항상 N-1개의 링크(link)를 가집니다.</li>
<li>트리에서 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간의 경로도 유일(존재,1개)합니다.(단, 같은 노드를 두 번 이상 방문하지 않는다)</li>
<li>트리의 높이는 레벨의 개수입니다.</li>
</ul>
</li>
</ul>
<h1 id="이진-트리-binary-tree"><a class="markdownIt-Anchor" href="#이진-트리-binary-tree"></a> 이진 트리 Binary Tree</h1>
<h3 id="특징"><a class="markdownIt-Anchor" href="#특징"></a> 특징</h3>
<ul>
<li>이진 트리에서 각 노드는 최대 2개의 자식을 가집니다.</li>
<li>각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정됩니다.(자식이 한 명인 경우에도)</li>
<li>서로 다른 이진트리는 값의 위치가 다르면 <code>서로 다른 이진트리</code>라고 불리온다. (자식노드가 한개인 경우에도 해당됩니다)</li>
</ul>
<h3 id="이진트리의-응용-expression-tree-huffman-code"><a class="markdownIt-Anchor" href="#이진트리의-응용-expression-tree-huffman-code"></a> 이진트리의 응용 Expression Tree, Huffman Code</h3>
<ul>
<li>
<p>(x+y) * ((a + b) / c) 를 이진 트리형태로 나타낼 수 있다. Expression트리에서 응용한다.</p>
</li>
<li>
<p>허프만 코드 ‘A’ - ‘Z’, ‘a’ - ‘z’ 파일들의 알파벳을 어떤 데이터를 압축하는 것을 뜻한다. 파일의 길이가 최소가 되도록 하는 알고리즘(파일 압축)</p>
</li>
</ul>
<h3 id="full-binary-trees-and-complete-binary-trees"><a class="markdownIt-Anchor" href="#full-binary-trees-and-complete-binary-trees"></a> Full Binary Trees And Complete Binary Trees</h3>
<ul>
<li>
<p>Full Binary Trees 모든 레벨에서 노드에 채워져 있는 경우</p>
</li>
<li>
<p>Completr Binary Trees 맨 마지막경우에는 노드가 없을 수 있다.(단, 끝에서부터 노드가 없을 수 있다.)</p>
</li>
<li>
<p>높이가 h인 full binary tree는 2^h-1개의 노드를 가진다.</p>
</li>
<li>
<p>노드가 N개인 full 혹은 complete 이진 트리의 높이는 O(logN)이다.(노드가 N개인 이진트리의 높이는 최악의 경우 N이 될 수 있다.)</p>
</li>
</ul>
<h3 id="이진트리의-표현"><a class="markdownIt-Anchor" href="#이진트리의-표현"></a> 이진트리의 표현</h3>
<ul>
<li>Heap은 Complete Binary Tree이다.</li>
<li>연결 구조 표현
<ul>
<li>각 노드에 하나에의 데이터필드와 왼쪽자식(left), 오른쪽 자식(right),그리고 부모노드§의 주소를 저장</li>
<li>부모노드는 주소는 반드시 필요한 경우가 아니면 보통 생략함</li>
</ul>
</li>
</ul>
<h3 id="이진트리의-순회traversal"><a class="markdownIt-Anchor" href="#이진트리의-순회traversal"></a> 이진트리의 순회(Traversal)</h3>
<ul>
<li>
<p>순회: 이진 트리의 모든 노드를 방문하는 일</p>
</li>
<li>
<p>중순위(inorder) 순회</p>
<ul>
<li>
<p>왼쪽자식기준으로 루트노드를 중간에 방문한다.</p>
</li>
<li>
<p>왼쪽 자식 노드-&gt;루트-&gt;오른쪽 자식 노드</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pre-order-tree-walk(left[x])</span><br><span class="line"><span class="built_in">print</span> key[x]</span><br><span class="line">pre-order-tree-wal(right[x])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>선순위(preorder) 순회</p>
<ul>
<li>
<p>왼쪽자식기준으로 루트노드를 처음에 방문한다.</p>
</li>
<li>
<p>루트 노드-&gt;왼쪽 자식 노드-&gt;오른쪽 자식 노드</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> key[x]</span><br><span class="line">pre-order-tree-walk(left[x])</span><br><span class="line">pre-order-tree-wal(right[x])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>후순위(postorder) 순회</p>
<ul>
<li>
<p>왼쪽기준으로 루트노드를 마지막에 방문한다.</p>
</li>
<li>
<p>왼쪽 자식 노드-&gt;루트 노드-&gt;중간 자식 노드</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pre-order-tree-walk(left[x])</span><br><span class="line">pre-order-tree-wal(right[x])</span><br><span class="line"><span class="built_in">print</span> key[x]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>레벨오더(level-order) 순회</p>
<ul>
<li>
<p>레벨 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로 방문합니다.</p>
</li>
<li>
<p>큐(queue)를 이용하여 구현</p>
<p>트리에 [1,2,3,4,5,6,7]이 순서대로 있다고하면 레벨별로 하나씩 방문한다(단, 기준은 왼쪽)</p>
<hr />
<p>Level 0: 1</p>
<p>Level 1: 2,3</p>
<p>Level 2: 4,5,6,7</p>
<hr />
<p>해당 순서로 방문한다고 생각하면 됩니다.</p>
</li>
</ul>
</li>
</ul>
<h1 id="이진탐색트리-inary-search-tree"><a class="markdownIt-Anchor" href="#이진탐색트리-inary-search-tree"></a> 이진탐색트리 inary Search Tree</h1>
]]></content>
      <categories>
        <category>알고리즘</category>
      </categories>
      <tags>
        <tag>검색트리</tag>
        <tag>이진탐색트리</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>N-Queen 문제</title>
    <url>/2019/11/23/n-queen/</url>
    <content><![CDATA[<h2 id="n-queen문제"><a class="markdownIt-Anchor" href="#n-queen문제"></a> <a href="https://www.acmicpc.net/problem/9663" target="_blank" rel="noopener">N-Queen문제</a></h2>
<h2 id="컴퓨팅적-스킬"><a class="markdownIt-Anchor" href="#컴퓨팅적-스킬"></a> 컴퓨팅적 스킬</h2>
<ul>
<li>Recursive() 재귀함수 어느지점에서 종료시키고, 다시 재귀호출을 해야하는지의개념을 확실하게 알고 있어야합니다.</li>
<li>Recursive()의 개념을 잡기에 좋은 문제는 <code>백준 N과 M시리즈</code> 입니다. 개념이 약하신분들은 순열과 조합의 개념부터 확실히 잡고 오시는것이 좋을 것이라고 생각을 합니다.</li>
<li><code>백트래킹 깊이우선탐색(DFS)</code>의 개념을 알아야합니다. 깊이우선탐색은 보통 <code>Recursive, Stack</code>를 사용합니다. Recursive가 직관적이고 코드이해하기도 쉽고, 스택보다는 구현이 덜 복잡하다는 장점이 있어서 Recursive로 구현하겠습니다.</li>
</ul>
<hr />
<h2 id="컴퓨팅적-사고"><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2>
<ul>
<li>
<p>깊이우선탐색(DFS) 진행한 Level과 모든 말을 놓는 경우의 수가 같을때 재귀호출을 종료해야합니다.</p>
</li>
<li>
<p>N<em>N</em>N … N^N의 시간복잡도를 갖습니다.</p>
</li>
<li>
<p>백트래킹의 개념에 대해 알고 있어야 한다. 깊이우선탐색의 트리형태로 어떻게 진행하는지 직접 손으로 써보면서 진행해야합니다.</p>
</li>
<li>
<p>상태공간트리의 개념을 알고 있어야합니다.</p>
<ul>
<li>상태공간트리란 찾는 해를 포함하는 트리이며 이트리안에 어떠한 노드에 해당하는 이 트리를 체계적으로 탐색하면서 반드시 해를 찾을 수 있어야합니다.</li>
</ul>
</li>
<li>
<p>해당 퀸이 열 있는지 체크와 대각선을 체크해야합니다.</p>
</li>
</ul>
<p>예를 들어 설명하겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start에서 시작하면서 트리의 형태로 가지를 치면서 진행합니다. start-&gt; (0,0) (0,1) (0,2) (0,3)  첫번째 열에서 갈수 있는 모든 경우의 수입니다.</span><br><span class="line"></span><br><span class="line">(1,0) (1,1) (1,2) .... 두번째 열에서 갈 수 있는 경우의 수</span><br><span class="line"></span><br><span class="line">(level, 1) (level, 2) (level, 3) Level 크기에서 갈 수 있는 경우의 수</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Level 0</td>
<td>(0,0)</td>
<td>(0,1)</td>
<td>(0,2)</td>
<td>(0,3)</td>
</tr>
<tr>
<td>Level 1</td>
<td>(1,0)</td>
<td>(1,1)</td>
<td>(1,2)</td>
<td>(1,3)</td>
</tr>
<tr>
<td>Level 2</td>
<td>(2,0)</td>
<td>(2,1)</td>
<td>(2,2)</td>
<td>(2,3)</td>
</tr>
<tr>
<td>Level 3</td>
<td>(3,0)</td>
<td>(3,1)</td>
<td>(3,2)</td>
<td>(3,3)</td>
</tr>
</tbody>
</table>
<hr />
<p>다음의 상황은 <code>Level 0 ~ Level N</code> 의 경우까지 진행하는 경우라고 생각하겠습니다.</p>
<ul>
<li>
<p>Level0의 경우에서 갈 수 있는 모든경우를 탐색하면서 퀸을 놓습니다. 그리고 다음 Level1으로 진행하면서 열에 들어갈 수 있는 경우를 확인하면서 진행합니다. 이때 알아야 하는 부분이 Promissing의 개념입니다.</p>
</li>
<li>
<p>즉,<code>Level0 (0,0)</code>에 퀸을 놓으면 <code>Level1 (1,0)</code>에 퀸을 놓는 경우를 확인해보겠습니다. 퀸을 놓을 수 있는 조건은 <code>동, 서, 남, 북, 대각선</code>에 퀸이 위치해있으면 놓을 수 없습니다. 그러면 당연히 (1,0)은 확인할 필요도 없이 놓을 수 없는 경우의 수라는것입니다. 이것을 Promissing의 개념을 확인하여 더 갈 수 있는지 없는지를 판단하는 것입니다. 체크한다고 하시면 됩니다.</p>
</li>
<li>
<p>레벨의 수가 결국 말의 개수를 뜻합니다. 제 코드에서는 cols라는 배열이 쓰이는데 이것은 현재 말이 어디에 놓였는지에 대한 위치입니다. cols[1] : 1번말이 놓인 열 , cols[2] : 2번말이 놓인 열 … cols[i] = j (i번말이 j에 놓였다는 의미입니다. i는 결국 레벨입니다.)</p>
</li>
<li>
<p>Promissing Test를 진행할 때 마지막에 놓인 이 말이 이전에 놓인 다른 말들과 충돌하는지 검사를 하면 퀸을 놓을수 있는지 없는지를 확인 할 수 있습니다.</p>
</li>
</ul>
<h3 id="recursive-설계"><a class="markdownIt-Anchor" href="#recursive-설계"></a> Recursive 설계</h3>
<ol>
<li>promising()함수를 호출합니다. 진행이 가능한지 여부를 확인하고 아니면 false, 가능하면 true를 리턴합니다.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다.</span></span><br><span class="line"> <span class="keyword">if</span>(!promissing(level,N))&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Level과 N의 값이 같은 경우(성공한 경우)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 성공적으로 도착하였을 경우</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(level == N)&#123;</span><br><span class="line">      <span class="comment">// 기존의 N-queen의 위치를 구하면 종료하는 형식이였지만, 모든 경우의 수를 구하기 위해서는 해당 cnt값을 증가시켜주어서 확인할 수 있다.</span></span><br><span class="line">      cnt+=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Level과 N의 값이 같지 않은 경우 Recursive() 재귀 함수 호출</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">     cols[level+<span class="number">1</span>] = i;</span><br><span class="line">     <span class="comment">// 다음 레벨로 재귀 호출</span></span><br><span class="line">     <span class="keyword">if</span>(recursive(level+<span class="number">1</span>,N))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="promising-test-설계"><a class="markdownIt-Anchor" href="#promising-test-설계"></a> Promising Test 설계</h3>
<ol>
<li>같은 열을 확인하여야합니다.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미))</span></span><br><span class="line">      <span class="keyword">if</span>(cols[i] == cols[level])&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>같은 대각선에 놓였는지를 확인하여야 합니다.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 대각선에 충돌되는것 확인</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((level-i) == <span class="built_in">abs</span>(cols[level] - cols[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2>
<h3 id="1-dfs-백트래킹-해당-값-찾기기본-개념"><a class="markdownIt-Anchor" href="#1-dfs-백트래킹-해당-값-찾기기본-개념"></a> 1. DFS 백트래킹 해당 값 찾기(기본 개념)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  n-queen.cpp</span></span><br><span class="line"><span class="comment">//  algorithm-level-up</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by kgh on 22/11/2019.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 kgh. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cols[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">promissing</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;level; i++)&#123;</span><br><span class="line">        <span class="comment">// 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미))</span></span><br><span class="line">        <span class="keyword">if</span>(cols[i] == cols[level])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 대각선에 충돌되는것 확인</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((level-i) == <span class="built_in">abs</span>(cols[level] - cols[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다.</span></span><br><span class="line">    <span class="keyword">if</span>(!promissing(level,N))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 성공적으로 도착하였을 경우</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(level == N)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; i &lt;&lt; <span class="string">","</span> &lt;&lt; cols[i] &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">        cols[level+<span class="number">1</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 성공할 경우</span></span><br><span class="line">        <span class="keyword">if</span>(recursive(level+<span class="number">1</span>,N))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">8</span>;</span><br><span class="line">    recursive(<span class="number">0</span>,N);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-dfs-백트래킹-해당-값-찾기경우의-수-찾기-백준-문제"><a class="markdownIt-Anchor" href="#2-dfs-백트래킹-해당-값-찾기경우의-수-찾기-백준-문제"></a> 2. DFS 백트래킹 해당 값 찾기(경우의 수 찾기 백준 문제)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  n-queen.cpp</span></span><br><span class="line"><span class="comment">//  algorithm-level-up</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by kgh on 22/11/2019.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 kgh. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cols[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">promissing</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;level; i++)&#123;</span><br><span class="line">        <span class="comment">// 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미))</span></span><br><span class="line">        <span class="keyword">if</span>(cols[i] == cols[level])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 대각선에 충돌되는것 확인</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((level-i) == <span class="built_in">abs</span>(cols[level] - cols[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다.</span></span><br><span class="line">    <span class="keyword">if</span>(!promissing(level,N))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 성공적으로 도착하였을 경우</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(level == N)&#123;</span><br><span class="line">        <span class="comment">// 기존의 N-queen의 위치를 구하면 종료하는 형식이였지만, 모든 경우의 수를 구하기 위해서는 해당 cnt값을 증가시켜주어서 확인할 수 있다.</span></span><br><span class="line">        cnt+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">        cols[level+<span class="number">1</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 성공할 경우</span></span><br><span class="line">        <span class="keyword">if</span>(recursive(level+<span class="number">1</span>,N))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    recursive(<span class="number">0</span>,N);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>알고리즘</category>
      </categories>
      <tags>
        <tag>백준</tag>
        <tag>DFS</tag>
        <tag>백트래킹</tag>
      </tags>
  </entry>
  <entry>
    <title>프로그래머스 더 맵게</title>
    <url>/2019/11/20/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EB%8D%94%EB%A7%B5%EA%B2%8C/</url>
    <content><![CDATA[<h2 id="프로그래머스-더-맵게-문제"><a class="markdownIt-Anchor" href="#프로그래머스-더-맵게-문제"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42626" target="_blank" rel="noopener">프로그래머스 더 맵게 문제</a></h2>
<h2 id="컴퓨팅적-스킬"><a class="markdownIt-Anchor" href="#컴퓨팅적-스킬"></a> 컴퓨팅적 스킬</h2>
<ul>
<li>이번 문제를 해결하기 위해서는 단순 sort를 사용하는것이 아니라 우선순위큐 <code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;</code>  오름차순 형식으로 써주어야합니다.</li>
<li>단순히 while문을 통해서 안에서 sort를 처리하려고 하였지만 16번 테스트케이스를 통과하지 못하였고 효율성에서는 시간초과가 발생하였습니다. 또한, 범위값이 너무 제한적이였다. 그래서 우선순위큐를 사용하였습니다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoville의 길이는 1 이상 1,000,000 이하입니다.</span><br><span class="line">K는 0 이상 1,000,000,000 이하입니다.</span><br><span class="line">scoville의 원소는 각각 0 이상 1,000,000 이하입니다.</span><br></pre></td></tr></table></figure>
<ul>
<li>주의해야할점은 <code>우선순위큐 push는 맨앞으로 들어간다는것과 top에 있는것도 0번째 인덱스에 있는 값</code>입니다.</li>
</ul>
<hr />
<h2 id="컴퓨팅적-사고"><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2>
<ol>
<li>스코빌 벡터에 있는 값을 우선순위큐에 넣어준다. <code>greater&lt;int&gt;</code>를 옵션으로 지정하였기 때문에 자동으로 오름차순으로 정렬해줍니다. 만약 내림차순으로 하고 싶은경우 less<int>옵션을 사용하시면 됩니다.</li>
<li><code>첫번째, 두번째값을 통하여 스코빌 지수</code>를 구합니다. <code>단 q.top()의 값이 K보다 작아야합니다.</code> 반복문 조건</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">예시</span><br><span class="line">스코빌 1 2 3 9 10일경우  </span><br><span class="line">(1 + 2 * 2) 5 3 9 10 으로 변경됩니다. 우선순위큐 이므로 3 5 9 10 정렬됩니다.</span><br><span class="line">(3 + 5 * 2) 13 9 10 으로 변경됩니다. 우선순위큐 이므로 9 10 13 정렬됩니다.</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>기존의 while문에서는 sort를 다시해주어야하는데 우선순위 큐가 자동으로 정렬시켜주기때문에 필요없는 과정입니다.</li>
<li>만약 우선순위큐의 사이즈가 2이하가 되면 더이상 구할 수 없으므로 Return -1을 실행합니다. 그게 아니라면 계속 진행하고 q.top()의 값이 K보다 큰 경우가 있으면 더이상 반복문을 반복하지 않습니다.</li>
</ol>
<hr />
<h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2>
<h3 id="1-일반적인-sort-풀이시간초과"><a class="markdownIt-Anchor" href="#1-일반적인-sort-풀이시간초과"></a> 1. 일반적인 sort 풀이(시간초과)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  더맵게 일반 정렬.cpp</span></span><br><span class="line"><span class="comment">//  algorithm-level-up</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by kgh on 20/11/2019.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 kgh. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scoville;</span><br><span class="line">  </span><br><span class="line">    scoville.push_back(<span class="number">3</span>);</span><br><span class="line">    scoville.push_back(<span class="number">9</span>);</span><br><span class="line">    scoville.push_back(<span class="number">10</span>);</span><br><span class="line">    scoville.push_back(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">int</span> K=<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = scoville.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        sort(scoville.<span class="built_in">begin</span>(),scoville.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 스코빌 첫번째 값이 K보다 작아야하고, cnt 값이 해당 스코빌 사이즈값이전까지 돌아아한다, 그리고 스코빌 사이즈는 2보다 커야한다. 아니면 -&gt; 메모리 에러남</span></span><br><span class="line">        <span class="keyword">if</span>(scoville[<span class="number">0</span>] &lt; K &amp;&amp; cnt &lt; len &amp;&amp; scoville.<span class="built_in">size</span>() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> new_scoville=<span class="number">0</span>;</span><br><span class="line">                  </span><br><span class="line">          new_scoville = scoville[<span class="number">0</span>] + (scoville[<span class="number">1</span>] * <span class="number">2</span>);</span><br><span class="line">          scoville[<span class="number">0</span>] = new_scoville;</span><br><span class="line">          scoville.erase(scoville.<span class="built_in">begin</span>()+<span class="number">1</span>);</span><br><span class="line">          cnt+=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 스코빌 첫번째지수가 K보다 작으면 결국 모든것이 되지않았으니까 cnt = 0;</span></span><br><span class="line">            <span class="keyword">if</span>(scoville[<span class="number">0</span>] &lt; K)&#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">        answer = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; answer;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        answer = cnt;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; answer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="우선순위큐-사용"><a class="markdownIt-Anchor" href="#우선순위큐-사용"></a> 우선순위큐 사용</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  더맵게 우선순위큐.cpp</span></span><br><span class="line"><span class="comment">//  algorithm-level-up</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by kgh on 20/11/2019.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 kgh. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scoville;</span><br><span class="line">    scoville.push_back(<span class="number">1</span>);</span><br><span class="line">    scoville.push_back(<span class="number">2</span>);</span><br><span class="line">    scoville.push_back(<span class="number">3</span>);</span><br><span class="line">    scoville.push_back(<span class="number">9</span>);</span><br><span class="line">    scoville.push_back(<span class="number">10</span>);</span><br><span class="line">    scoville.push_back(<span class="number">12</span>);</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> K = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;scoville.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        q.push(scoville[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min_num_first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_num_second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.top() &lt; K)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        min_num_first = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        min_num_second = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        res = min_num_first + (min_num_second * <span class="number">2</span>);</span><br><span class="line">        q.push(res);</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>알고리즘</category>
      </categories>
      <tags>
        <tag>프로그래머스</tag>
        <tag>알고리즘</tag>
        <tag>레벨2</tag>
        <tag>우선순위큐</tag>
      </tags>
  </entry>
  <entry>
    <title>프로그래머스 가장 큰 수</title>
    <url>/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%ED%81%B0%EC%88%98/</url>
    <content><![CDATA[<h2 id="프로그래머스-가장-큰-수-문제"><a class="markdownIt-Anchor" href="#프로그래머스-가장-큰-수-문제"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42746" target="_blank" rel="noopener">프로그래머스 가장 큰 수 문제</a></h2>
<h2 id="컴퓨팅적-스킬"><a class="markdownIt-Anchor" href="#컴퓨팅적-스킬"></a> 컴퓨팅적 스킬</h2>
<ul>
<li>0 또는 양의 정수 1 &lt;= numbers_length &lt;= 100,000, 0 &lt;= numbers &lt;= 1000 를 보고 O(N^2) 복잡도 불가할 것이라 예측하였습니다. 왜냐하면 (100,000)^ = 약 100억</li>
<li>String to int 변환 함수 atoi(str.c_str()), int to String 변환함수 to_string(number)
<ul>
<li><code>“String&quot; - ‘0’ =&gt; 숫자</code>로 변경이 가능합니다. <code>단, 범위는 0~9까지</code></li>
<li><code>Number + ‘0’ =&gt; 문자</code>로 변경이 가능합니다. <code>단, 범위는 0~9까지</code></li>
<li>숫자가 10이 나왔을 경우에는 <code>dec = dec * 10 + str[i] - '0'</code>의 형식으로 해주어야합니다. <code>유사문제로는 카카오 셔틀버스 문제</code>가 있습니다.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 &gt; s2 + s1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s1 &gt; s2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="컴퓨팅적-사고"><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2>
<ul>
<li>string기준으로 문제를 해결해야한다.</li>
<li>맨 처음 순열과 같이 <code>DFS로 완전탐색</code>을 하였지만 <code>시간초과</code> 가 나서 sort()함수 사용해봤지만 테스트케이스는 맞지만 시간초과는 그대로여서 시간복잡도에 고민을 한번 더 하였습니다.</li>
<li><code>Sort Compare</code>로 비교 후 정렬값들을 가지고 문자열끼리 append시켜주었으면 쉽게 해결하였을 문제였습니다.</li>
<li>compare 함수 기본 형식(기본적으로 오름차순을 적용시킵니다.) 굳이 if문을 쓰지 않고 바로 return s1 &gt; s2형식으로 해주어도 됩니다.</li>
</ul>
<hr />
<h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2>
<h3 id="1-dfs풀이시간초과"><a class="markdownIt-Anchor" href="#1-dfs풀이시간초과"></a> 1. DFS풀이(시간초과)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  가장큰수.cpp</span></span><br><span class="line"><span class="comment">//  algorithm-level-up</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by kgh on 14/11/2019.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 kgh. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100001</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value_v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(b.<span class="built_in">size</span>() &gt; a.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> b &gt; a;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b &lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//len개를 모두 선택하였을 경우</span></span><br><span class="line">    <span class="keyword">if</span>(idx == len)&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            str += to_string(value_v[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> comp = atoi(str.c_str());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(comp &gt; ans)&#123;</span><br><span class="line">            ans = comp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check[i] = <span class="literal">true</span>;</span><br><span class="line">        value_v.push_back(v[i]);</span><br><span class="line">        dfs(idx+<span class="number">1</span>, v, len);</span><br><span class="line">        value_v.pop_back();</span><br><span class="line">        check[i] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">    s.push_back(<span class="string">"3"</span>); s.push_back(<span class="string">"30"</span>); s.push_back(<span class="string">"34"</span>);s.push_back(<span class="string">"5"</span>);s.push_back(<span class="string">"9"</span>);</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(len);</span><br><span class="line">    sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), compare);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        v[i] = atoi(s[i].c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,v,len);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; to_string(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-정렬-비교시간초과-x-정답"><a class="markdownIt-Anchor" href="#string-정렬-비교시간초과-x-정답"></a> String 정렬 비교(시간초과 X 정답)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 + s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 + s1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s1 + s2 &gt; s2 + s1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">    numbers.push_back(<span class="number">3</span>); numbers.push_back(<span class="number">30</span>); numbers.push_back(<span class="number">34</span>);numbers.push_back(<span class="number">5</span>);numbers.push_back(<span class="number">9</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numbers_len = numbers.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers_len; i++)&#123;</span><br><span class="line">        s.push_back(to_string(numbers[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="keyword">int</span> s_len = s.<span class="built_in">size</span>();</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s_len; i++)&#123;</span><br><span class="line">          ans += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>유사문제: <a href="https://www.acmicpc.net/problem/1422" target="_blank" rel="noopener">백준 1422 숫자의 신</a></p>
</blockquote>
]]></content>
      <categories>
        <category>알고리즘</category>
      </categories>
      <tags>
        <tag>프로그래머스</tag>
        <tag>알고리즘</tag>
        <tag>레벨2</tag>
      </tags>
  </entry>
  <entry>
    <title>프로그래머스 H-index</title>
    <url>/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4H-INDEX/</url>
    <content><![CDATA[<h2 id="프로그래머스-h-index-문제"><a class="markdownIt-Anchor" href="#프로그래머스-h-index-문제"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42747" target="_blank" rel="noopener">프로그래머스 H-index 문제</a></h2>
<h2 id="컴퓨팅적-스킬"><a class="markdownIt-Anchor" href="#컴퓨팅적-스킬"></a> 컴퓨팅적 스킬</h2>
<ul>
<li>정렬문제인 만큼 <code>#include &lt;algorithm&gt; 헤더에 있는 sort를 이용하면 됩니다.</code></li>
<li>sort는 기본적으로 오름차순 정렬로 되어있습니다. 별 다른 옵션을 주지 않아도 오름차순 정렬을 하게 됩니다. 그 외 <code>내림차순정렬</code>을 이용 할 때는 다음과 같은 두가지 방법을 사용할 수 있습니다.</li>
</ul>
<blockquote>
<p>1.compare함수를 이용한 내림차순 방법</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool compare(int v1,int v2)&#123;</span><br><span class="line">    return v1 &lt; v2;</span><br><span class="line">&#125;</span><br><span class="line">sort(citations.begin(),citations.end(),compare);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>greater<int>() 함수 옵션을 사용한 내림차순 정렬</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort(citations.begin(),citations.end(),greater&lt;int&gt;());</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="컴퓨팅적-사고"><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2>
<ul>
<li><code>H-index</code>의 개념을 알고가셔야 합니다. 논문 n편중 h번이상 인용된 논문이 h편이상이고 h번 이하 인용되었다면 h가 H-index가 됩니다.</li>
<li>첫번째 <code>테스트 케이스인 [3,0,6,1,5]</code>로 예를 들어 설명하겠습니다.</li>
</ul>
<blockquote>
<p>오름차순 정렬 전</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">DATA</th>
<th style="text-align:left">INDEX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">4</td>
</tr>
</tbody>
</table>
<hr />
<blockquote>
<p>오름차순 정렬 후</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">DATA</th>
<th style="text-align:left">INDEX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">4</td>
</tr>
</tbody>
</table>
<hr />
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<ul>
<li>정렬전과 정렬후의 과정입니다.<code>H-index</code>라는것을 맨처음에 모든 값의 합을 나눈 평균의 값이 H-Index라고 생각을 하여 아주 단순하게 생각했습니다. 당연히 틀린것이였습니다.</li>
<li><em>index</em>를 가지고 생각했어야 했는데, 값을 가지고 생각을 하였습니다. 위의 테스트케이스는 총 5편의 논문이 쓰여졌으며  <code>인덱스값이 DATA의 값보다 커지는 시점</code> <code>index &gt; data</code>을 찾아야 합니다. 그 시점이 H-index지점입니다.데이터값은 뒤에서부터 비교하고 인덱스값은 앞에서 비교하게 됩니다. 따라서 citations.size()-i-1의 형식이 나오게됩니다. -1을 해주는이유는 for문에서는citiation-1지점까지만 순회하기때문에 이에 따라 -1을 붙여준것입니다. 어디서부터 시작하고 어디서부터 끝내는지에 대해서 한번더 고민해보시면 되겠습니다.</li>
<li>Data = 5, Index = 3의 지점이 H-index에 해당하는값 입니다. <code>index&gt;data</code>의 지점에 index는 3의 값을 반환하게 됩니다. 이 값은 결국 h-index의 값을 나타내는것이며 <code>총 5편의 논문과 3회이상의 인용된 논문 3편, 3회 이하 인용된 논문 2편</code>이 되게 됩니다. 따라서 h-index의 값을 정확하게 도출해냈다고 할 수 있습니다.</li>
<li>문제들을 너무 어렵게 생각하여 풀었는데, <code>index</code>에 대해 유연하게 접근하면 쉽게 풀 수 있었던 문제라고 생각합니다.</li>
</ul>
<hr />
<h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2>
<h3 id="1-정렬-풀이"><a class="markdownIt-Anchor" href="#1-정렬-풀이"></a> 1. 정렬 풀이</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 오름차순 정렬, 내림차순은 그 반대 v1 &gt; v2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &lt; v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; citations;</span><br><span class="line">    citations.push_back(<span class="number">3</span>);</span><br><span class="line">    citations.push_back(<span class="number">0</span>);</span><br><span class="line">    citations.push_back(<span class="number">6</span>);</span><br><span class="line">    citations.push_back(<span class="number">1</span>);</span><br><span class="line">    citations.push_back(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    sort(citations.<span class="built_in">begin</span>(),citations.<span class="built_in">end</span>(),compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;citations.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= citations[citations.<span class="built_in">size</span>()-i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>알고리즘</category>
      </categories>
      <tags>
        <tag>프로그래머스</tag>
        <tag>알고리즘</tag>
        <tag>레벨2</tag>
        <tag>H-INDEX</tag>
        <tag>정렬</tag>
      </tags>
  </entry>
  <entry>
    <title>프로그래머스 위장</title>
    <url>/2019/11/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%9C%84%EC%9E%A5/</url>
    <content><![CDATA[<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42578" target="_blank" rel="noopener">프로그래머스 위장문제</a></p>
<hr />
<h2 id="컴퓨팅적-스킬"><a class="markdownIt-Anchor" href="#컴퓨팅적-스킬"></a> 컴퓨팅적 스킬</h2>
<ul>
<li>
<p>옷 종류 = KEY, 옷 이름= VALUE를 두고 문제를 해결해야 한다고 생각하였습니다.</p>
</li>
<li>
<p><strong>#include&lt;unordered_map&gt;</strong> 헤더에 포함된 <strong>unordered_map&lt;string,int&gt;</strong> 형태로 사용하려고 하였습니다.</p>
<ul>
<li>unordered와 map중 unordered 자료구조를 사용한 이유는 map은 balanced tree의 형태를 가지고 있고, unordered_map는 hash형태로 이루어져있기 때문에 성능차이의 이슈로 특별한 이유가 없는 한 unordered_map을 사용하려고 합니다.</li>
<li>주어진 파라미터 <em>vector&lt;vector<string>&gt; clothes;</em> 의 형태가 주어졌는데요. 헷갈리는 부분이 있어서 설명하고 넘어가겠습니다. <em>vector&lt;vector<string></em>  2차원 벡터는 2차원 배열과 형태가 같습니다.</li>
<li>그리고, 2차원 벡터에 값을 넣게 될경우 주의해야할 점이 한가지 있습니다. 직접 접근해서 벡터값을 넣지 못하게 되어있다는것입니다. <em>clothes[0].push_back(“yellow_hat”)</em> 처럼 값을 넣으려고 하였지만, Xcode에서 <em>Invalid operands to binary expression</em> 에러가 나타났습니다. 직접적으로 2차원벡터에 값을 바로 접근하기가 불가능한 모양입니다. 그래서 1차원 벡터를 생성시킨 후 값을 넣어준 다음, 2차원 벡터에 값이 들어간 벡터를 넣었습니다. <s>프로그래머스에서 테스트케이스로 바로 Input을 주기 때문에 이러한 과정이 필요없지만, 직접 소스코드를 Xcode에 작성하면서 디버깅도 해보는편이라 저런형식으로 넣어주게 되었습니다.</s></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; clothes;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v1.push_back(<span class="string">"yellow_hat"</span>); v1.push_back(<span class="string">"headgear"</span>);</span><br><span class="line">v2.push_back(<span class="string">"blue_sunglasses"</span>); v2.push_back(<span class="string">"eyewear"</span>);</span><br><span class="line">v3.push_back(<span class="string">"green_turban"</span>); v3.push_back(<span class="string">"headgear"</span>);</span><br><span class="line">clothes.push_back(v1);</span><br><span class="line">clothes.push_back(v2);</span><br><span class="line">clothes.push_back(v3);</span><br></pre></td></tr></table></figure>
<ul>
<li>1차원 행부분에서 열부분을 참고하시면 모든값들을 가져올 수 있겠습니다. 그리고, auto를 사용하셔서 값들을 가져올 수도 있습니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>아래와 같은 3가지 형식으로 사용하시면 됩니다.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clothes.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    m[clothes[i][<span class="number">1</span>]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p : clothes)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; p.at(<span class="number">0</span>);</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt; p[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s : clothes)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>map에 있는 값들을 모두 확인하기 위해서는<strong>iterator</strong> 를 사용하셔야 합니다. 사용하실 방식은 다음과 같습니다. map과 map::iterator를 선언시켜줍니다. 그리고 iter 변수를 사용해서 unordered_map에 있는 모든 값들을 탐색을 시작하게 됩니다. iter-&gt;first, iter-&gt;second로 참조하여 접근하게 되면 해당 맵의 &lt;string,int&gt;형태로 저장된 값을 가져올 수 있습니다.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter=m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">    answer *= (iter-&gt;second+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–</p>
<h2 id="컴퓨팅적-사고"><a class="markdownIt-Anchor" href="#컴퓨팅적-사고"></a> 컴퓨팅적 사고</h2>
<ul>
<li>
<p>첫번째 테스트 케이스를 예시로 설명해보겠습니다. [headergear, eyewear] 의 두가지 종류가 있습니다. headgear를 입거나 안입는 경우 headgear = 2가지 경우, eyewear를 입거나 안입는 경우 1가지 경우입니다. 이것을 경우의 수로 적용시켜보겠습니다. (headgear +1)* (eyewear + 1)로 적용시키면 (2+1) * (1+1) = 6 - 1 = 5가지가 됩니다.</p>
<ul>
<li>이때 +1을 왜 더하는거야? 라고 생각하실분이 있으실 것입니다. 그 이유는 의상을 입을까? 말까? 라는 경우를 고려해주어야하기 때문입니다. 그래서 +1을 해주게 되는것입니다.</li>
<li>마지막에 -1은 또 왜해주나요? 적어도 하나의 의상을 입어야하므로 모두 입지않는 경우의 수인 1가지 경우를 빼주어야 결국 모든 경우의 수의 조합이 나오게 될 것입니다.</li>
</ul>
</li>
<li>
<p>모든 원소는 문자열로 이루어져있고, clothes는 [의상의 이름, 의상의 종류]의 형태를 가지고 있다. 따라서 해시 자료구조형을 사용해서 접근하면 된다. 처음에는 조합개념으로 dfs를 진행하려고 하였지만, 선택한 개수가 매번달라지는 경우때문에 dfs를 사용하지 않았습니다.</p>
</li>
</ul>
<hr />
<h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2>
<hr />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  위장문제.cpp</span></span><br><span class="line"><span class="comment">//  algorithm-level-up</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by kgh on 15/11/2019.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 kgh. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; clothes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v3;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    v1.push_back(<span class="string">"yellow_hat"</span>); v1.push_back(<span class="string">"headgear"</span>);</span><br><span class="line">    v2.push_back(<span class="string">"blue_sunglasses"</span>); v2.push_back(<span class="string">"eyewear"</span>);</span><br><span class="line">    v3.push_back(<span class="string">"green_turban"</span>); v3.push_back(<span class="string">"headgear"</span>);</span><br><span class="line">    clothes.push_back(v1);</span><br><span class="line">    clothes.push_back(v2);</span><br><span class="line">    clothes.push_back(v3);</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clothes.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        m[clothes[i][<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        answer *= (iter-&gt;second+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; answer<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>알고리즘</category>
      </categories>
      <tags>
        <tag>프로그래머스</tag>
        <tag>알고리즘</tag>
        <tag>위장</tag>
        <tag>레벨2</tag>
        <tag>해시</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 명령어</title>
    <url>/2019/11/10/hexo-%20command/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="front-formatter"><a class="markdownIt-Anchor" href="#front-formatter"></a> front formatter</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post.md 머리말</span></span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- 태그명 #(예) 헥소</span><br><span class="line">- 깃허브</span><br><span class="line"></span><br><span class="line"># 또는 아래와 같이 사용 할수 있다.</span><br><span class="line">tags: [헥소, 깃허브]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 카테고리명 #(예) 깃허브</span><br><span class="line">- 서브카테고리명 #(예) 헥소</span><br><span class="line"></span><br><span class="line"># 또는 아래 처럼 사용 할수 있다.</span><br><span class="line">categories: [깃허브, 헥소]</span><br></pre></td></tr></table></figure>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new post <span class="string">"My New Post"</span></span><br><span class="line">$ hexo new draft <span class="string">"My new Draft"</span></span><br><span class="line">$ hexo new layout <span class="string">"My New layout"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server post</span><br><span class="line">$ hexo server draft</span><br><span class="line">$ hexo server layout</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="generate-static-files-and-deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#generate-static-files-and-deploy-to-remote-sites"></a> Generate static files and Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>
<h3 id="image-files-path"><a class="markdownIt-Anchor" href="#image-files-path"></a> image files path</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source/images/image file path</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>command</tag>
      </tags>
  </entry>
</search>
