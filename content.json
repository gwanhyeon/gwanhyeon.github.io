{"meta":{"title":"KGH IT LOG","subtitle":"KGH IT LOG","description":"#BACK-END #SPRING #ALGORITHM","author":"Gwan-Hyeon Kim","url":"http://gwanhyeon.github.io.com","root":"/"},"pages":[{"title":"KGH IT Blog","date":"2019-11-04T17:19:11.000Z","updated":"2019-11-15T14:24:04.489Z","comments":true,"path":"about.html","permalink":"http://gwanhyeon.github.io.com/about.html","excerpt":"","text":"블로그 이전 작업중입니다. Tistory Github"}],"posts":[{"title":"이진탐색트리 BST","slug":"bst","date":"2019-11-22T16:21:08.000Z","updated":"2019-11-22T17:00:30.050Z","comments":true,"path":"2019/11/23/bst/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/23/bst/","excerpt":"","text":"검색트리 Search Tree 계층적인 구조를 표현 조직도 디렉토리와 서브디렉토리 구조 가계도 트리의 특징 트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됩니다. 맨 위의 노드를 &quot;루트(root)&quot;라고 부릅니다. 노드를 연결하는 선을 &quot;link&quot;, &quot;edge&quot;,&quot;branch&quot; 부모노드 자식노드로 구성되어있습니다. 루트노드를 제외한 트리의 모든 노드들은 유일한 부모노드를 갖습니다. 부모가 동일한 노드들을 형제 &quot;sibling&quot;관계라고 부릅니다. 자식이 없는 노드들을 &quot;leaf&quot;노드라고 부릅니다. “leaf” 노드가 아닌것 내부 노드라고 부릅니다. 조상-자손 관계가 있다. 부모-자식관계를 확장한것 (ancestor-descendant) 관계 루트는 레벨관계 Level 0 ~ Level N 까지 갖습니다. 트리의 기본적인 성질 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가집니다. 트리에서 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간의 경로도 유일(존재,1개)합니다.(단, 같은 노드를 두 번 이상 방문하지 않는다) 트리의 높이는 레벨의 개수입니다. 이진 트리 Binary Tree 특징 이진 트리에서 각 노드는 최대 2개의 자식을 가집니다. 각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정됩니다.(자식이 한 명인 경우에도) 서로 다른 이진트리는 값의 위치가 다르면 서로 다른 이진트리라고 불리온다. (자식노드가 한개인 경우에도 해당됩니다) 이진트리의 응용 Expression Tree, Huffman Code (x+y) * ((a + b) / c) 를 이진 트리형태로 나타낼 수 있다. Expression트리에서 응용한다. 허프만 코드 ‘A’ - ‘Z’, ‘a’ - ‘z’ 파일들의 알파벳을 어떤 데이터를 압축하는 것을 뜻한다. 파일의 길이가 최소가 되도록 하는 알고리즘(파일 압축) Full Binary Trees And Complete Binary Trees Full Binary Trees 모든 레벨에서 노드에 채워져 있는 경우 Completr Binary Trees 맨 마지막경우에는 노드가 없을 수 있다.(단, 끝에서부터 노드가 없을 수 있다.) 높이가 h인 full binary tree는 2^h-1개의 노드를 가진다. 노드가 N개인 full 혹은 complete 이진 트리의 높이는 O(logN)이다.(노드가 N개인 이진트리의 높이는 최악의 경우 N이 될 수 있다.) 이진트리의 표현 Heap은 Complete Binary Tree이다. 연결 구조 표현 각 노드에 하나에의 데이터필드와 왼쪽자식(left), 오른쪽 자식(right),그리고 부모노드§의 주소를 저장 부모노드는 주소는 반드시 필요한 경우가 아니면 보통 생략함 이진트리의 순회(Traversal) 순회: 이진 트리의 모든 노드를 방문하는 일 중순위(inorder) 순회 왼쪽자식기준으로 루트노드를 중간에 방문한다. 왼쪽 자식 노드-&gt;루트-&gt;오른쪽 자식 노드 123pre-order-tree-walk(left[x])print key[x]pre-order-tree-wal(right[x]) 선순위(preorder) 순회 왼쪽자식기준으로 루트노드를 처음에 방문한다. 루트 노드-&gt;왼쪽 자식 노드-&gt;오른쪽 자식 노드 123print key[x]pre-order-tree-walk(left[x])pre-order-tree-wal(right[x]) 후순위(postorder) 순회 왼쪽기준으로 루트노드를 마지막에 방문한다. 왼쪽 자식 노드-&gt;루트 노드-&gt;중간 자식 노드 123pre-order-tree-walk(left[x])pre-order-tree-wal(right[x])print key[x] 레벨오더(level-order) 순회 레벨 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로 방문합니다. 큐(queue)를 이용하여 구현 트리에 [1,2,3,4,5,6,7]이 순서대로 있다고하면 레벨별로 하나씩 방문한다(단, 기준은 왼쪽) Level 0: 1 Level 1: 2,3 Level 2: 4,5,6,7 해당 순서로 방문한다고 생각하면 됩니다. 이진탐색트리 inary Search Tree","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"검색트리","slug":"검색트리","permalink":"http://gwanhyeon.github.io.com/tags/%EA%B2%80%EC%83%89%ED%8A%B8%EB%A6%AC/"},{"name":"이진탐색트리","slug":"이진탐색트리","permalink":"http://gwanhyeon.github.io.com/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC/"},{"name":"BST","slug":"bst","permalink":"http://gwanhyeon.github.io.com/tags/bst/"}]},{"title":"N-Queen 문제","slug":"n-queen","date":"2019-11-22T15:02:37.000Z","updated":"2019-11-22T16:03:46.307Z","comments":true,"path":"2019/11/23/n-queen/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/23/n-queen/","excerpt":"","text":"N-Queen문제 컴퓨팅적 스킬 Recursive() 재귀함수 어느지점에서 종료시키고, 다시 재귀호출을 해야하는지의개념을 확실하게 알고 있어야합니다. Recursive()의 개념을 잡기에 좋은 문제는 백준 N과 M시리즈 입니다. 개념이 약하신분들은 순열과 조합의 개념부터 확실히 잡고 오시는것이 좋을 것이라고 생각을 합니다. 백트래킹 깊이우선탐색(DFS)의 개념을 알아야합니다. 깊이우선탐색은 보통 Recursive, Stack를 사용합니다. Recursive가 직관적이고 코드이해하기도 쉽고, 스택보다는 구현이 덜 복잡하다는 장점이 있어서 Recursive로 구현하겠습니다. 컴퓨팅적 사고 깊이우선탐색(DFS) 진행한 Level과 모든 말을 놓는 경우의 수가 같을때 재귀호출을 종료해야합니다. NNN … N^N의 시간복잡도를 갖습니다. 백트래킹의 개념에 대해 알고 있어야 한다. 깊이우선탐색의 트리형태로 어떻게 진행하는지 직접 손으로 써보면서 진행해야합니다. 상태공간트리의 개념을 알고 있어야합니다. 상태공간트리란 찾는 해를 포함하는 트리이며 이트리안에 어떠한 노드에 해당하는 이 트리를 체계적으로 탐색하면서 반드시 해를 찾을 수 있어야합니다. 해당 퀸이 열 있는지 체크와 대각선을 체크해야합니다. 예를 들어 설명하겠습니다. 12345start에서 시작하면서 트리의 형태로 가지를 치면서 진행합니다. start-&gt; (0,0) (0,1) (0,2) (0,3) 첫번째 열에서 갈수 있는 모든 경우의 수입니다.(1,0) (1,1) (1,2) .... 두번째 열에서 갈 수 있는 경우의 수(level, 1) (level, 2) (level, 3) Level 크기에서 갈 수 있는 경우의 수 0 1 2 3 Level 0 (0,0) (0,1) (0,2) (0,3) Level 1 (1,0) (1,1) (1,2) (1,3) Level 2 (2,0) (2,1) (2,2) (2,3) Level 3 (3,0) (3,1) (3,2) (3,3) 다음의 상황은 Level 0 ~ Level N 의 경우까지 진행하는 경우라고 생각하겠습니다. Level0의 경우에서 갈 수 있는 모든경우를 탐색하면서 퀸을 놓습니다. 그리고 다음 Level1으로 진행하면서 열에 들어갈 수 있는 경우를 확인하면서 진행합니다. 이때 알아야 하는 부분이 Promissing의 개념입니다. 즉,Level0 (0,0)에 퀸을 놓으면 Level1 (1,0)에 퀸을 놓는 경우를 확인해보겠습니다. 퀸을 놓을 수 있는 조건은 동, 서, 남, 북, 대각선에 퀸이 위치해있으면 놓을 수 없습니다. 그러면 당연히 (1,0)은 확인할 필요도 없이 놓을 수 없는 경우의 수라는것입니다. 이것을 Promissing의 개념을 확인하여 더 갈 수 있는지 없는지를 판단하는 것입니다. 체크한다고 하시면 됩니다. 레벨의 수가 결국 말의 개수를 뜻합니다. 제 코드에서는 cols라는 배열이 쓰이는데 이것은 현재 말이 어디에 놓였는지에 대한 위치입니다. cols[1] : 1번말이 놓인 열 , cols[2] : 2번말이 놓인 열 … cols[i] = j (i번말이 j에 놓였다는 의미입니다. i는 결국 레벨입니다.) Promissing Test를 진행할 때 마지막에 놓인 이 말이 이전에 놓인 다른 말들과 충돌하는지 검사를 하면 퀸을 놓을수 있는지 없는지를 확인 할 수 있습니다. Recursive 설계 promising()함수를 호출합니다. 진행이 가능한지 여부를 확인하고 아니면 false, 가능하면 true를 리턴합니다. 1234// 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다. if(!promissing(level,N))&#123; return false; &#125; Level과 N의 값이 같은 경우(성공한 경우) 12345// 성공적으로 도착하였을 경우 else if(level == N)&#123; // 기존의 N-queen의 위치를 구하면 종료하는 형식이였지만, 모든 경우의 수를 구하기 위해서는 해당 cnt값을 증가시켜주어서 확인할 수 있다. cnt+=1; &#125; Level과 N의 값이 같지 않은 경우 Recursive() 재귀 함수 호출 1234567for(int i=1; i&lt;=N; i++)&#123; cols[level+1] = i; // 다음 레벨로 재귀 호출 if(recursive(level+1,N))&#123; return true; &#125; &#125; Promising Test 설계 같은 열을 확인하여야합니다. 1234// 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미)) if(cols[i] == cols[level])&#123; return false; &#125; 같은 대각선에 놓였는지를 확인하여야 합니다. 1234// 대각선에 충돌되는것 확인 else if((level-i) == abs(cols[level] - cols[i]))&#123; return false; &#125; 풀이 1. DFS 백트래킹 해당 값 찾기(기본 개념) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// n-queen.cpp// algorithm-level-up//// Created by kgh on 22/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cols[10001];int cnt = 0;bool promissing(int level,int N)&#123; for(int i=1; i&lt;level; i++)&#123; // 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미)) if(cols[i] == cols[level])&#123; return false; &#125; // 대각선에 충돌되는것 확인 else if((level-i) == abs(cols[level] - cols[i]))&#123; return false; &#125; &#125; return true;&#125;bool recursive(int level,int N)&#123; // 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다. if(!promissing(level,N))&#123; return false; &#125; // 성공적으로 도착하였을 경우 else if(level == N)&#123; for(int i=1; i&lt;=N; i++)&#123; cout &lt;&lt; \"(\" &lt;&lt; i &lt;&lt; \",\" &lt;&lt; cols[i] &lt;&lt; \")\"; &#125; return true; &#125; for(int i=1; i&lt;=N; i++)&#123; cols[level+1] = i; // 성공할 경우 if(recursive(level+1,N))&#123; return true; &#125; &#125; return false;&#125;int main(void)&#123; int N = 8; recursive(0,N); cout &lt;&lt; cnt; return 0;&#125; 2. DFS 백트래킹 해당 값 찾기(경우의 수 찾기 백준 문제) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//// n-queen.cpp// algorithm-level-up//// Created by kgh on 22/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cols[10001];int cnt = 0;bool promissing(int level,int N)&#123; for(int i=1; i&lt;level; i++)&#123; // 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미)) if(cols[i] == cols[level])&#123; return false; &#125; // 대각선에 충돌되는것 확인 else if((level-i) == abs(cols[level] - cols[i]))&#123; return false; &#125; &#125; return true;&#125;bool recursive(int level,int N)&#123; // 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다. if(!promissing(level,N))&#123; return false; &#125; // 성공적으로 도착하였을 경우 else if(level == N)&#123; // 기존의 N-queen의 위치를 구하면 종료하는 형식이였지만, 모든 경우의 수를 구하기 위해서는 해당 cnt값을 증가시켜주어서 확인할 수 있다. cnt+=1; &#125; for(int i=1; i&lt;=N; i++)&#123; cols[level+1] = i; // 성공할 경우 if(recursive(level+1,N))&#123; return true; &#125; &#125; return false;&#125;int main(void)&#123; int N; cin &gt;&gt; N; recursive(0,N); cout &lt;&lt; cnt; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io.com/tags/%EB%B0%B1%EC%A4%80/"},{"name":"DFS","slug":"dfs","permalink":"http://gwanhyeon.github.io.com/tags/dfs/"},{"name":"백트래킹","slug":"백트래킹","permalink":"http://gwanhyeon.github.io.com/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"}]},{"title":"프로그래머스 더 맵게","slug":"프로그래머스더맵게","date":"2019-11-20T14:47:05.000Z","updated":"2019-11-20T15:12:00.598Z","comments":true,"path":"2019/11/20/프로그래머스더맵게/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/20/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EB%8D%94%EB%A7%B5%EA%B2%8C/","excerpt":"","text":"프로그래머스 더 맵게 문제 컴퓨팅적 스킬 이번 문제를 해결하기 위해서는 단순 sort를 사용하는것이 아니라 우선순위큐 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; 오름차순 형식으로 써주어야합니다. 단순히 while문을 통해서 안에서 sort를 처리하려고 하였지만 16번 테스트케이스를 통과하지 못하였고 효율성에서는 시간초과가 발생하였습니다. 또한, 범위값이 너무 제한적이였다. 그래서 우선순위큐를 사용하였습니다. 123scoville의 길이는 1 이상 1,000,000 이하입니다.K는 0 이상 1,000,000,000 이하입니다.scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 주의해야할점은 우선순위큐 push는 맨앞으로 들어간다는것과 top에 있는것도 0번째 인덱스에 있는 값입니다. 컴퓨팅적 사고 스코빌 벡터에 있는 값을 우선순위큐에 넣어준다. greater&lt;int&gt;를 옵션으로 지정하였기 때문에 자동으로 오름차순으로 정렬해줍니다. 만약 내림차순으로 하고 싶은경우 less옵션을 사용하시면 됩니다. 첫번째, 두번째값을 통하여 스코빌 지수를 구합니다. 단 q.top()의 값이 K보다 작아야합니다. 반복문 조건 12345예시스코빌 1 2 3 9 10일경우 (1 + 2 * 2) 5 3 9 10 으로 변경됩니다. 우선순위큐 이므로 3 5 9 10 정렬됩니다.(3 + 5 * 2) 13 9 10 으로 변경됩니다. 우선순위큐 이므로 9 10 13 정렬됩니다....... 기존의 while문에서는 sort를 다시해주어야하는데 우선순위 큐가 자동으로 정렬시켜주기때문에 필요없는 과정입니다. 만약 우선순위큐의 사이즈가 2이하가 되면 더이상 구할 수 없으므로 Return -1을 실행합니다. 그게 아니라면 계속 진행하고 q.top()의 값이 K보다 큰 경우가 있으면 더이상 반복문을 반복하지 않습니다. 풀이 1. 일반적인 sort 풀이(시간초과) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// 더맵게 일반 정렬.cpp// algorithm-level-up//// Created by kgh on 20/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main(void)&#123; vector&lt;int&gt; scoville; scoville.push_back(3); scoville.push_back(9); scoville.push_back(10); scoville.push_back(12); int K=7; int cnt = 0; int answer = 0; int len = scoville.size(); while(true)&#123; sort(scoville.begin(),scoville.end()); // 스코빌 첫번째 값이 K보다 작아야하고, cnt 값이 해당 스코빌 사이즈값이전까지 돌아아한다, 그리고 스코빌 사이즈는 2보다 커야한다. 아니면 -&gt; 메모리 에러남 if(scoville[0] &lt; K &amp;&amp; cnt &lt; len &amp;&amp; scoville.size() &gt; 2)&#123; int new_scoville=0; new_scoville = scoville[0] + (scoville[1] * 2); scoville[0] = new_scoville; scoville.erase(scoville.begin()+1); cnt+=1; &#125;else &#123; // 스코빌 첫번째지수가 K보다 작으면 결국 모든것이 되지않았으니까 cnt = 0; if(scoville[0] &lt; K)&#123; cnt = 0; &#125; break; &#125; &#125; if(cnt == 0)&#123; answer = -1; cout &lt;&lt; answer; &#125;else &#123; answer = cnt; cout &lt;&lt; answer; &#125; return 0;&#125; 우선순위큐 사용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// 더맵게 우선순위큐.cpp// algorithm-level-up//// Created by kgh on 20/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main(void)&#123; vector&lt;int&gt; scoville; scoville.push_back(1); scoville.push_back(2); scoville.push_back(3); scoville.push_back(9); scoville.push_back(10); scoville.push_back(12); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q; int K = 7; for(int i=0; i&lt;scoville.size(); i++)&#123; q.push(scoville[i]); &#125; int min_num_first = 0; int min_num_second = 0; int res = 0; int cnt = 0; while(q.top() &lt; K)&#123; if(q.size() &lt; 2)&#123; return -1; &#125; min_num_first = q.top(); q.pop(); min_num_second = q.top(); q.pop(); res = min_num_first + (min_num_second * 2); q.push(res); cnt += 1; &#125; cout &lt;&lt; cnt;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io.com/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io.com/tags/%EB%A0%88%EB%B2%A82/"},{"name":"우선순위큐","slug":"우선순위큐","permalink":"http://gwanhyeon.github.io.com/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/"}]},{"title":"프로그래머스 가장 큰 수","slug":"프로그래머스큰수","date":"2019-11-16T00:14:41.000Z","updated":"2019-11-16T01:29:22.039Z","comments":true,"path":"2019/11/16/프로그래머스큰수/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%ED%81%B0%EC%88%98/","excerpt":"","text":"프로그래머스 가장 큰 수 문제 컴퓨팅적 스킬 0 또는 양의 정수 1 &lt;= numbers_length &lt;= 100,000, 0 &lt;= numbers &lt;= 1000 를 보고 O(N^2) 복잡도 불가할 것이라 예측하였습니다. 왜냐하면 (100,000)^ = 약 100억 String to int 변환 함수 atoi(str.c_str()), int to String 변환함수 to_string(number) “String&quot; - ‘0’ =&gt; 숫자로 변경이 가능합니다. 단, 범위는 0~9까지 Number + ‘0’ =&gt; 문자로 변경이 가능합니다. 단, 범위는 0~9까지 숫자가 10이 나왔을 경우에는 dec = dec * 10 + str[i] - '0'의 형식으로 해주어야합니다. 유사문제로는 카카오 셔틀버스 문제가 있습니다. 1234567891011bool compare(const string &amp;s1, const string &amp;s2)&#123; return s1 + s2 &gt; s2 + s1 ? true : false;&#125;bool compare(const string &amp;s1, const string &amp;s2)&#123; if(s1 &gt; s2)&#123; return true; &#125;else &#123; return false; &#125;&#125; 컴퓨팅적 사고 string기준으로 문제를 해결해야한다. 맨 처음 순열과 같이 DFS로 완전탐색을 하였지만 시간초과 가 나서 sort()함수 사용해봤지만 테스트케이스는 맞지만 시간초과는 그대로여서 시간복잡도에 고민을 한번 더 하였습니다. Sort Compare로 비교 후 정렬값들을 가지고 문자열끼리 append시켜주었으면 쉽게 해결하였을 문제였습니다. compare 함수 기본 형식(기본적으로 오름차순을 적용시킵니다.) 굳이 if문을 쓰지 않고 바로 return s1 &gt; s2형식으로 해주어도 됩니다. 풀이 1. DFS풀이(시간초과) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 가장큰수.cpp// algorithm-level-up//// Created by kgh on 14/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;bool check[100001];int ans = 0;int arr[100001];vector&lt;int&gt; value_v;bool compare(const string &amp;a, const string b)&#123; if(b.size() &gt; a.size())&#123; return b &gt; a; &#125;else &#123; return b &lt; a; &#125; &#125;void dfs(int idx,vector&lt;int&gt; v,int len)&#123; //len개를 모두 선택하였을 경우 if(idx == len)&#123; string str = \"\"; for(int i=0; i&lt;len; i++)&#123; str += to_string(value_v[i]); &#125; int comp = atoi(str.c_str()); if(comp &gt; ans)&#123; ans = comp; &#125; return; &#125; for(int i=0; i&lt;len; i++)&#123; if(check[i])&#123; continue; &#125; check[i] = true; value_v.push_back(v[i]); dfs(idx+1, v, len); value_v.pop_back(); check[i] = false; &#125;&#125;int main(void)&#123; vector&lt;string&gt; s; s.push_back(\"3\"); s.push_back(\"30\"); s.push_back(\"34\");s.push_back(\"5\");s.push_back(\"9\"); int len = s.size(); vector&lt;int&gt; v(len); sort(s.begin(), s.end(), compare); for(int i=0; i&lt;s.size(); i++)&#123; v[i] = atoi(s[i].c_str()); &#125; dfs(0,v,len); cout &lt;&lt; to_string(ans); return 0; &#125; String 정렬 비교(시간초과 X 정답) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;bool compare(const string &amp;s1, const string &amp;s2)&#123; cout &lt;&lt; s1 + s2; cout &lt;&lt; s2 + s1 &lt;&lt; '\\n'; return s1 + s2 &gt; s2 + s1 ? true : false;&#125;int main(void)&#123; string ans = \"\"; vector&lt;int&gt; numbers; vector&lt;string&gt; s; numbers.push_back(3); numbers.push_back(30); numbers.push_back(34);numbers.push_back(5);numbers.push_back(9); int numbers_len = numbers.size(); for(int i=0; i&lt;numbers_len; i++)&#123; s.push_back(to_string(numbers[i])); &#125; sort(s.begin(), s.end(), compare); int s_len = s.size(); for(int i=0; i&lt;s_len; i++)&#123; ans += s[i]; &#125; if(ans[0] == '0') return \"0\"; cout&lt;&lt; ans; return 0; &#125; 유사문제: 백준 1422 숫자의 신","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io.com/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io.com/tags/%EB%A0%88%EB%B2%A82/"}]},{"title":"프로그래머스 H-index","slug":"프로그래머스H-INDEX","date":"2019-11-15T23:11:02.000Z","updated":"2019-11-17T14:11:26.615Z","comments":true,"path":"2019/11/16/프로그래머스H-INDEX/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4H-INDEX/","excerpt":"","text":"프로그래머스 H-index 문제 컴퓨팅적 스킬 정렬문제인 만큼 #include &lt;algorithm&gt; 헤더에 있는 sort를 이용하면 됩니다. sort는 기본적으로 오름차순 정렬로 되어있습니다. 별 다른 옵션을 주지 않아도 오름차순 정렬을 하게 됩니다. 그 외 내림차순정렬을 이용 할 때는 다음과 같은 두가지 방법을 사용할 수 있습니다. 1.compare함수를 이용한 내림차순 방법 1234bool compare(int v1,int v2)&#123; return v1 &lt; v2;&#125;sort(citations.begin(),citations.end(),compare); greater() 함수 옵션을 사용한 내림차순 정렬 1sort(citations.begin(),citations.end(),greater&lt;int&gt;()); 컴퓨팅적 사고 H-index의 개념을 알고가셔야 합니다. 논문 n편중 h번이상 인용된 논문이 h편이상이고 h번 이하 인용되었다면 h가 H-index가 됩니다. 첫번째 테스트 케이스인 [3,0,6,1,5]로 예를 들어 설명하겠습니다. 오름차순 정렬 전 DATA INDEX 3 0 0 1 6 2 1 3 5 4 오름차순 정렬 후 DATA INDEX 0 0 1 1 3 2 5 3 6 4 정렬전과 정렬후의 과정입니다.H-index라는것을 맨처음에 모든 값의 합을 나눈 평균의 값이 H-Index라고 생각을 하여 아주 단순하게 생각했습니다. 당연히 틀린것이였습니다. index를 가지고 생각했어야 했는데, 값을 가지고 생각을 하였습니다. 위의 테스트케이스는 총 5편의 논문이 쓰여졌으며 인덱스값이 DATA의 값보다 커지는 시점 index &gt; data을 찾아야 합니다. 그 시점이 H-index지점입니다.데이터값은 뒤에서부터 비교하고 인덱스값은 앞에서 비교하게 됩니다. 따라서 citations.size()-i-1의 형식이 나오게됩니다. -1을 해주는이유는 for문에서는citiation-1지점까지만 순회하기때문에 이에 따라 -1을 붙여준것입니다. 어디서부터 시작하고 어디서부터 끝내는지에 대해서 한번더 고민해보시면 되겠습니다. Data = 5, Index = 3의 지점이 H-index에 해당하는값 입니다. index&gt;data의 지점에 index는 3의 값을 반환하게 됩니다. 이 값은 결국 h-index의 값을 나타내는것이며 총 5편의 논문과 3회이상의 인용된 논문 3편, 3회 이하 인용된 논문 2편이 되게 됩니다. 따라서 h-index의 값을 정확하게 도출해냈다고 할 수 있습니다. 문제들을 너무 어렵게 생각하여 풀었는데, index에 대해 유연하게 접근하면 쉽게 풀 수 있었던 문제라고 생각합니다. 풀이 1. 정렬 풀이 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 오름차순 정렬, 내림차순은 그 반대 v1 &gt; v2bool compare(int v1,int v2)&#123; return v1 &lt; v2;&#125;int main(void)&#123; vector&lt;int&gt; citations; citations.push_back(3); citations.push_back(0); citations.push_back(6); citations.push_back(1); citations.push_back(5); sort(citations.begin(),citations.end(),compare); for(int i=0; i&lt;citations.size(); i++)&#123; if(i &gt;= citations[citations.size()-i-1])&#123; cout &lt;&lt; i; break; &#125; &#125; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io.com/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io.com/tags/%EB%A0%88%EB%B2%A82/"},{"name":"H-INDEX","slug":"h-index","permalink":"http://gwanhyeon.github.io.com/tags/h-index/"},{"name":"정렬","slug":"정렬","permalink":"http://gwanhyeon.github.io.com/tags/%EC%A0%95%EB%A0%AC/"}]},{"title":"프로그래머스 위장","slug":"프로그래머스위장","date":"2019-11-15T11:02:11.000Z","updated":"2019-11-16T00:17:20.101Z","comments":true,"path":"2019/11/15/프로그래머스위장/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%9C%84%EC%9E%A5/","excerpt":"","text":"프로그래머스 위장문제 컴퓨팅적 스킬 옷 종류 = KEY, 옷 이름= VALUE를 두고 문제를 해결해야 한다고 생각하였습니다. #include&lt;unordered_map&gt; 헤더에 포함된 unordered_map&lt;string,int&gt; 형태로 사용하려고 하였습니다. unordered와 map중 unordered 자료구조를 사용한 이유는 map은 balanced tree의 형태를 가지고 있고, unordered_map는 hash형태로 이루어져있기 때문에 성능차이의 이슈로 특별한 이유가 없는 한 unordered_map을 사용하려고 합니다. 주어진 파라미터 vector&lt;vector&gt; clothes; 의 형태가 주어졌는데요. 헷갈리는 부분이 있어서 설명하고 넘어가겠습니다. vector&lt;vector 2차원 벡터는 2차원 배열과 형태가 같습니다. 그리고, 2차원 벡터에 값을 넣게 될경우 주의해야할 점이 한가지 있습니다. 직접 접근해서 벡터값을 넣지 못하게 되어있다는것입니다. clothes[0].push_back(“yellow_hat”) 처럼 값을 넣으려고 하였지만, Xcode에서 Invalid operands to binary expression 에러가 나타났습니다. 직접적으로 2차원벡터에 값을 바로 접근하기가 불가능한 모양입니다. 그래서 1차원 벡터를 생성시킨 후 값을 넣어준 다음, 2차원 벡터에 값이 들어간 벡터를 넣었습니다. 프로그래머스에서 테스트케이스로 바로 Input을 주기 때문에 이러한 과정이 필요없지만, 직접 소스코드를 Xcode에 작성하면서 디버깅도 해보는편이라 저런형식으로 넣어주게 되었습니다. 123456789101112vector&lt;vector&lt;string&gt;&gt; clothes;vector&lt;string&gt; v1;vector&lt;string&gt; v2;vector&lt;string&gt; v3;v1.push_back(\"yellow_hat\"); v1.push_back(\"headgear\");v2.push_back(\"blue_sunglasses\"); v2.push_back(\"eyewear\");v3.push_back(\"green_turban\"); v3.push_back(\"headgear\");clothes.push_back(v1);clothes.push_back(v2);clothes.push_back(v3); 1차원 행부분에서 열부분을 참고하시면 모든값들을 가져올 수 있겠습니다. 그리고, auto를 사용하셔서 값들을 가져올 수도 있습니다. 아래와 같은 3가지 형식으로 사용하시면 됩니다. 12345678910111213141516for(int i=0; i&lt;clothes.size(); i++)&#123; m[clothes[i][1]]++;&#125;or for(auto p : clothes)&#123; cout&lt;&lt; p.at(0); cout&lt;&lt; p[0];&#125;or for(vector&lt;string&gt; s : clothes)&#123; cout&lt;&lt; s[0];&#125; map에 있는 값들을 모두 확인하기 위해서는iterator 를 사용하셔야 합니다. 사용하실 방식은 다음과 같습니다. map과 map::iterator를 선언시켜줍니다. 그리고 iter 변수를 사용해서 unordered_map에 있는 모든 값들을 탐색을 시작하게 됩니다. iter-&gt;first, iter-&gt;second로 참조하여 접근하게 되면 해당 맵의 &lt;string,int&gt;형태로 저장된 값을 가져올 수 있습니다. 12345unordered_map&lt;string,int&gt; m;unordered_map&lt;string,int&gt;::iterator iter;for(iter=m.begin(); iter != m.end(); iter++)&#123; answer *= (iter-&gt;second+1);&#125; – 컴퓨팅적 사고 첫번째 테스트 케이스를 예시로 설명해보겠습니다. [headergear, eyewear] 의 두가지 종류가 있습니다. headgear를 입거나 안입는 경우 headgear = 2가지 경우, eyewear를 입거나 안입는 경우 1가지 경우입니다. 이것을 경우의 수로 적용시켜보겠습니다. (headgear +1)* (eyewear + 1)로 적용시키면 (2+1) * (1+1) = 6 - 1 = 5가지가 됩니다. 이때 +1을 왜 더하는거야? 라고 생각하실분이 있으실 것입니다. 그 이유는 의상을 입을까? 말까? 라는 경우를 고려해주어야하기 때문입니다. 그래서 +1을 해주게 되는것입니다. 마지막에 -1은 또 왜해주나요? 적어도 하나의 의상을 입어야하므로 모두 입지않는 경우의 수인 1가지 경우를 빼주어야 결국 모든 경우의 수의 조합이 나오게 될 것입니다. 모든 원소는 문자열로 이루어져있고, clothes는 [의상의 이름, 의상의 종류]의 형태를 가지고 있다. 따라서 해시 자료구조형을 사용해서 접근하면 된다. 처음에는 조합개념으로 dfs를 진행하려고 하였지만, 선택한 개수가 매번달라지는 경우때문에 dfs를 사용하지 않았습니다. 풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// 위장문제.cpp// algorithm-level-up//// Created by kgh on 15/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main(void)&#123; unordered_map&lt;string,int&gt; m; vector&lt;vector&lt;string&gt;&gt; clothes; vector&lt;string&gt; v1; vector&lt;string&gt; v2; vector&lt;string&gt; v3; v1.push_back(\"yellow_hat\"); v1.push_back(\"headgear\"); v2.push_back(\"blue_sunglasses\"); v2.push_back(\"eyewear\"); v3.push_back(\"green_turban\"); v3.push_back(\"headgear\"); clothes.push_back(v1); clothes.push_back(v2); clothes.push_back(v3); for(int i=0; i&lt;clothes.size(); i++)&#123; m[clothes[i][1]]++; &#125; int answer = 1; unordered_map&lt;string,int&gt;::iterator iter; for(iter=m.begin(); iter != m.end(); iter++)&#123; answer *= (iter-&gt;second+1); &#125; cout &lt;&lt; answer-1; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io.com/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"위장","slug":"위장","permalink":"http://gwanhyeon.github.io.com/tags/%EC%9C%84%EC%9E%A5/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io.com/tags/%EB%A0%88%EB%B2%A82/"},{"name":"해시","slug":"해시","permalink":"http://gwanhyeon.github.io.com/tags/%ED%95%B4%EC%8B%9C/"}]},{"title":"Hexo 명령어","slug":"hexo- command","date":"2019-11-09T16:29:33.000Z","updated":"2019-11-16T00:17:45.614Z","comments":true,"path":"2019/11/10/hexo- command/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/10/hexo-%20command/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start front formatter 123456# post.md 머리말---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 123456tags:- 태그명 #(예) 헥소- 깃허브# 또는 아래와 같이 사용 할수 있다.tags: [헥소, 깃허브] 123456categories:- 카테고리명 #(예) 깃허브- 서브카테고리명 #(예) 헥소# 또는 아래 처럼 사용 할수 있다.categories: [깃허브, 헥소] Create a new post 123$ hexo new post \"My New Post\"$ hexo new draft \"My new Draft\"$ hexo new layout \"My New layout\" More info: Writing Run server 123$ hexo server post$ hexo server draft$ hexo server layout More info: Server Generate static files 12$ hexo generate$ hexo g More info: Generating Deploy to remote sites 12$ hexo deploy$ hexo d More info: Deployment Generate static files and Deploy to remote sites 12$ hexo clean$ hexo g -d image files path 1source/images/image file path","categories":[{"name":"HEXO","slug":"hexo","permalink":"http://gwanhyeon.github.io.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://gwanhyeon.github.io.com/tags/hexo/"},{"name":"command","slug":"command","permalink":"http://gwanhyeon.github.io.com/tags/command/"}]}]}