{"meta":{"title":"Ethan Kim IT Blog","subtitle":"Ethan Kim IT Blog","description":"개발 이야기 & 트렌드 공유와 새로운 기술들을 배우는것을 좋아합니다.","author":"Ethan Kim","url":"http://gwanhyeon.github.io","root":"/"},"pages":[{"title":"Ethan Kim IT Blog","date":"2019-11-04T17:19:11.000Z","updated":"2020-09-08T13:22:33.267Z","comments":true,"path":"about.html","permalink":"http://gwanhyeon.github.io/about.html","excerpt":"","text":"👨‍💻 백엔드 서버 개발자 동료와 개발 이야기 하는것을 좋아하며 클린코드를 지향합니다. Issues &amp; Trend 공유와 새로운 기술들을 배우는것을 좋아합니다. Spring/Springboot Framework, Infra 환경에 개발에 관심이 많습니다. 최근에 Java8와 반응형 Reactive RxJava를 배우고 있습니다. LINK About me Github"}],"posts":[{"title":"01.Rxjava와 리액티브 프로그래밍","slug":"reactive-programming-section01","date":"2020-09-09T13:01:58.000Z","updated":"2020-09-09T15:13:24.231Z","comments":true,"path":"2020/09/09/reactive-programming-section01/","link":"","permalink":"http://gwanhyeon.github.io/2020/09/09/reactive-programming-section01/","excerpt":"","text":"What is RxJava? 자바(Java)에서 리액티브 프로그래밍(Reactive Programming)을 구현하는데 사용하는 라이브러리입니다. 이벤트 처리와 같은 비동기 처리에 최적화됐으며, 2.0버전부터 Reactive Streams 사양을 구현합니다. Reactive Streams 사양을 구현합니다. Reactive Streams는 어떤 라이브러리나 프레임워크라도 데이터 스트림을 비동기로 처리하는 공통 메커니즘을 인터페이스로 제공합니다. 즉, RxJava2.0부터는 Reative Streams API를 의존하고 Reactive Streams를 제외한 다른 라이브러리는 의존하지 않습니다. RxJava는 함수형 리액티브(Functional Reactive Programming)은 아니지만, 함수형 프로그램의 영향을 받아 함수형 인터페이스를 인자로 전달받는 메서드가 많습니다. 이러한 함수형 인터페이스를 사용하는 메서드들을 조합하면 함수형 프로그래밍을 하는 것 처럼 데이터를 필터링하거나 변환하는 등의 처리를 유연하게 할 수 있습니다. 1. Rxjava의 지원 버전 Java 6 버전 이상과 안드로이드2.3버전 진저브레드(gingerbread)이상을 지원합니다. 2. RxJava 기본 출력해보기 12345678import io.reactivex.Flowable;public class RxjavaOutput &#123; public static void main(String[] args) &#123; Flowable&lt;String&gt; flowable = Flowable.just(\"Hello\", \"World\"); flowable.subscribe(data-&gt; System.out.println(data)); &#125;&#125; 3. 처리 순서 just 메서드 인자로 전달된 데이터를 통지하는 생산자(Flowable)를 생성합니다. 생산자가 데이터를 통지하면 소비자(람다식으로 구현된 함수형 인터페이스) 데이터 출력이 됩니다. 1. What is reactive programming? 데이터가 통지될 때마다 관련 프로그램이 반응(reaction)해 데이터를 처리하는 프로그래밍 방식입니다. 1.1. Example of reactive programming GPS위치 정보가 변경될 때의 데이터 전송 흐름을 상상해보면 이해하기 쉽습니다. 이동해 위치 정보가 변경될 때마다 데이터를 전송하고 이동을 멈추면 데이터전송을 중지하는 것처럼 생성되는 데이터를 한 번에 보내지 않고 각각의 데이터가 생성될 때마다 순서대로 보냅니다. 이러한 데이터의 흐름을 데이터 스트림(data stream) 이라고 합니다. 이미 생성된 데이터 집합인 리스트(list)같은 컬렉션(collection) 과는 다르게 앞으로 발생할 가능성이 있는 데이터 까지도 포함하는 데이터 집합체 입니다. 데이터 스트림은 이벤트와도 관련이 있어서 문자열을 입력하는 행위는 입력한 데이터가 순서대로 생성하는것으로 생각 할 수 있습니다. 예를 들어, &quot;abc&quot;라고 입력하면 입력 이벤트가 발생할때 다음과 같은 데이터가 생성된다고 생각할 수 있습니다. 1231. [a]2. [ab]3. [abc] 마찬가지로 버튼을 누르는 행위에 대한 구체적인 데이터가 없더라도 버튼 이벤트와 같은 데이터가 생성된다고 생각할 수 있습니다. 버튼을 여러번 누른다면 누른 횟수만큼 버튼을 누른다 라는 이벤트가 발생할 수 있습니다. 즉, 이벤트도 발생할 때마다 데이터를 전송하는 데이터 스트림으로 다룰 수 있습니다. 데이터 스트림으로 데이터를 전달받은 프로그램이 그때마다 적절히 처리 할 수 있게 구성됐습니다. ⇒ 결론적으로 필요한 데이터를 직접 가져와 처리하는것이 아니라 보내온 데이터를 받은 시점에 반응해 이를 처리하는 프로그램을 만드는것이 리액티브 프로그래밍입니다. 또 다른 예로, 상품가격과 부가가치세 세율로 부가가치세를 계산하는 프로그램이 있다고 할때, 리액티브 프로그래밍이 아니라면 상품가격과 부가가치세 세율을 얻는 것만으로는 어떤 일도 일어나지 않습니다. 값을 얻은 후에 부가가치세를 계산한다 라는 행위(action)이 이루어져야 비로소 부가 가치세를 계산합니다. 또한, 부가 가치세를 계산한 후 상품가격이 변경되더라도 다시 계산처리 행위가 이루어지지 않는 한 부가가치세는 변경되지 않습니다. 1.2. 리액티브 프로그래밍이 아닐때 입력한다 버튼이 눌린다 계산 결과를 표시한다 상품 가격이 바뀌어도 세금계산 버튼을 누르지 않으면 부가가치세가 바뀌지 않는다. 1.3. 리액티브 프로그래밍일 때 입력한다 입력한 내용을 통지한다 통지를 받아 계산하고 결과를 표시한다 상품가격이 바뀔 때마다 부가가치세가 자동으로 계산된다. 상품 가격 변동을 감지하는 리스너(listener)를 이용해 자동으로 부가가치세를 계산하는 프로그램과 어떤 차이가 있는지 의문이 생길 수 있습니다. 예를 들어, 상품가격이 변경 될때 반응하면서 상품가격에 해당하는 부가가치세를 다시 계산해 표시하는 것을 리액티브 프로그래밍이라 할 수 없습니다. 리스너(listener)가 반응하면서 부가가치세 항목에 새로운 데이터가 전달되고 부가가치세 항목에서 계산 프로그램을 실행해 결과를 부가가치세로 표시한다고 생각하면 리액티브 프로그래밍이라고 할 수 있습니다. ⇒ 리액티브 프로그래밍에서 데이터를 생산하는 측이 데이터를 전달하는것까지 책임집니다. 데이터를 생산하는측(상품가격)은 데이터를 전달하는것까지 책임집니다. 그러므로 데이터를 생산하는 측은 데이터를 소비하는 측(예 부가가치세)이 전달 받은 데이터로 무엇을 하는지 관여하지 않아도 됩니다. 데이터를 생산하는 측은 데이터를 소비하는 측에 무엇을 하든지 관계가 없으므로 소비하는 측의 처리를 기다릴 필요가 없습니다. 그러므로 데이터를 통지한 후 데이터를 소비하는 측에서 데이터를 처리하는 도중이라도 데이터를 생산하는 측은 바로 다음 데이터를 처리 할 수 있습니다. 1.4. 시스템 구축의 관점 리액티브 프로그래밍은 마이크로서비스(Miscroservice)와 같이 분산 시스템으로 프로그램을 구현하는데 적합해 최근 주목을 받고 있습니다. 리액티브 프로그래밍(Programming)과 리액티브 시스템(System)으로 부르지 않고 리액티브 시스템이 리액티브 프로그래밍으로 구현된 시스템을 의미하지 않기 때문입니다. 1.5. 리액티브 시스템이란? 메시지를 보내 데이터를 처리하고 상황에 따라 스케일 아웃(scale out)과 스케일 인(scale in)을 자동으로 수행해 장애 내성을 높임으로써 항상 빠르게 수용할 수 있는 시스템을 말합니다.(인프라 조건+) 2. RxJava의 개요 에릭마이어가 개발한 .net 프레임워크의 실험적인 라이브러리인 Reactive Extensions 를 줄여서 2009년 마이크로소프트에서 공개하고 2013년 넷플릭스가 자바로 이식한 것이 Rxjava의 시작입니다. 현재 Reative Extensions를 다루는 라이브러리는 ReactiveX 라는 오픈소스 프로젝트로 바뀌어 Java, .Net, javascript, Swift 등 여러 프로그래밍 언어를 지원하고 있습니다. RxJava 1.x버전 때는 자바에 Reactive Extensions를 이식하는 개발이 진행됐고, 리액티브 프로그래밍 개념이 널리 알려지면서 Reactive Extensions와 별도로 여러 업체와 단체에서 데이터 스트림을 비동기로 다루는 라이브러리와 프레임워크를 출시하였습니다. 라이브러리, 프레임워크 차이로 단체들이 데이터 스트림을 비동기로 다루는 최소한의 API를 정하고 제공했습니다. 2015년 4월 자바기반의 Reactive Streams for JVM 버전이 1.0.0을 릴리즈하게 되었습니다. Rxjava 1.x버전때는 Reative Streams를 지원하지 않았지만, Rxjava 2.x버전때는 Reative Streams를 지원하여 2016년 10월에 Rxjava2.0이 릴리즈 되었습니다. Rxjava2.0버전부터 내부를 완전히 새롭게 구현하여 성능개선과 배압(back pressure) 사양에 따라 사용하는 API가 변경됐습니다. 그리고, Rxjava 1.x버전에서 2.x버전으로 전환할 때는 API 변경 작업도 반영해야 하므로 2.x버전으로 간단하게 전환할 수가 없습니다. 그 이유는 내부구현을 모두 바꾸었기 때문입니다. 버전별 루트 패키지 1234|버전|패키지||-----|------||1.x|rx||2.x|io.reactivex| 따라서, RxJava의 두 버전을 같은 프로젝트에 함께 사용할 수는 있으나 프로젝트 내부에서 Rxjav에 의존하는 다른 라이브러리를 사용한다면 라이브러리가 어떤 버전을 지원하느냐에 따라 두 버전을 함께 사용하지 못할 수도 있습니다. 두 버전을 사용하는것은 바람직 하지 않습니다. Rxjava의 실험적인 API가 있습니다. 해당 에너테이션이 붙어 있는것은 개발중이거나 실험중인 API입니다. @Beta @Experimental 추가로 io.reactivex.internal로 시작하는 패키지에 있는 클래스는 Rxjava 내부에서 기본으로 사용하는 클래스입니다. 가능하면 클래스에 의존하지 않는 편이 더 낫습니다. 3. RxJava의 특징 Rxjava는 디자인 패턴인 옵저버(Observer)패턴을 잘 확장했습니다. 3.1. 옵저버패턴이란? 감시 대상 객체의 상태가 변하면 이를 관찰하는 객체에 알려주는 구조입니다. 이 패턴의 특징을 살리면 데이터를 생성하는 측과 데이터를 소비하는 측으로 나눌 수 있습니다. 또한, 옵저버패턴에 완료와 에러통지를 할 수 있어서 모든 데이터 통지가 끝나거나 에러가 발생하는 시점에 별도로 대응해줄수도 있습니다. 3.2. 비동기 처리 Rxjava의 또 다른 특징으로 쉬운 비동기 처리를 들 수 있습니다. Reactive Streams 규칙의 근간이 되는 Observable규약 이라는 Rxjava개발 가이드라인을 따른 구현이라면 직접 스레드(thread)를 관리하는 번거로움에서 해방되고 구현도 쉽게 가능합니다. 또한, 동기 처리나 비동기 처리나 구현 방법에는 큰 차이가 없는 것도 Rxjava의 특징입니다. RxJava는 함수형 프로그래밍의 영향을 받아 함수형 인터페이스로 인자를 전달받는 메서드를 사용해 대부분의 처리를 구현합니다. 입력과 결과만 정해져 있으면 구체적인 처리는 개발자에게 맡길 수 잇으므로 더욱 자유로운 구현이 가능합니다. 3.3. 함수형 프로그램의 원칙 처리 작업의 영향 범위를 좁힐 수 있고 동시에 복잡하지않게 비동기 처리를 할 수 있습니다.","categories":[{"name":"RxJava","slug":"rxjava","permalink":"http://gwanhyeon.github.io/categories/rxjava/"}],"tags":[{"name":"RxJava","slug":"rxjava","permalink":"http://gwanhyeon.github.io/tags/rxjava/"},{"name":"리액티브프로그래밍","slug":"리액티브프로그래밍","permalink":"http://gwanhyeon.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}]},{"title":"[삼성 SW 역량테스트] 백준 연구소 14502","slug":"beakjoon-laboratory-14502","date":"2020-09-08T11:48:16.781Z","updated":"2020-09-09T07:06:50.689Z","comments":true,"path":"2020/09/08/beakjoon-laboratory-14502/","link":"","permalink":"http://gwanhyeon.github.io/2020/09/08/beakjoon-laboratory-14502/","excerpt":"","text":"문제 링크 삼성 SW 역량테스트 기출 백준 연구소 14502 1. 문제 조건 연구소는 크기가 N×M입니다. 연구소에서 빈곳 0, 벽 1, 바이러스 2의 값이 주어지게 됩니다. 벽을 3개만 세운 뒤 바이러스가 퍼질 수 없는 안전영역의 최댓값을 구하는 문제입니다. 지도의 세로 크기 N과 가로 크기 M (3 ≤ N, M ≤ 8) 2. 컴퓨팅 사고 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다. 라는 조건이 있는 문제입니다. 이 문제를 풀때 가장 중요한점은 DFS로 접근해야 하는가? BFS로 접근해야 하는가를 많이 고민하였던 문제였습니다. Basement 조건이 벽을 3개 세울 때 조합의 경우의 수를 사용하기 위해서 DFS를 사용하였으며, 연구소에서 바이러스들이 전염시키는 과정은 BFS로 풀이를 진행하였습니다. 값을 입력받고 빈칸과 바이러스의 좌표를 담고 있는 벡터에 해당 값들을 넣어주게 됩니다. 빈칸을 기준으로 DFS를 수행한다. 따라서,조합의 경우라고 생각하면 됩니다. N(빈칸의 개수중)에서 3개를 뽑는 경우의 수라고 생각을 합니다. DFS 에서의 수행은 빈칸의 개수가 기준이 되므로 empty_size를 선언해서 받아오게 하였습니다. CNT 값이 3일 경우 3개의 벽을 모두 세운 경우이므로 기존의 값은 변화가 되면 안되기때문에 맵을 Copy시켜줍니다. 이제 BFS를 수행하기위해 각각의 경우에 있어서 Check변수가 1일 경우에만 벽을 세워주게 됩니다. 바이러스가 전파시에 현재 바이러스의 값 2인 좌표 (x,y)의 점을 기준으로 BFS를 수행합니다. 모든 BFS경우를 돌고나서 아직 전염되지 않은 값이 있는곳이 안전지대입니다. 그 곳의 값을 safe_size 카운팅 시켜줍니다. 각 경우마다 안전영역의 최대의 값을 구해주어야하므로 최댓값을 갱신시켜줍니다. 각 경우마다 경우의 수가 달라지므로 visited 변수를 초기화 시켜줍니다. 즉, DFS 반복 → basement 확인 → BFS (x,y)좌표로 부터 바이러스 전염 → 안전영역의 최댓값 3. 풀이 코드 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//// 연구소14502.cpp// algorithm-ps//// Created by kgh on 2020/09/07.// Copyright © 2020 kgh. All rights reserved.//#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int n,m = 0;const int MAX = 8;int map[MAX][MAX];int copy_map[MAX][MAX];vector&lt;pair&lt;int,int&gt;&gt; empty;vector&lt;pair&lt;int,int&gt;&gt; virus;int empty_size = 0;int check[MAX*MAX]; // size를 MAX * MAX를 해준이유는 빈칸이 N*M까지 나올 수 있기 때문입니다.int visited[MAX][MAX];int dir[4][2] = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;int ans = -1;void bfs(int x,int y)&#123; queue&lt;pair&lt;int,int&gt;&gt; q; q.push(&#123;x,y&#125;); visited[x][y] = 1; while(!q.empty())&#123; int dx = q.front().first; int dy = q.front().second; q.pop(); for(int i=0; i&lt;4; i++)&#123; int mx = dx + dir[i][0]; int my = dy + dir[i][1]; if(mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m)&#123; if(visited[mx][my] == 0 &amp;&amp; copy_map[mx][my] == 0)&#123; visited[mx][my] = 1; copy_map[mx][my] = 2; q.push(&#123;mx,my&#125;); &#125; &#125; &#125; &#125; &#125; void dfs(int idx,int cnt)&#123; if(cnt == 3)&#123; memset(visited, 0, sizeof(visited)); // 기존의 맵을 변경시키면 안되기때문에 값을 카피시켜줍니다. for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; copy_map[i][j] = map[i][j]; &#125; &#125; // 벽을 세우기 하나의 경우마다의 벽을 세워야함. int count = 0; for(int i=0; i&lt;empty_size; i++)&#123; if(count == 3)&#123; break; &#125; if(check[i] == 1)&#123; int x = empty[i].first; int y = empty[i].second; copy_map[x][y] = 1; count +=1; &#125; &#125; // virus 전염시키기 for(int i=0; i&lt;virus.size(); i++)&#123; int x = virus[i].first; int y = virus[i].second; bfs(x,y); &#125; int safe_size = 0; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; if(copy_map[i][j] == 0)&#123; safe_size++; &#125; &#125; &#125; if(ans &lt; safe_size)&#123; ans = safe_size; &#125; return; &#125; // 조합의 형식으로 3개가 뽑힐때까지 뽑았다가 종료되는 시점에 그 값을 다시 false로 만들고 다시 조합의 경우를 뽑습니다. for(int i=idx; i&lt;empty_size; i++)&#123; if(check[i] == 1)&#123; continue; &#125; check[i] = 1; dfs(i, cnt+1); check[i] = 0; &#125; &#125;int main(void)&#123; cin &gt;&gt; n &gt;&gt; m; // 값을 입력받고 빈칸과 바이러스의 좌표를 담고 있는 벡터에 해당 값들을 넣어주게 된다. for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; cin &gt;&gt; map[i][j]; // 0: 빈칸 if(map[i][j] == 0)&#123; empty.push_back(&#123;i,j&#125;); &#125; // 2: 바이러스 else if(map[i][j] == 2)&#123; virus.push_back(&#123;i,j&#125;); &#125; &#125; &#125; // 빈칸을 기준으로 DFS를 수행한다. 따라서,조합의 경우라고 생각하면 됩니다. N(빈칸의 개수중)에서 3개를 뽑는 경우의 수라고 생각을 합니다. empty_size = empty.size(); dfs(0,0); cout &lt;&lt; ans; return 0;&#125; JAVA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.List;import java.util.StringTokenizer;public class 연구소 &#123; static class Dot &#123; private int x; private int y; public Dot(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125; static int n; static int m; static int[][] map; static int[][] copy_map; static List&lt;Dot&gt; virusList = new ArrayList&lt;Dot&gt;(); static int[][] dir =&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; static int ans = 0; static void wallDfs(int idx, int cnt) &#123; if(cnt == 3)&#123; // map Copy copyMapFunc(); // virus spread for(Dot dot : virusList)&#123; virusSpreadBfs(dot.x, dot.y); &#125; // safe Area ans = Math.max(ans, getSafeArea()); return; &#125; for(int i=idx; i&lt;n * m; i++)&#123; int x = i / m; int y = i % m; if(map[x][y] == 1 || map[x][y] == 2)&#123; continue; &#125; map[x][y] = 1; wallDfs(i+1, cnt+1); map[x][y] = 0; &#125; &#125; // 맵 카 static void copyMapFunc() &#123; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; copy_map[i][j] = map[i][j]; &#125; &#125; &#125; // 바이러스 퍼트리기 static void virusSpreadBfs(int x,int y) &#123; for(int i=0; i&lt;4; i++)&#123; int mx = x + dir[i][0]; int my = y + dir[i][1]; if(mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m)&#123; if(copy_map[mx][my] == 0)&#123; copy_map[mx][my] = 2; virusSpreadBfs(mx,my); &#125; &#125; &#125; &#125; // 안전영역 개수 체크 static int getSafeArea() &#123; int safe = 0; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; if(copy_map[i][j] == 0)&#123; safe += 1; &#125; &#125; &#125; return safe; &#125; /* 4 6 0 0 0 0 0 0 1 0 0 0 0 2 1 1 1 0 0 2 0 0 0 0 0 2 */ public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); n = Integer.parseInt(st.nextToken()); m = Integer.parseInt(st.nextToken()); map = new int[n][m]; copy_map = new int[n][m]; for(int i=0; i&lt;n; i++)&#123; st = new StringTokenizer(br.readLine()); for(int j=0; j&lt;m; j++)&#123; map[i][j] = Integer.parseInt(st.nextToken()); if(map[i][j] == 2)&#123; virusList.add(new Dot(i,j)); &#125; &#125; &#125; wallDfs(0,0); System.out.println(ans); &#125;&#125; 4. [2.로봇 청소기]","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"삼성SW역량테스트","slug":"삼성sw역량테스트","permalink":"http://gwanhyeon.github.io/tags/%EC%82%BC%EC%84%B1sw%EC%97%AD%EB%9F%89%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"BOJ","slug":"boj","permalink":"http://gwanhyeon.github.io/tags/boj/"}]},{"title":"백준연산자끼워넣기2-15658","slug":"백준연산자끼워넣기2-15658","date":"2019-12-19T16:31:17.000Z","updated":"2020-09-07T21:04:32.332Z","comments":true,"path":"2019/12/20/백준연산자끼워넣기2-15658/","link":"","permalink":"http://gwanhyeon.github.io/2019/12/20/%EB%B0%B1%EC%A4%80%EC%97%B0%EC%82%B0%EC%9E%90%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B02-15658/","excerpt":"","text":"연산자끼워넣기(2)15658 컴퓨팅 스킬 DFS 재귀호출로 백트래킹으로 구해줍니다. 연산자끼워넣기 1번문제와 같은 원리입니다. 정답 또한 같습니다. 1. 컴퓨팅 사고 DFS 백트래킹 맨처음 dfs(v,1,v[0],plus,minus,multi,div); 호출할 때 왜 idx = 1로 시작하고, sum의 값을 v[0]의 값을 넘겨주는가에 대한 의문을 갖고 계신분들이 있습니다. idx를 1로 시작한 이유는 곱하기나, 나눗셈의 경우에서 sum의 값이 0일 경우 올바르지 않은 값이 연산되게 됩니다. 따라서, v[0] (+, -, *, /) v[1] 의 형태로 연산이 되게 됩니다. 따라서 올바른 값을 구할 수 있습니다. 곰곰히 생각해보시면 어떤 말씀인지 알 것이라 생각합니다. 입력받은 plus,minus,multi,div의 개수를 0보다 클 경우에는 계속해서 재귀호출을 합니다. 시간복잡도 계산 총 연산자(+,-,*,/) 4개의 연산자이고, 총 N은 (2&lt;=N&lt;=11) 11까지 이므로 4^10 = 1048570의 복잡도를 가지게 됩니다. 123456789101112if(plus &gt; 0)&#123; dfs(v,idx+1,sum+v[idx],plus-1, minus, multi, div);&#125;if(minus &gt; 0)&#123; dfs(v,idx+1,sum-v[idx], plus, minus-1, multi, div);&#125;if(multi &gt; 0)&#123; dfs(v,idx+1,sum*v[idx], plus, minus, multi-1, div);&#125;if(div &gt; 0)&#123; dfs(v,idx+1,sum/v[idx], plus, minus, multi, div-1);&#125; 만약 v.size() == idx 모든 원소의 개수를 확인하였을 경우에 현재 sum값을 res 벡터에 값을 넣어줍니다. 그 후 auto p = minmax_element(res.begin(), res.end());를 사용하여 최댓값과 최솟값을 구해주게 됩니다. 이렇게 구하지 않고도 문제의 조건에서보면 최댓값과 최솟값이 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다 라는 조건이 있습니다. 이러한 것들에 따라 값을 max함수와 min함수를 사용하면서 최댓값과 최솟값을 구해줍니다. 다른분들의 풀이를 보니 이런식으로 사용하시는것을 보고 배우게 되었습니다. 123456const int MAX = 1000000000 + 1;int maxResult = -MAX, minResult = MAX; maxResult = max(maxResult, sum); minResult = min(minResult, sum); cout &lt;&lt; maxResult &lt;&lt; endl; cout &lt;&lt; minResult &lt;&lt; endl; 1.1. DFS 백트래킹 풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// 12_백준_연산자끼워넣기2_15658.cpp// algorithm-level-up//// Created by kgh on 20/12/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; res;void dfs(vector&lt;int&gt; v, int sum, int idx, int plus, int minus, int multi, int div)&#123; if(idx == v.size())&#123; res.push_back(sum); return; &#125; if(plus &gt; 0)&#123; dfs(v,sum+v[idx],idx+1, plus-1,minus,multi,div); &#125; if(minus &gt; 0)&#123; dfs(v,sum-v[idx],idx+1, plus,minus-1,multi,div); &#125; if(multi &gt; 0)&#123; dfs(v,sum*v[idx],idx+1, plus,minus,multi-1,div); &#125; if(div &gt; 0)&#123; dfs(v,sum/v[idx],idx+1, plus,minus,multi,div-1); &#125; &#125;int main(void)&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; v(n); int plus=0; int minus=0; int multi=0; int div=0; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; for(int i=0; i&lt;4; i++)&#123; int cal=0; cin &gt;&gt; cal; if(i == 0)&#123; plus = cal; &#125;else if(i == 1)&#123; minus = cal; &#125;else if(i == 2)&#123; multi = cal; &#125;else &#123; div = cal; &#125; &#125; dfs(v, v[0],1,plus, minus, multi, div); auto p = minmax_element(res.begin(), res.end()); cout &lt;&lt; *p.second &lt;&lt; \" \" &lt;&lt; *p.first; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"},{"name":"DFS","slug":"dfs","permalink":"http://gwanhyeon.github.io/tags/dfs/"},{"name":"백트래킹","slug":"백트래킹","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"}]},{"title":"백준퇴사14501","slug":"백준퇴사14501","date":"2019-12-17T08:09:56.000Z","updated":"2020-09-07T21:04:28.551Z","comments":true,"path":"2019/12/17/백준퇴사14501/","link":"","permalink":"http://gwanhyeon.github.io/2019/12/17/%EB%B0%B1%EC%A4%80%ED%87%B4%EC%82%AC14501/","excerpt":"","text":"백준퇴사14501 1. 컴퓨팅 스킬 백트래킹 재귀호출 2. 컴퓨팅 사고 맨 처음에 조합으로 next_permutation을 사용해서 해당 T[i]만큼 false를 만들면서 오는 경우를 찾으면 어떨까 라고 생각하였지만, 직감적으로 쉽지않다는것을 느꼈습니다. 그래서 재귀함수로 풀어보자 라는 생각으로 풀게되었습니다. 이 부분이 가장 중요한 부분입니다. 재귀 백트래킹으로 idx==n+1과 같을때 basement 정답을 찾았을 경우를 확인하였습니다. 그리고 idx값이 n+1보다 클 경우 조건에 퇴사할 수 없으므로 return으로 종료시켜주었습니다. 기존것과 다르게 이것은 선택할지 말지에 대한 경우를 잘 확인해주어야합니다. 예를 들면, [1,2,3,4,5]라는 T배열이있다고 가정하면 1,2,3,4,5라는 값을 모두 사용하는것이 아니라 날짜가 n+1과 같은경우를 찾는 경우이기 때문에 1,2,3,4,5라는 값을 모두 사용할 수 있고, 최소 하나이상의 값만 사용할 수 있습니다. 너무 습관적으로 for문안에다가 재귀함수를 호출하였는데, 이 문제는 조합이나 순열문제가 아니라 말그대로 브루트포스문제였습니다. for을 작성하게 되면 1,2,3,4,5의 모든 값에 대한 경우의 수를 확인하는것입니다. 익숙함에 속아버렸습니다. dfs를 호출할때 이것도 무의식적으로 dfs(0,0)을 호출하였는데, 문제의 조건에서 보면 최소 1일부터이기 때문에 초기조건을 1부터 시작하였습니다.idx는 상담일 day와 같습니다. 최대값을 찾아주는것은 max_num이라는 변수를 활용하여서 그때마다 비교해서 업데이트를 해주었습니다. max_elements를 사용할 수도 있었지만, 빠르게 비교해주기위해서 이런 로직을 사용하였습니다. 3. 풀이 3.1. 백트래킹 DFS 123456789101112131415161718192021222324252627282930313233343536373839404142//// 11_백준_퇴사_14501.cpp// algorithm-level-up//// Created by kgh on 17/12/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int T[16];int P[16];int n =0;int max_num = -1;void dfs(int sum, int idx)&#123; if(idx == n+1)&#123; if(sum &gt; max_num)&#123; max_num = sum; &#125; return; &#125; if(idx &gt; n+1)&#123; return; &#125; dfs(sum+P[idx], idx+T[idx]); dfs(sum,idx+1);&#125;int main(void)&#123; cin &gt;&gt; n; for(int i=1; i&lt;=n; i++)&#123; cin &gt;&gt; T[i] &gt;&gt; P[i]; &#125; dfs(0,1); cout &lt;&lt; max_num &lt;&lt; '\\n'; return 0;&#125; 혹시라도 0,1에서 왜 시작하는거지? 라는 의문이 있으신분은 아래와 같이 구현하여도 상관은 없습니다. 단지 문제의 조건에 부합시키기 위해 위와 같이 작성한것 뿐입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041//// 11_백준_퇴사_14501.cpp// algorithm-level-up//// Created by kgh on 17/12/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int T[16];int P[16];int n =0;int max_num = -1;void dfs(int sum, int idx)&#123; if(idx == n)&#123; if(sum &gt; max_num)&#123; max_num = sum; &#125; return; &#125; if(idx &gt; n)&#123; return; &#125; dfs(sum+P[idx], idx+T[idx]); dfs(sum,idx+1);&#125;int main(void)&#123; cin &gt;&gt; n; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; T[i] &gt;&gt; P[i]; &#125; dfs(0,0); cout &lt;&lt; max_num &lt;&lt; '\\n'; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"},{"name":"백트래킹","slug":"백트래킹","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"}]},{"title":"백준부분수열의합1182","slug":"백준부분수열의합1182","date":"2019-12-16T16:45:40.000Z","updated":"2020-09-07T21:04:23.749Z","comments":true,"path":"2019/12/17/백준부분수열의합1182/","link":"","permalink":"http://gwanhyeon.github.io/2019/12/17/%EB%B0%B1%EC%A4%80%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98%ED%95%A91182/","excerpt":"","text":"백준 부분수열의합 1182 1. 컴퓨팅적 스킬 재귀호출 사용, 조합 사용 2. 컴퓨팅적 사고 next_permutation을 사용한 조합을 이용한 풀이 방법 1 순열과 조합중 조합을 사용하여 각각의 부분집합의 경우를 모두 구해준다. 하나씩 check변수에 모든 값을 true로 바꾸어준 후, 맨 앞에 있는 값들을 false로 바꾸면서 모든 부분집합의 경우를 구해준다. 재귀함수 백트래킹을 이용한 풀이 방법 2 m == 0 일때 공집합을 빼주어야한다. 양수라고 하였음. 정수에서 양수의 크기만 가지므로 공집합은 제외해야함 int cnt = 0;의 값이 계속초기화된다고 할 수 있지만, 결과값 반환할때는 그값이 더해진값만 반환된다. 경우의 수 의 문제임 따라서, 그값이 1로반환되어 한번의 경우의수 0번의 경우의수를 반환하여 더해가다보면 최종 경우의 수를 반환하게 된다. 정답일 경우는 sum == m이 같고, cnt ==값이 5개일때만 가능하다. 비정답일 경우는 sum == m이 아닌경우에 cnt==값이 5개 일경우는 불가능하다. 예를 들면, 도달했지만 값이 다를 수 있음 반례임 3. 풀이 재귀 백트래킹 풀이 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; ans;int check[21];int cnt = 0;void dfs(vector&lt;int&gt; v,int n,int m, int idx, int sum)&#123; if(ans.size() &gt; 0)&#123; int s = 0; for(int i=0; i&lt;ans.size(); i++)&#123; s += ans[i]; &#125; if(s == m)&#123; cnt +=1; &#125; &#125; for(int i=idx; i&lt;n; i++)&#123; if(check[i])&#123; continue; &#125; check[i] = true; ans.push_back(v[i]); dfs(v,n,m,i,sum); check[i] = false; ans.pop_back(); &#125;&#125;int main(void)&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; v(n); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; dfs(v,n,m,0,0); cout &lt;&lt; cnt; return 0;&#125; 재귀 백트래킹 풀이 2 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int ans = 0;void dfs(vector&lt;int&gt; v, int m, int cnt,int sum)&#123; // 합이 m과 같을 경우 if(cnt == v.size())&#123; if(sum == m)&#123; ans +=1; &#125; return; &#125; else if(cnt == v.size())&#123; return; &#125; dfs(v,m,cnt+1,sum+v[cnt]); dfs(v,m,cnt+1,sum);&#125;int main(void)&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; v(n); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; //공집합 빼주기 if(m==0)&#123; ans -=1; &#125; dfs(v,m,0,0); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;&#125; next_permutation 조합 풀이 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(void)&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; v(n); bool check[21]; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; int cnt = 0; for(int i=0; i&lt;20; i++)&#123; check[i] = true; &#125; for(int i=0; i&lt;n; i++)&#123; check[i] = false; do&#123; int sum = 0; for(int j=0; j&lt;n; j++)&#123; if(check[j] != true)&#123; sum += v[j]; &#125; &#125; if(sum == m)&#123; cnt +=1; &#125; &#125;while(next_permutation(check,check+n)); &#125; cout &lt;&lt; cnt; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"},{"name":"백트래킹","slug":"백트래킹","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"},{"name":"조합","slug":"조합","permalink":"http://gwanhyeon.github.io/tags/%EC%A1%B0%ED%95%A9/"}]},{"title":"백준암호만들기1759","slug":"백준암호만들기1759","date":"2019-12-02T18:36:20.000Z","updated":"2020-09-07T21:04:19.944Z","comments":true,"path":"2019/12/03/백준암호만들기1759/","link":"","permalink":"http://gwanhyeon.github.io/2019/12/03/%EB%B0%B1%EC%A4%80%EC%95%94%ED%98%B8%EB%A7%8C%EB%93%A4%EA%B8%B01759/","excerpt":"","text":"백준암호만들기1759 1. 컴퓨팅 스킬 Recursive를 활용한 풀이 백트래킹 두가지 방법으로 풀겠습니다. include헤더에 sort함수를 사용하겠습니다. 그 이유는 사전식으로 가능성 있는 암호를 모두 출력한다. 라는 조건이 있기 때문입니다. 2. 컴퓨팅 사고 조합의 방식으로 풀어야합니다. 어떻게 조합으로 풀어야된다는 생각을 하였을까요? 문자의 종류는 C가지, 암호는 서로 다른 L개의 알파벳 소문자들로 구성된다고 문제에 나와있다. 이것이 뜻하는 바는 바로 C개의 문자중 L개를 뽑는 방식이다 결국 조합을 나타내는 문제라는 것입니다. 백트래킹을 푸는 방식은 두가지 방법이 있습니다. 개인마다 풀이의 차이이긴 하나 개인적으로 1번풀이로 진행합니다. vector와 check변수를 활용한 풀이 vector 알파벳을 선택하는 recursive(), 알파벳을 선택하지 않는 recursive() 재귀함수 호출시 idx변수와 cnt변수를 사용합니다. Idx변수는 시작점을 결정해주는 변수, cnt는 몇 개를 뽑아야하는지 그리고 재귀 호출 종료 해당 basement 조건이 됩니다. 그리고, 조합은 순열과 다르게 해당 지정된 idx값 이하의 값들은 구성하지 않습니다. 예를 들어, 123 213 312 는 모두 동일한 경우로 생각합니다. 조합을 구현하기 위해서는 check배열변수와 알파벳을 담기위한 vector를 선언합니다. 해당값이 사용되었더라면 check[i] == true로 확인하여 continue를 진행합니다. 그리고 나서 다음 반복문 수가 진행되면서 해당값이 사용되지 않았다면 해당 값을 check=true를 진행하고, vector에 해당되는 알파벳을 push_back을 해주게됩니다. 그리고나서 재귀호출을 하면서 cnt+1의 값을 해주며 idx의 값은 i의 값을 넣어주면서 진행합니다. cnt값은 내가 고를 값이며, idx의 값은 해당 기준이 되는 값이기때문에 반복문을 돌면서 해당값에 대한 재귀호출을 반복하게 하게됩니다. 만약 cnt의 값이 내가 구하고자하는 n의 값과 같다면 해당 경우를 구한것이기 때문에 실질적인 로직을 작성합니다. 알파벳은 자음 21가지, 모음 [a,e,i,o,u] 5가지로 구성됩니다. 따라서, push_back으로 넣었던 vector의 값을 하나씩 꺼내면서 해당 알파벳이 [a,e,i,o,u]중에 하나 일 경우 모음에 대한 개수를 증가시켜주고, 이와반대로 자음일 경우 자음의 개수를 증가시켜줍니다. 모음의 개수는 1이상이여야하고, 자음의 개수는 2이상이여야합니다. 만약 이 해당되는 조건에 만족한다면 해당 vector에 있는 값을 모두 출력시켜주게 됩니다. 그리고, Return값으로 해당 재귀함수가 종료되고나서 check=false로 방문을 해제시키고, 마지막에 들어있던 벡터값도 빼주게 됩니다. 그리고나서 다음에 해당하는 경우의 수로 재귀함수가 호출되면서 조합에 대한 모든경우를 구할 수 있게됩니다. idx변수는 해당 기준이 되는점이고, cnt는 해당종료 조건(몇개를 뽑을지 조건)입니다. 2번 백트래킹방식으로 사용할 경우 선택한 경우, 선택하지 않은경우를 cnt값을 더해주는지 안더해주는지 경우로 나누어서 재귀호출이 진행되게 됩니다. 2번방식은 개인적으로 직관적인 판단하기가 힘들고 1번방식이 직관적인 이해가 더 쉬웠습니다. 조합과 반대로 순열은 idx변수가 사라지게 됩니다. 왜냐하면 기준이 되는점을 확인해야합니다. 예를 들어서 [1,2,3,4,5] [2,1,3,4,5]는 조합과 다르게 다른경우의 수로 나타냅니다. 조합은 저것을 하나의 경우의수로 판단하기 때문입니다. 그리고 순열은 idx를 사용하지 않으므로 해당되는 모든값에 첫번째 값부터 다시 확인을 진행한다는 차이점이 있습니다. 2.1. DFS 백트래킹 1번 방식 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool check[15];vector&lt;char&gt; str;void dfs(vector&lt;char&gt; v, int m, int n, int idx, int cnt)&#123; if(cnt == n)&#123; int ja = 0; int mo = 0; for(int i=0; i&lt;str.size(); i++)&#123; if(str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' ||str[i] == 'u')&#123; mo +=1; &#125;else&#123; ja +=1; &#125; &#125; if(mo &gt;=1 &amp;&amp; ja &gt;= 2)&#123; for(int i=0; i&lt;str.size(); i++)&#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; '\\n'; &#125; return; &#125; if(idx == v.size())&#123; return; &#125; for(int i=idx; i&lt;v.size(); i++)&#123; if(check[i] == true)&#123; continue; &#125; check[i] = true; str.push_back(v[i]); dfs(v,m,n,i,cnt+1); str.pop_back(); check[i] = false; &#125;&#125;int main(void)&#123; int n = 0; int m = 0; cin &gt;&gt; n &gt;&gt; m; vector&lt;char&gt; v(m); for(int i=0; i&lt;m; i++)&#123; cin &gt;&gt; v[i]; &#125; sort(v.begin(),v.end()); dfs(v,m,n,0,0); return 0;&#125; 2.2. DFS 백트래킹 2번방식 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void dfs(vector&lt;char&gt; v, int n, int m, string str, int idx)&#123; if(str.length() == n)&#123; int ja=0; int mo=0; for(int i=0; i&lt;str.size(); i++)&#123; if(str[i] == 'a' || str[i] == 'e'|| str[i] == 'i' || str[i] == 'o' || str[i] == 'u')&#123; mo +=1; &#125;else &#123; ja +=1; &#125; &#125; if(mo &gt;= 1 &amp;&amp; ja &gt;= 2)&#123; cout &lt;&lt; str &lt;&lt; '\\n'; &#125; return; &#125; if(v.size() == idx)&#123; return; &#125; //알파벳 선택 하는 경우 dfs(v,n,m,str+v[idx],idx+1); //알파벳 선택 하지 않는 경우 dfs(v,n,m,str,idx+1);&#125;int main(void)&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; vector&lt;char&gt; v(m); for(int i=0; i&lt;m; i++)&#123; cin &gt;&gt; v[i]; &#125; sort(v.begin(), v.end()); dfs(v,n,m,\"\",0); &#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"}]},{"title":"백준연산자끼워넣기14888","slug":"백준연산자끼워넣기14888","date":"2019-12-02T09:57:01.000Z","updated":"2020-09-07T21:04:06.530Z","comments":true,"path":"2019/12/02/백준연산자끼워넣기14888/","link":"","permalink":"http://gwanhyeon.github.io/2019/12/02/%EB%B0%B1%EC%A4%80%EC%97%B0%EC%82%B0%EC%9E%90%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B014888/","excerpt":"","text":"연산자끼워넣기14888 1. 컴퓨팅 스킬 next_permutation 값을 저장 시킬 vector v; 연산자의 개수를 1,2,3,4 의 값으로 넣을 vector cal; #include헤더에 minmax_element으로 최대값과 최소값 구해줍니다. DFS 재귀호출로 백트래킹으로 구해줍니다. 2. 컴퓨팅 사고 next_permutation n을 입력받아 수를 v에 입력을 받아줍니다. +, -, *, /의 개수를 확인해서 cal 변수에 1,2,3,4를 나누어서 넣어줍니다. 예를 들면, 2 0 1 0 일경우 +의 개수는 2개이므로 1을 두번넣어주고, *의 개수는 1개이므로 3을 한번넣어주고 해당 cal 벡터에는 [1, 1, 3]이 됩니다. cal에 담긴 벡터를 next_permutation을 돌려주면서 순열값 모든경우의 수를 구해줍니다. cal값이 1일 경우 + , 2일경우 -, 3일 경우 *, 4일 경우 / 의 연산대로 조건을 처리해줍니다. 이때, sum = v[0]을 해준이유는 순차적으로 계산을 진행해야하므로 가장 맨처음에 존재하는 값을 sum에 담고 시작하였습니다. 연산자의 개수는 수의 N-1개이기때문에 미리 sum에 값을 넣어주었습니다. 예를 들면 10 + 20를 연산해야 한다고 할 경우 sum = 10을 두고 sum + 20으로 연산을 처리하기위해서 입니다. 조건에 보면 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 합니다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다.을 해주어야하므로 sum의 값이 음수일 경우 sum = -sum 으로 양수 값을 변경하고, sum = (sum / v[i]) 을 계산해준 후 다시 음수값으로 변경하였습니다. sum이 양수일 경우 sum = (sum / v[i])로 로직대로 처리하였습니다. minmax_element를 사용하여 max, min값을 동시에 구하였습니다. auto p = minmax_element(ans.begin(), ans.end());의 형식으로 최대값과 최소값을 모두 구할 수 있습니다. *p.second는 최소값, *p.first는 최대값입니다. 3. 해당 +,-,*,/ 연산자에 가중치를 부여하여 그 값에 따라 순열을 통해 모든경우의 수를 구하는것이 키 포인트였습니다. DFS 백트래킹 맨처음 dfs(v,1,v[0],plus,minus,multi,div); 호출할 때 왜 idx = 1로 시작하고, sum의 값을 v[0]의 값을 넘겨주는가에 대한 의문을 갖고 계신분들이 있습니다. idx를 1로 시작한 이유는 곱하기나, 나눗셈의 경우에서 sum의 값이 0일 경우 올바르지 않은 값이 연산되게 됩니다. 따라서, v[0] (+, -, *, /) v[1] 의 형태로 연산이 되게 됩니다. 따라서 올바른 값을 구할 수 있습니다. 곰곰히 생각해보시면 어떤 말씀인지 알 것이라 생각합니다. 입력받은 plus,minus,multi,div의 개수를 0보다 클 경우에는 계속해서 재귀호출을 합니다. 123456789101112if(plus &gt; 0)&#123; dfs(v,idx+1,sum+v[idx],plus-1, minus, multi, div);&#125;if(minus &gt; 0)&#123; dfs(v,idx+1,sum-v[idx], plus, minus-1, multi, div);&#125;if(multi &gt; 0)&#123; dfs(v,idx+1,sum*v[idx], plus, minus, multi-1, div);&#125;if(div &gt; 0)&#123; dfs(v,idx+1,sum/v[idx], plus, minus, multi, div-1);&#125; 만약 v.size() == idx 모든 원소의 개수를 확인하였을 경우에 현재 sum값을 res 벡터에 값을 넣어줍니다. 그 후 auto p = minmax_element(res.begin(), res.end());를 사용하여 최댓값과 최솟값을 구해주게 됩니다. 이렇게 구하지 않고도 문제의 조건에서보면 최댓값과 최솟값이 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다 라는 조건이 있습니다. 이러한 것들에 따라 값을 max함수와 min함수를 사용하면서 최댓값과 최솟값을 구해줍니다. 다른분들의 풀이를 보니 이런식으로 사용하시는것을 보고 배우게 되었습니다. 123456const int MAX = 1000000000 + 1;int maxResult = -MAX, minResult = MAX; maxResult = max(maxResult, sum); minResult = min(minResult, sum); cout &lt;&lt; maxResult &lt;&lt; endl; cout &lt;&lt; minResult &lt;&lt; endl; 3.1. DFS 백트래킹 풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorihtm&gt;using namespace std;vector&lt;int&gt; res;void dfs(vector&lt;int&gt; v, int idx,int sum, int plus, int minus, int multi, int div)&#123; if(idx == v.size())&#123; res.push_back(sum); return; &#125; if(plus &gt; 0)&#123; dfs(v,idx+1,sum+v[idx],plus-1, minus, multi, div); &#125; if(minus &gt; 0)&#123; dfs(v,idx+1,sum-v[idx], plus, minus-1, multi, div); &#125; if(multi &gt; 0)&#123; dfs(v,idx+1,sum*v[idx], plus, minus, multi-1, div); &#125; if(div &gt; 0)&#123; dfs(v,idx+1,sum/v[idx], plus, minus, multi, div-1); &#125; &#125;int main(void)&#123; vector&lt;int&gt; v; int n; cin &gt;&gt; n; int plus=0; int minus=0; int multi=0; int div = 0; for(int i=0; i&lt;n; i++)&#123; int input; cin &gt;&gt; input; v.push_back(input); &#125; for(int i=0; i&lt;4; i++)&#123; int cal; cin &gt;&gt; cal; if(i == 0)&#123; plus = cal; &#125;else if(i == 1)&#123; minus = cal; &#125;else if(i == 2)&#123; multi = cal; &#125;else &#123; div = cal; &#125; &#125; dfs(v,1,v[0],plus,minus,multi,div); auto p = minmax_element(res.begin(), res.end()); cout &lt;&lt; *p.second &lt;&lt; ' ' &lt;&lt; *p.first;&#125; 3.2. next_permutation 풀이 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//// 08_백준_연산자끼워넣기_14888.cpp// algorithm-level-up//// Created by kgh on 02/12/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void)&#123; int n=0; cin &gt;&gt; n; vector&lt;int&gt; v(n); vector&lt;int&gt; cal; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; for(int i=0; i&lt;4; i++)&#123; int a = 0; cin &gt;&gt; a; for(int j=0; j&lt;a; j++)&#123; if(i == 0)&#123; cal.push_back(1); &#125;else if(i == 1)&#123; cal.push_back(2); &#125;else if(i == 2)&#123; cal.push_back(3); &#125;else if(i == 3)&#123; cal.push_back(4); &#125; &#125; &#125; vector&lt;int&gt; ans; do&#123; int sum = v[0]; for(int i=1; i&lt;v.size(); i++)&#123; if(cal[i-1] == 1)&#123; sum = sum + v[i]; &#125;else if(cal[i-1] == 2)&#123; sum = sum - v[i]; &#125;else if(cal[i-1] == 3)&#123; sum = sum * v[i]; &#125;else &#123; if(sum &lt; 0)&#123; sum = -sum; sum = (sum / v[i]); sum = -sum; &#125;else &#123; sum = (sum / v[i]); &#125; &#125; &#125; ans.push_back(sum); &#125;while(next_permutation(cal.begin(), cal.end())); auto p = minmax_element(ans.begin(), ans.end()); cout &lt;&lt; *p.second &lt;&lt; '\\n'; cout &lt;&lt; *p.first &lt;&lt; '\\n'; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"},{"name":"DFS","slug":"dfs","permalink":"http://gwanhyeon.github.io/tags/dfs/"},{"name":"백트래킹","slug":"백트래킹","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"}]},{"title":"백준6603로또","slug":"백준6603로또","date":"2019-12-02T08:32:25.000Z","updated":"2020-09-07T21:04:00.399Z","comments":true,"path":"2019/12/02/백준6603로또/","link":"","permalink":"http://gwanhyeon.github.io/2019/12/02/%EB%B0%B1%EC%A4%806603%EB%A1%9C%EB%98%90/","excerpt":"","text":"로또6603 1. 컴퓨팅 스킬 vector check 변수에 6개를 뽑는 경우의 수 이므로, k-6개만큼은 0을 푸쉬백 해주고, 6개까지에 1을 넣어줍니다. check배열로 next_permutation을 수행합니다. true인경우가 조합을 구하는 경우의 수입니다. 테스트케이스를 돌면서 vectorv, vector check의 값의 초기화값을 잘 생각해주어야한다. 초기화가 원활하게 이루어지지않을 경우 이상한 값을 가득담고있습니다. 값이 들어있는 vector&lt;int&gt; v; 변수를 next_permutation을 하는것이 아니라 check변수를 수행하는것입니다. 2. 컴퓨팅 사고 처음에 check배열을 선언해서 단순히 1의 값만넣어서 체크하였지만, check[i]==1 의 경우만 체크해주었다. 하지만, 조합이 나오는것이 아니라 순열의 값이 나오게 되어 올바르지 않은 값이다. 그 이유는 단순히 check배열을 사용하여 true,false값을 사용할 경우에는 중복된 값을 체크 할 수가 없다. check된 값을 next_permutation을 돌려주어야지 조합의 경우를 찾을 수 있습니다. 순열과 조합중에 조합 중복을 제거해야합니다. push_back 을 0 과 1을 해주는 경우를 잘 생각해야합니다. 6개를 뽑는 경우의 수 이므로, k-6개만큼은 0을 푸쉬백 해주고, 6개까지에 1을 넣어줍니다. 가장 중요한점은 왜 0 111111이 들어가는데 어떻게 이것을 조합을 뽑을지에 대한 고민을 했다. 단순히 0,1과으로 조합의 경우를 세어준것입니다. 순열의 경우에는 이전에 보았던 값들도 확인해주어야하지만, 조합의 경우는 이전의 값을 확인하지 않는다는것이다. next_permutation을 돌리게 되면서 그 순열의 값들은 계속해서 변경되기때문에 중복없는 값을 계속해서 체크해서 나갈 수 있다는점입니다. next_permuation을 돌린 후 그 값을 모두 ans 저장시켜 sort(ans.begin(), ans.end())를 통하여 값을 오름차순 정렬을 시켜줍니다. 단순히 check배열로 true를 체크하는것이 아니라, check vector의 값으로 next_permutation을 돌려주면서 check[i]== true일 경우 N개중 K개를 고르는 경우를 구할 수 있습니다. 2.1. next_permutation풀이 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// 07_백준_로또_6603.cpp// algorithm-level-up//// Created by kgh on 02/12/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(void)&#123; while(true)&#123; int n=0; cin &gt;&gt; n; vector&lt;int&gt; v(n); vector&lt;int&gt; check; if(n == 0)&#123; break; &#125; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; for(int i=0; i&lt;n-6; i++)&#123; check.push_back(0); &#125; for(int i=0; i&lt;6; i++)&#123; check.push_back(1); &#125; sort(v.begin(),v.end()); vector&lt;vector&lt;int&gt;&gt; ans; do&#123; vector&lt;int&gt; curr; for(int i=0; i&lt;n; i++)&#123; if(check[i] == 1)&#123; curr.push_back(v[i]); &#125; &#125; ans.push_back(curr); &#125;while(next_permutation(check.begin(),check.end())); sort(ans.begin(),ans.end()); for(int i=0; i&lt;ans.size(); i++)&#123; for(int j=0; j&lt;ans[i].size(); j++)&#123; cout &lt;&lt; ans[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; '\\n'; &#125; cout &lt;&lt; '\\n'; &#125; return 0;&#125; 2.2. 백트래킹 풀이 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int check[13];vector&lt;int&gt; ans;void dfs(vector&lt;int&gt; v, int idx, int cnt)&#123; if(cnt == 6)&#123; sort(ans.begin(),ans.end()); for(int i=0; i&lt;ans.size(); i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\\n'; return; &#125; for(int i=idx; i&lt;v.size(); i++)&#123; if(check[i] == true)&#123; continue; &#125; check[i] = true; ans.push_back(v[i]); dfs(v,i,cnt+1); check[i] = false; ans.pop_back(); &#125; &#125;int main(void)&#123; while(true)&#123; int n=0; cin &gt;&gt;n; if(n == 0)&#123; break; &#125; vector&lt;int&gt; v(n); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; dfs(v,0,0); cout &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"}]},{"title":"백준외원판순회2-10971","slug":"백준외원판순회2-10971","date":"2019-12-02T07:33:31.000Z","updated":"2020-09-07T21:04:13.875Z","comments":true,"path":"2019/12/02/백준외원판순회2-10971/","link":"","permalink":"http://gwanhyeon.github.io/2019/12/02/%EB%B0%B1%EC%A4%80%EC%99%B8%EC%9B%90%ED%8C%90%EC%88%9C%ED%9A%8C2-10971/","excerpt":"","text":"백준외원판순회2 10971 1. 컴퓨팅 스킬 W[i][j]는 도시 i에서 도시 j로 가기 위한 비용이므로 모든 경우의 수 완전탐색을 수행합니다. N까지의 값을 vector에 넣어서 next_permutation을 수행합니다. next_permutation을 수행하는이유는 예를 들어 N이 4라고 하였을 경우 0,1,2,3까지의 값들을 vector에 넣고 모든 경우의 수를 만들어서 w[0][0], w[0][1]…w[0][3], w[1][0],w[1][1]…w[1][3]까지의 경우를 수행합니다. 2. 컴퓨팅 사고 잘못 접근하였던점 저 맵을 보는순간 비에프에스로 풀어도될 것같은데 라는생각을 하였습니다. 하지만, 전혀 다른 문제였으며 완전탐색을 통해 풀어야합니다. n값과 w 이차원배열에 비용을 입력받는다. w[i][i] = 0일 경우 비용이 없습니다. 모든 각 노드간의 간선의 비용에 따른 최소비용을 찾습니다. 마지막노드와 첫번째 노드를 연결시키는 부분이 가장 핵심문제입니다. 직접 손으로 그래프를 그려보았습니다. 시간복잡도 O(N*N!) N! = 10! = 3628800 마지막노드에서 첫번째노드를 연결시킬 방법의 조건을 잘 찾아야한다. 가는경우의수와 다시 돌아오는 경우의수를 체크합니다. 3. 풀이 3.1. next_permutation을 사용한 풀이 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//// 06_백준_외원판순회2_10971.cpp// algorithm-level-up//// Created by kgh on 30/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int w[11][11];int n;int main(void)&#123; vector&lt;int&gt; v; cin &gt;&gt; n; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;n; j++)&#123; cin &gt;&gt; w[i][j]; &#125; &#125; for(int i=0; i&lt;n; i++)&#123; v.push_back(i); &#125; int min=210000000; sort(v.begin(),v.end()); do&#123; int sum = 0; bool check = true; for(int i=0; i&lt;n-1; i++)&#123; if(w[v[i]][v[i+1]] == 0)&#123; check = false; &#125;else&#123; sum = sum + w[v[i]][v[i+1]]; &#125; &#125; if(check &amp;&amp; w[v[n-1]][v[0]] != 0)&#123; sum = sum + w[v[n-1]][v[0]]; if(min &gt; sum)&#123; min = sum; &#125; &#125; &#125;while(next_permutation(v.begin(),v.end())); cout &lt;&lt; min &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"}]},{"title":"백준123더하기9095","slug":"백준123더하기9095","date":"2019-11-28T14:57:13.000Z","updated":"2020-09-07T21:03:48.779Z","comments":true,"path":"2019/11/28/백준123더하기9095/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/28/%EB%B0%B1%EC%A4%80123%EB%8D%94%ED%95%98%EA%B8%B09095/","excerpt":"","text":"백준 1,2,3더하기 9095 1. 컴퓨팅적 스킬 DFS 재귀함수 이용 vector에 테스트케이스 개수만큼의 값들을 넣어준 후, 반복문을 통해 각 경우에 대한 dfs를 호출하여 최종적으로 리턴되는값은 1,2,3으로 만들 수 있는 n에 대한 경우의 수입니다. dfs를 이해하기에 가장 좋은 예중 하나는 n과m문제입니다. 순열과 조합에 대표적인 문제입니다. 이 시리즈들을 모두 재귀로 한번 풀어보시길 바랍니다. N과 M시리즈 문제집 2. 컴퓨팅적 사고 v == sum 일 경우 1,2,3으로 만들 수 있는 경우의 수 이기때문에 return 1을 해줍니다. v &lt; sum 일 경우 return 0으로 현재 들어온 값을 재귀함수 종료시켜줍니다. dfs(v,n,sum+1) 1의 경우, dfs(v,n,sum+2) 2의 경우, dfs(v,n,sum+3) 3의 경우입니다. 1,2,3을 더하는 경우이므로 dfs(v,n,sum+1)+dfs(v,n,sum+2)+dfs(v,n,sum+3) 의 값을 반환시켜주면 현재까지 경우의 수를 반환시켜줍니다. 언제 종료될것인가의 조건과 그 조건을 넘어섰을때 조건을 잘 생각해서 로직을 구현하여야 합니다. 3. 풀이 3.1. DFS 1234567891011121314151617181920212223242526272829303132333435363738394041//// 04_백준_1,2,3더하기_9095.cpp// algorithm-level-up//// Created by kgh on 30/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int cnt = 0;int dfs(int v, int n,int sum)&#123; //값에 부합할 경우 if(v == sum)&#123; return 1; &#125; //값의 범위를 넘어가게되면 그 이외의 값들이 들어가게되기때문에 반드시 필요한 조건 if(v &lt; sum)&#123; return 0; &#125; return dfs(v,n,sum+1)+dfs(v,n,sum+2)+dfs(v,n,sum+3);&#125;int main(void)&#123; int n=0; cin &gt;&gt; n; vector&lt;int&gt; v(n); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; for(int i=0; i&lt;v.size(); i++)&#123; cout &lt;&lt; dfs(v[i], n, 0) &lt;&lt; \"\\n\"; &#125; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"}]},{"title":"백준차이를최대로10819","slug":"백준차이를최대로10819","date":"2019-11-28T14:57:13.000Z","updated":"2020-09-07T21:03:55.501Z","comments":true,"path":"2019/11/28/백준차이를최대로10819/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/28/%EB%B0%B1%EC%A4%80%EC%B0%A8%EC%9D%B4%EB%A5%BC%EC%B5%9C%EB%8C%80%EB%A1%9C10819/","excerpt":"","text":"백준 차이를최대로 10819 1. 컴퓨팅 스킬 #include헤더에 있는 next_permutation()함수를 호출하여 순열과조합을 구현합니다. next_permutation : 현재 나와 있는 수열에서 인자로 넘어간 범위에 해당하는 다음 순열을 구하고 true를 반환한다. 다음 순열이 없다면(다음에 나온 순열이 순서상 이전 순열보다 작다면) false를 반환합니다. prev_permutation : 현재 나와 있는 수열에서 인자로 넘어간 범위에 해당하는 이전 순열을 구하고 true를 반환한다. 이전 순열이 없다면(다음에 나온 순열이 순서상 이전 순열보다 크다면) false를 반환합니다. #include헤더에 있는 abs절대값 함수를 사용합니다.(해당조건) 반드시 정렬이 수행되어야만 올바를 결과값을 얻을 수 있습니다. 2. 컴퓨팅 사고 |A[0] - A[1]| + |A[1] - A[2]| + … + |A[N-2] - A[N-1]|의 조건에 따라 반복문을 통하여 해당조건에 순열의 첫번째 경우, 두번째 경우, …마지막 경우에 따라 int sum의 값에 저장한 후 그 값을 max값과 비교한다. 최대값을 구해야하므로 이러한 일련의 과정이 필요합니다. sum += abs(v[i] - v[i+1]); 의 식으로 현재 순열과조합의 경우에서 값들의 합을 구합니다. 이때 i값과 i+1값의 범위가 벗어나지 않는지 반드시 확인합니다. for문을 v.size()만큼 순회하면 오버플로우가 발생합니다. max값과 sum의 값을 비교한 후 sum의 값이 max값보다 클 경우 max값을 해당 sum의 값으로 업데이트 시켜줍니다.(최대값) next_permutation의 수행이 모두 끝나면 현재 max을 출력합니다. 현재 최대값이 저장되어 있습니다. 3. 풀이 3.1. next_permutation을 사용한 풀이 12345678910111213141516171819202122232425262728293031323334353637//// 05_백준_차이를최대로_10819.cpp// algorithm-level-up//// Created by kgh on 30/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(void)&#123; int n=0; cin &gt;&gt; n; vector&lt;int&gt; v(n); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; int max = 0; sort(v.begin(), v.end()); do&#123; int sum = 0; for(int i=0; i&lt;v.size()-1; i++)&#123; sum += abs(v[i] - v[i+1]); &#125; if(max &lt; sum)&#123; max = sum; &#125; &#125;while(next_permutation(v.begin(), v.end())); cout &lt;&lt; max &lt;&lt; \"\\n\"; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"}]},{"title":"백준날짜계산1476","slug":"백준날짜계산1476","date":"2019-11-28T08:57:13.000Z","updated":"2020-09-07T21:03:43.928Z","comments":true,"path":"2019/11/28/백준날짜계산1476/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/28/%EB%B0%B1%EC%A4%80%EB%82%A0%EC%A7%9C%EA%B3%84%EC%82%B01476/","excerpt":"","text":"백준 날짜계산 1476 1. 컴퓨팅적 스킬 단순 반복문과 조건문을 이용한 사칙연산 문제 while문을 이용해 지구,태양,달이 해당 입력값과 맞을 경우 break; 2. 컴퓨팅적 사고 년도가 증가할때마다 E,S,M이 1씩 증가한다. 지구 1&lt;=E&lt;=15, 태양1&lt;=S&lt;=28, 달 1&lt;=m&lt;=19의 범위를 벗어나게 된다면 해당 값을 1로 초기화 시켜야합니다. E == 16, S == 29, M == 19일때 1로 초기화 입력 x,y,z 지구,태양,달을 입력 받았을때 x == E, y == S, z == M 지구,태양,달이 같은 연도를 찾은것이므로 종료시킵니다. 이때, sum은 몇년이 지났는지를 카운팅한 변수입니다. 따라서 sum을 출력시켜 정답을 도출시킵니다. 계산 범위를 잘 생각해서 풀어야합니다. 3. 풀이 3.1. 모든경우의 수를 찾습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// 02_백준_날짜계산_1476.cpp// algorithm-level-up//// Created by kgh on 28/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int main(void)&#123; int x,y,z = 0; // 입력 int e=1; int s=1; int m=1; // 지구, 태양, 달 cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; int sum = 1; // 연도 while(true)&#123; if(e == x &amp;&amp; s == y &amp;&amp; m == z)&#123; cout &lt;&lt; sum &lt;&lt; '\\n'; break; &#125; e +=1; s +=1; m +=1; sum +=1; // 지구범위 if(e == 16)&#123; e = 1; &#125; // 태양범위 if(s == 29)&#123; s = 1; &#125; // 달 범위 if(m == 20)&#123; m = 1; &#125; &#125; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"}]},{"title":"백준일곱난쟁이2309","slug":"백준일곱난쟁이2309","date":"2019-11-28T08:57:13.000Z","updated":"2020-09-07T21:03:37.538Z","comments":true,"path":"2019/11/28/백준일곱난쟁이2309/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/28/%EB%B0%B1%EC%A4%80%EC%9D%BC%EA%B3%B1%EB%82%9C%EC%9F%81%EC%9D%B42309/","excerpt":"","text":"백준 일곱난쟁이 2309 1. 컴퓨팅적 스킬 do while ~ (next_permutation)으로 계속해서 다음 조합의 경우의 수를 찾는다. vector v, check변수를 선언하여 permutation을 수행한다. 9명중 7명을 뽑아야하므로 7명만큼 check=true로 변경해서 수행한다. next_permutation을 수행하면서 값들이 계속변경되기 때문에 값이 변경되면서 출력된다. 2. 컴퓨팅적 사고 백설공주를 도와 키를 확인하여 난쟁이를 찾자. 9명의 난쟁이 중에 7명의 난쟁이를 골라 키의 합이 100이 되는 경우를 찾아야한다. 9명중에 7명을 고르는 것은 9C7 = 9C2와 같은 경우의 수이다. 9명중 2명을 골랐을때 두명을 고르는 수는 O(N^2) * 난쟁이의 키의 합을 고르는 복잡도 O(N) = O(N^3)의 시간복잡도를 갖는다. N=9명이므로 9^3 = 729의 모든경우의 수에서 찾을 수 있다. 경우 1)난쟁이가 아닌 9명중 2명을 뽑는 경우를 구해서 sum의 값에서 그 해당 값들을 뺐을때 합이 100인경우를 찾는다. 경우 2)next_permutation을 돌려서 9명중 7명을 선택해서 그 값이 100일때 그 값들을 출력시켜준다. 이때 check변수를 선언하여 7명을 선택해야하는 경우를 true로 바꾸어주면서 수행한다. 주의해야 할점: 정렬이 되어있는 상태여야 한다. 3. 풀이 3.1. 이중 포문 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(void)&#123; int n = 9; int sum = 0; vector&lt;int&gt; v(n); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; sum += v[i]; &#125; sort(v.begin(), v.end()); for(int i=0; i&lt;n; i++)&#123; for(int j=i+1; j&lt;n; j++)&#123; if(sum - v[i] - v[j] == 100)&#123; for(int z=0; z&lt;n; z++)&#123; if(i == z || j == z)&#123; continue; &#125; cout &lt;&lt; v[z] &lt;&lt; '\\n'; &#125; break; &#125; &#125; &#125; return 0;&#125; 3.2. next_permutation 조합 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(void)&#123; int n = 9; vector&lt;int&gt; v(n); vector&lt;bool&gt; check(n); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; v[i]; &#125; for(int i=0; i&lt;7; i++)&#123; check[i] = true; &#125; sort(v.begin(), v.end()); do &#123; int sum = 0; for(int i=0; i&lt;n; i++)&#123; if(check[i] == true)&#123; sum += v[i]; &#125; &#125; if(sum== 100)&#123; for(int i=0; i&lt;7; i++)&#123; cout &lt;&lt; v[i] &lt;&lt; \"\\n\"; &#125; break; &#125; &#125; while (next_permutation(v.begin(),v.end()));&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"브루트포스","slug":"브루트포스","permalink":"http://gwanhyeon.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"}]},{"title":"이진탐색트리 BST","slug":"bst","date":"2019-11-22T16:21:08.000Z","updated":"2020-09-07T21:03:24.506Z","comments":true,"path":"2019/11/23/bst/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/23/bst/","excerpt":"","text":"검색트리 Search Tree 1. 계층적인 구조를 표현 조직도 디렉토리와 서브디렉토리 구조 가계도 2. 트리의 특징 트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됩니다. 맨 위의 노드를 &quot;루트(root)&quot;라고 부릅니다. 노드를 연결하는 선을 &quot;link&quot;, &quot;edge&quot;,&quot;branch&quot; 부모노드 자식노드로 구성되어있습니다. 루트노드를 제외한 트리의 모든 노드들은 유일한 부모노드를 갖습니다. 부모가 동일한 노드들을 형제 &quot;sibling&quot;관계라고 부릅니다. 자식이 없는 노드들을 &quot;leaf&quot;노드라고 부릅니다. “leaf” 노드가 아닌것 내부 노드라고 부릅니다. 조상-자손 관계가 있다. 부모-자식관계를 확장한것 (ancestor-descendant) 관계 루트는 레벨관계 Level 0 ~ Level N 까지 갖습니다. 트리의 기본적인 성질 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가집니다. 트리에서 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간의 경로도 유일(존재,1개)합니다.(단, 같은 노드를 두 번 이상 방문하지 않는다) 트리의 높이는 레벨의 개수입니다. 1. 이진 트리 Binary Tree 1.1. 특징 이진 트리에서 각 노드는 최대 2개의 자식을 가집니다. 각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정됩니다.(자식이 한 명인 경우에도) 서로 다른 이진트리는 값의 위치가 다르면 서로 다른 이진트리라고 불리온다. (자식노드가 한개인 경우에도 해당됩니다) 1.2. 이진트리의 응용 Expression Tree, Huffman Code (x+y) * ((a + b) / c) 를 이진 트리형태로 나타낼 수 있다. Expression트리에서 응용한다. 허프만 코드 ‘A’ - ‘Z’, ‘a’ - ‘z’ 파일들의 알파벳을 어떤 데이터를 압축하는 것을 뜻한다. 파일의 길이가 최소가 되도록 하는 알고리즘(파일 압축) 1.3. Full Binary Trees And Complete Binary Trees Full Binary Trees 모든 레벨에서 노드에 채워져 있는 경우 Completr Binary Trees 맨 마지막경우에는 노드가 없을 수 있다.(단, 끝에서부터 노드가 없을 수 있다.) 높이가 h인 full binary tree는 2^h-1개의 노드를 가진다. 노드가 N개인 full 혹은 complete 이진 트리의 높이는 O(logN)이다.(노드가 N개인 이진트리의 높이는 최악의 경우 N이 될 수 있다.) 1.4. 이진트리의 표현 Heap은 Complete Binary Tree이다. 연결 구조 표현 각 노드에 하나에의 데이터필드와 왼쪽자식(left), 오른쪽 자식(right),그리고 부모노드§의 주소를 저장 부모노드는 주소는 반드시 필요한 경우가 아니면 보통 생략함 1.5. 이진트리의 순회(Traversal) 순회: 이진 트리의 모든 노드를 방문하는 일 중순위(inorder) 순회 왼쪽자식기준으로 루트노드를 중간에 방문한다. 왼쪽 자식 노드-&gt;루트-&gt;오른쪽 자식 노드 123pre-order-tree-walk(left[x])print key[x]pre-order-tree-walk(right[x]) 선순위(preorder) 순회 왼쪽자식기준으로 루트노드를 처음에 방문한다. 루트 노드-&gt;왼쪽 자식 노드-&gt;오른쪽 자식 노드 123print key[x]pre-order-tree-walk(left[x])pre-order-tree-walk(right[x]) 후순위(postorder) 순회 왼쪽기준으로 루트노드를 마지막에 방문한다. 왼쪽 자식 노드-&gt;루트 노드-&gt;중간 자식 노드 123pre-order-tree-walk(left[x])pre-order-tree-walk(right[x])print key[x] 레벨오더(level-order) 순회 레벨 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로 방문합니다. 큐(queue)를 이용하여 구현 트리에 [1,2,3,4,5,6,7]이 순서대로 있다고하면 레벨별로 하나씩 방문한다(단, 기준은 왼쪽) Level 0: 1 Level 1: 2,3 Level 2: 4,5,6,7 해당 순서로 방문한다고 생각하면 됩니다. 1.6. Dynamic Set 여러개의 데이터의 집합을 뜻하는 말을 일컫습니다. 여러 개의 키(Key)를 저장합니다. 다음과 같은 연산들을 지원하는 자료구조입니다. INSERT - 새로운 키의 삽입 SEARCH - 키 탐색 DELETE - 키의 삭제 예: 심볼 테이블 1.7. 배열 정렬 O 검색: O(logN) 삽입: O(N) 삭제: O(N) 정렬 X 검색: O(N) 삽입: O(1), O(N) 삭제: O(1) 1.8. 연결리스트 정렬 O 검색: O(N), O(logN) 삽입: O(N) 삭제: O(1) 정렬 X 검색: O(N) 삽입: O(1) 삭제: O(1) 정렬이 이루어지면 이진검색 O(logN)의 시간복잡도 만큼수행된다. 예를 들면, 1,2,4,8 의 형식으로 트리의 노드의 개수가 증가된다고 하면 2^k = N으로 나타낼 수 있다. k는 시행횟수이며, N은 입력된 개수입니다. 이것을 K = log2N으로 나타낼 수 있습니다. 이때 시간복잡도에서는 상수를 무시하기 때문에 K=logN으로 나타낼 수 있습니다. 따라서, 이진탐색의 시간복잡도는 O(logN) 입니다. 1.9. 다양한 방법들 정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(N) 이진탐색트리(Binary Search Tree), 레드-블랙트리, AVL-트리 등의 트리에 기반한 구조들 Direct Address Table, 해쉬 테이블 등 1.10. 검색트리 Dynamic set을 트리의 형태로 구현 일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height)에 비례하는 시간복잡도를 가짐 이진검색트리(Binary Search Tree), 레드-블랙 트리(Red-black tree), B-트리 등 2. 이진탐색트리 Binary Search Tree 2.1. 이전검색트리(BST) 특징 이진트리이면서 각노드에 하나의 키를 저장 각 노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같다. 중위 순회의 값을 갖는다 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다. 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다. 중복된 노드가 없어야 한다. 왼쪽 서브트리, 오른쪽 서브트리 또한 이진탐색트리이다. 2.2. 1.SEARCH 12345678910111213RECURSIVETREE-SEARCH(x,k) x = 루트노드, k = 찾는값 // x가 null이거나 k == key[x]를 찾은 경우(원하는 값을 찾은 경우) if x == NULL || k == key[x] then return x; // 키보다 작을 경우 if k &lt; key[x] then return TREE-SEARCH(left[x],k) // 키보다 클경우 else then return TREE-SEARCH(right[x],k) 12345678NONE RECURSIVEITERATIVE-TREE-SEARCH(x,k) While x != NULL and K != key[x] do if k &lt; key[x] then x &lt;- left[x] else x &lt;- rgiht[x] return x; 시간복잡도: O(h), h = 트리의 높이","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"검색트리","slug":"검색트리","permalink":"http://gwanhyeon.github.io/tags/%EA%B2%80%EC%83%89%ED%8A%B8%EB%A6%AC/"},{"name":"이진탐색트리","slug":"이진탐색트리","permalink":"http://gwanhyeon.github.io/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC/"},{"name":"BST","slug":"bst","permalink":"http://gwanhyeon.github.io/tags/bst/"}]},{"title":"N-Queen 문제","slug":"n-queen","date":"2019-11-22T15:02:37.000Z","updated":"2020-09-07T21:03:30.300Z","comments":true,"path":"2019/11/23/n-queen/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/23/n-queen/","excerpt":"","text":"N-Queen문제 1. 컴퓨팅적 스킬 Recursive() 재귀함수 어느지점에서 종료시키고, 다시 재귀호출을 해야하는지의개념을 확실하게 알고 있어야합니다. Recursive()의 개념을 잡기에 좋은 문제는 백준 N과 M시리즈 입니다. 개념이 약하신분들은 순열과 조합의 개념부터 확실히 잡고 오시는것이 좋을 것이라고 생각을 합니다. 백트래킹 깊이우선탐색(DFS)의 개념을 알아야합니다. 깊이우선탐색은 보통 Recursive, Stack를 사용합니다. Recursive가 직관적이고 코드이해하기도 쉽고, 스택보다는 구현이 덜 복잡하다는 장점이 있어서 Recursive로 구현하겠습니다. 2. 컴퓨팅적 사고 깊이우선탐색(DFS) 진행한 Level과 모든 말을 놓는 경우의 수가 같을때 재귀호출을 종료해야합니다. NNN … N^N의 시간복잡도를 갖습니다. 백트래킹의 개념에 대해 알고 있어야 한다. 깊이우선탐색의 트리형태로 어떻게 진행하는지 직접 손으로 써보면서 진행해야합니다. 상태공간트리의 개념을 알고 있어야합니다. 상태공간트리란 찾는 해를 포함하는 트리이며 이트리안에 어떠한 노드에 해당하는 이 트리를 체계적으로 탐색하면서 반드시 해를 찾을 수 있어야합니다. 해당 퀸이 열 있는지 체크와 대각선을 체크해야합니다. 예를 들어 설명하겠습니다. 12345start에서 시작하면서 트리의 형태로 가지를 치면서 진행합니다. start-&gt; (0,0) (0,1) (0,2) (0,3) 첫번째 열에서 갈수 있는 모든 경우의 수입니다.(1,0) (1,1) (1,2) .... 두번째 열에서 갈 수 있는 경우의 수(level, 1) (level, 2) (level, 3) Level 크기에서 갈 수 있는 경우의 수 0 1 2 3 Level 0 (0,0) (0,1) (0,2) (0,3) Level 1 (1,0) (1,1) (1,2) (1,3) Level 2 (2,0) (2,1) (2,2) (2,3) Level 3 (3,0) (3,1) (3,2) (3,3) 다음의 상황은 Level 0 ~ Level N 의 경우까지 진행하는 경우라고 생각하겠습니다. Level0의 경우에서 갈 수 있는 모든경우를 탐색하면서 퀸을 놓습니다. 그리고 다음 Level1으로 진행하면서 열에 들어갈 수 있는 경우를 확인하면서 진행합니다. 이때 알아야 하는 부분이 Promissing의 개념입니다. 즉,Level0 (0,0)에 퀸을 놓으면 Level1 (1,0)에 퀸을 놓는 경우를 확인해보겠습니다. 퀸을 놓을 수 있는 조건은 동, 서, 남, 북, 대각선에 퀸이 위치해있으면 놓을 수 없습니다. 그러면 당연히 (1,0)은 확인할 필요도 없이 놓을 수 없는 경우의 수라는것입니다. 이것을 Promissing의 개념을 확인하여 더 갈 수 있는지 없는지를 판단하는 것입니다. 체크한다고 하시면 됩니다. 레벨의 수가 결국 말의 개수를 뜻합니다. 제 코드에서는 cols라는 배열이 쓰이는데 이것은 현재 말이 어디에 놓였는지에 대한 위치입니다. cols[1] : 1번말이 놓인 열 , cols[2] : 2번말이 놓인 열 … cols[i] = j (i번말이 j에 놓였다는 의미입니다. i는 결국 레벨입니다.) Promissing Test를 진행할 때 마지막에 놓인 이 말이 이전에 놓인 다른 말들과 충돌하는지 검사를 하면 퀸을 놓을수 있는지 없는지를 확인 할 수 있습니다. 2.1. Recursive 설계 promising()함수를 호출합니다. 진행이 가능한지 여부를 확인하고 아니면 false, 가능하면 true를 리턴합니다. 1234// 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다. if(!promissing(level,N))&#123; return false; &#125; Level과 N의 값이 같은 경우(성공한 경우) 12345// 성공적으로 도착하였을 경우 else if(level == N)&#123; // 기존의 N-queen의 위치를 구하면 종료하는 형식이였지만, 모든 경우의 수를 구하기 위해서는 해당 cnt값을 증가시켜주어서 확인할 수 있다. cnt+=1; &#125; Level과 N의 값이 같지 않은 경우 Recursive() 재귀 함수 호출 1234567for(int i=1; i&lt;=N; i++)&#123; cols[level+1] = i; // 다음 레벨로 재귀 호출 if(recursive(level+1,N))&#123; return true; &#125; &#125; 2.2. Promising Test 설계 같은 열을 확인하여야합니다. 1234// 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미)) if(cols[i] == cols[level])&#123; return false; &#125; 같은 대각선에 놓였는지를 확인하여야 합니다. 1234// 대각선에 충돌되는것 확인 else if((level-i) == abs(cols[level] - cols[i]))&#123; return false; &#125; 3. 풀이 3.1. 1. DFS 백트래킹 해당 값 찾기(기본 개념) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// n-queen.cpp// algorithm-level-up//// Created by kgh on 22/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cols[10001];int cnt = 0;bool promissing(int level,int N)&#123; for(int i=1; i&lt;level; i++)&#123; // 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미)) if(cols[i] == cols[level])&#123; return false; &#125; // 대각선에 충돌되는것 확인 else if((level-i) == abs(cols[level] - cols[i]))&#123; return false; &#125; &#125; return true;&#125;bool recursive(int level,int N)&#123; // 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다. if(!promissing(level,N))&#123; return false; &#125; // 성공적으로 도착하였을 경우 else if(level == N)&#123; for(int i=1; i&lt;=N; i++)&#123; cout &lt;&lt; \"(\" &lt;&lt; i &lt;&lt; \",\" &lt;&lt; cols[i] &lt;&lt; \")\"; &#125; return true; &#125; for(int i=1; i&lt;=N; i++)&#123; cols[level+1] = i; // 성공할 경우 if(recursive(level+1,N))&#123; return true; &#125; &#125; return false;&#125;int main(void)&#123; int N = 8; recursive(0,N); cout &lt;&lt; cnt; return 0;&#125; 3.2. 2. DFS 백트래킹 해당 값 찾기(경우의 수 찾기 백준 문제) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//// n-queen.cpp// algorithm-level-up//// Created by kgh on 22/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int cols[10001];int cnt = 0;bool promissing(int level,int N)&#123; for(int i=1; i&lt;level; i++)&#123; // 같은 열에 놓였는지 확인 (레벨과 행이 같다는 의미임(결국 충돌이 있다는 의미)) if(cols[i] == cols[level])&#123; return false; &#125; // 대각선에 충돌되는것 확인 else if((level-i) == abs(cols[level] - cols[i]))&#123; return false; &#125; &#125; return true;&#125;bool recursive(int level,int N)&#123; // 1. 정답을 찾을 수 없는 경우 예를 들어 1,1 에서 2,1은 당연히 될수없는것이니까 프로미싱을 확인한다고 생각하면 된다. if(!promissing(level,N))&#123; return false; &#125; // 성공적으로 도착하였을 경우 else if(level == N)&#123; // 기존의 N-queen의 위치를 구하면 종료하는 형식이였지만, 모든 경우의 수를 구하기 위해서는 해당 cnt값을 증가시켜주어서 확인할 수 있다. cnt+=1; &#125; for(int i=1; i&lt;=N; i++)&#123; cols[level+1] = i; // 성공할 경우 if(recursive(level+1,N))&#123; return true; &#125; &#125; return false;&#125;int main(void)&#123; int N; cin &gt;&gt; N; recursive(0,N); cout &lt;&lt; cnt; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"백준","slug":"백준","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"name":"DFS","slug":"dfs","permalink":"http://gwanhyeon.github.io/tags/dfs/"},{"name":"백트래킹","slug":"백트래킹","permalink":"http://gwanhyeon.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"}]},{"title":"프로그래머스 더 맵게","slug":"프로그래머스더맵게","date":"2019-11-20T14:47:05.000Z","updated":"2020-09-07T21:03:19.697Z","comments":true,"path":"2019/11/20/프로그래머스더맵게/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/20/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EB%8D%94%EB%A7%B5%EA%B2%8C/","excerpt":"","text":"프로그래머스 더 맵게 문제 1. 컴퓨팅적 스킬 이번 문제를 해결하기 위해서는 단순 sort를 사용하는것이 아니라 우선순위큐 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; 오름차순 형식으로 써주어야합니다. 단순히 while문을 통해서 안에서 sort를 처리하려고 하였지만 16번 테스트케이스를 통과하지 못하였고 효율성에서는 시간초과가 발생하였습니다. 또한, 범위값이 너무 제한적이였다. 그래서 우선순위큐를 사용하였습니다. 123scoville의 길이는 1 이상 1,000,000 이하입니다.K는 0 이상 1,000,000,000 이하입니다.scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 주의해야할점은 우선순위큐 push는 맨앞으로 들어간다는것과 top에 있는것도 0번째 인덱스에 있는 값입니다. 2. 컴퓨팅적 사고 스코빌 벡터에 있는 값을 우선순위큐에 넣어준다. greater&lt;int&gt;를 옵션으로 지정하였기 때문에 자동으로 오름차순으로 정렬해줍니다. 만약 내림차순으로 하고 싶은경우 less옵션을 사용하시면 됩니다. 첫번째, 두번째값을 통하여 스코빌 지수를 구합니다. 단 q.top()의 값이 K보다 작아야합니다. 반복문 조건 12345예시스코빌 1 2 3 9 10일경우 (1 + 2 * 2) 5 3 9 10 으로 변경됩니다. 우선순위큐 이므로 3 5 9 10 정렬됩니다.(3 + 5 * 2) 13 9 10 으로 변경됩니다. 우선순위큐 이므로 9 10 13 정렬됩니다....... 기존의 while문에서는 sort를 다시해주어야하는데 우선순위 큐가 자동으로 정렬시켜주기때문에 필요없는 과정입니다. 만약 우선순위큐의 사이즈가 2이하가 되면 더이상 구할 수 없으므로 Return -1을 실행합니다. 그게 아니라면 계속 진행하고 q.top()의 값이 K보다 큰 경우가 있으면 더이상 반복문을 반복하지 않습니다. 3. 풀이 3.1. 1. 일반적인 sort 풀이(시간초과) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// 더맵게 일반 정렬.cpp// algorithm-level-up//// Created by kgh on 20/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main(void)&#123; vector&lt;int&gt; scoville; scoville.push_back(3); scoville.push_back(9); scoville.push_back(10); scoville.push_back(12); int K=7; int cnt = 0; int answer = 0; int len = scoville.size(); while(true)&#123; sort(scoville.begin(),scoville.end()); // 스코빌 첫번째 값이 K보다 작아야하고, cnt 값이 해당 스코빌 사이즈값이전까지 돌아아한다, 그리고 스코빌 사이즈는 2보다 커야한다. 아니면 -&gt; 메모리 에러남 if(scoville[0] &lt; K &amp;&amp; cnt &lt; len &amp;&amp; scoville.size() &gt; 2)&#123; int new_scoville=0; new_scoville = scoville[0] + (scoville[1] * 2); scoville[0] = new_scoville; scoville.erase(scoville.begin()+1); cnt+=1; &#125;else &#123; // 스코빌 첫번째지수가 K보다 작으면 결국 모든것이 되지않았으니까 cnt = 0; if(scoville[0] &lt; K)&#123; cnt = 0; &#125; break; &#125; &#125; if(cnt == 0)&#123; answer = -1; cout &lt;&lt; answer; &#125;else &#123; answer = cnt; cout &lt;&lt; answer; &#125; return 0;&#125; 3.2. 우선순위큐 사용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// 더맵게 우선순위큐.cpp// algorithm-level-up//// Created by kgh on 20/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main(void)&#123; vector&lt;int&gt; scoville; scoville.push_back(1); scoville.push_back(2); scoville.push_back(3); scoville.push_back(9); scoville.push_back(10); scoville.push_back(12); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q; int K = 7; for(int i=0; i&lt;scoville.size(); i++)&#123; q.push(scoville[i]); &#125; int min_num_first = 0; int min_num_second = 0; int res = 0; int cnt = 0; while(q.top() &lt; K)&#123; if(q.size() &lt; 2)&#123; return -1; &#125; min_num_first = q.top(); q.pop(); min_num_second = q.top(); q.pop(); res = min_num_first + (min_num_second * 2); q.push(res); cnt += 1; &#125; cout &lt;&lt; cnt;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io/tags/%EB%A0%88%EB%B2%A82/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"우선순위큐","slug":"우선순위큐","permalink":"http://gwanhyeon.github.io/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/"}]},{"title":"프로그래머스 가장 큰 수","slug":"프로그래머스큰수","date":"2019-11-16T00:14:41.000Z","updated":"2020-09-07T21:03:05.866Z","comments":true,"path":"2019/11/16/프로그래머스큰수/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%ED%81%B0%EC%88%98/","excerpt":"","text":"프로그래머스 가장 큰 수 문제 1. 컴퓨팅적 스킬 0 또는 양의 정수 1 &lt;= numbers_length &lt;= 100,000, 0 &lt;= numbers &lt;= 1000 를 보고 O(N^2) 복잡도 불가할 것이라 예측하였습니다. 왜냐하면 (100,000)^ = 약 100억 String to int 변환 함수 atoi(str.c_str()), int to String 변환함수 to_string(number) “String&quot; - ‘0’ =&gt; 숫자로 변경이 가능합니다. 단, 범위는 0~9까지 Number + ‘0’ =&gt; 문자로 변경이 가능합니다. 단, 범위는 0~9까지 숫자가 10이 나왔을 경우에는 dec = dec * 10 + str[i] - '0'의 형식으로 해주어야합니다. 유사문제로는 카카오 셔틀버스 문제가 있습니다. 1234567891011bool compare(const string &amp;s1, const string &amp;s2)&#123; return s1 + s2 &gt; s2 + s1 ? true : false;&#125;bool compare(const string &amp;s1, const string &amp;s2)&#123; if(s1 &gt; s2)&#123; return true; &#125;else &#123; return false; &#125;&#125; 2. 컴퓨팅적 사고 string기준으로 문제를 해결해야한다. 맨 처음 순열과 같이 DFS로 완전탐색을 하였지만 시간초과 가 나서 sort()함수 사용해봤지만 테스트케이스는 맞지만 시간초과는 그대로여서 시간복잡도에 고민을 한번 더 하였습니다. Sort Compare로 비교 후 정렬값들을 가지고 문자열끼리 append시켜주었으면 쉽게 해결하였을 문제였습니다. compare 함수 기본 형식(기본적으로 오름차순을 적용시킵니다.) 굳이 if문을 쓰지 않고 바로 return s1 &gt; s2형식으로 해주어도 됩니다. 3. 풀이 3.1. 1. DFS풀이(시간초과) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 가장큰수.cpp// algorithm-level-up//// Created by kgh on 14/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;bool check[100001];int ans = 0;int arr[100001];vector&lt;int&gt; value_v;bool compare(const string &amp;a, const string b)&#123; if(b.size() &gt; a.size())&#123; return b &gt; a; &#125;else &#123; return b &lt; a; &#125; &#125;void dfs(int idx,vector&lt;int&gt; v,int len)&#123; //len개를 모두 선택하였을 경우 if(idx == len)&#123; string str = \"\"; for(int i=0; i&lt;len; i++)&#123; str += to_string(value_v[i]); &#125; int comp = atoi(str.c_str()); if(comp &gt; ans)&#123; ans = comp; &#125; return; &#125; for(int i=0; i&lt;len; i++)&#123; if(check[i])&#123; continue; &#125; check[i] = true; value_v.push_back(v[i]); dfs(idx+1, v, len); value_v.pop_back(); check[i] = false; &#125;&#125;int main(void)&#123; vector&lt;string&gt; s; s.push_back(\"3\"); s.push_back(\"30\"); s.push_back(\"34\");s.push_back(\"5\");s.push_back(\"9\"); int len = s.size(); vector&lt;int&gt; v(len); sort(s.begin(), s.end(), compare); for(int i=0; i&lt;s.size(); i++)&#123; v[i] = atoi(s[i].c_str()); &#125; dfs(0,v,len); cout &lt;&lt; to_string(ans); return 0; &#125; 3.2. String 정렬 비교(시간초과 X 정답) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;bool compare(const string &amp;s1, const string &amp;s2)&#123; cout &lt;&lt; s1 + s2; cout &lt;&lt; s2 + s1 &lt;&lt; '\\n'; return s1 + s2 &gt; s2 + s1 ? true : false;&#125;int main(void)&#123; string ans = \"\"; vector&lt;int&gt; numbers; vector&lt;string&gt; s; numbers.push_back(3); numbers.push_back(30); numbers.push_back(34);numbers.push_back(5);numbers.push_back(9); int numbers_len = numbers.size(); for(int i=0; i&lt;numbers_len; i++)&#123; s.push_back(to_string(numbers[i])); &#125; sort(s.begin(), s.end(), compare); int s_len = s.size(); for(int i=0; i&lt;s_len; i++)&#123; ans += s[i]; &#125; if(ans[0] == '0') return \"0\"; cout&lt;&lt; ans; return 0; &#125; 유사문제: 백준 1422 숫자의 신","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io/tags/%EB%A0%88%EB%B2%A82/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}]},{"title":"프로그래머스 H-index","slug":"프로그래머스H-INDEX","date":"2019-11-15T23:11:02.000Z","updated":"2020-09-07T21:03:13.693Z","comments":true,"path":"2019/11/16/프로그래머스H-INDEX/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4H-INDEX/","excerpt":"","text":"프로그래머스 H-index 문제 1. 컴퓨팅적 스킬 정렬문제인 만큼 #include &lt;algorithm&gt; 헤더에 있는 sort를 이용하면 됩니다. sort는 기본적으로 오름차순 정렬로 되어있습니다. 별 다른 옵션을 주지 않아도 오름차순 정렬을 하게 됩니다. 그 외 내림차순정렬을 이용 할 때는 다음과 같은 두가지 방법을 사용할 수 있습니다. 1.compare함수를 이용한 내림차순 방법 1234bool compare(int v1,int v2)&#123; return v1 &lt; v2;&#125;sort(citations.begin(),citations.end(),compare); greater() 함수 옵션을 사용한 내림차순 정렬 1sort(citations.begin(),citations.end(),greater&lt;int&gt;()); 2. 컴퓨팅적 사고 H-index의 개념을 알고가셔야 합니다. 논문 n편중 h번이상 인용된 논문이 h편이상이고 h번 이하 인용되었다면 h가 H-index가 됩니다. 첫번째 테스트 케이스인 [3,0,6,1,5]로 예를 들어 설명하겠습니다. 오름차순 정렬 전 DATA INDEX 3 0 0 1 6 2 1 3 5 4 오름차순 정렬 후 DATA INDEX 0 0 1 1 3 2 5 3 6 4 3. 정렬전과 정렬후의 과정입니다.H-index라는것을 맨처음에 모든 값의 합을 나눈 평균의 값이 H-Index라고 생각을 하여 아주 단순하게 생각했습니다. 당연히 틀린것이였습니다. index를 가지고 생각했어야 했는데, 값을 가지고 생각을 하였습니다. 위의 테스트케이스는 총 5편의 논문이 쓰여졌으며 인덱스값이 DATA의 값보다 커지는 시점 index &gt; data을 찾아야 합니다. 그 시점이 H-index지점입니다.데이터값은 뒤에서부터 비교하고 인덱스값은 앞에서 비교하게 됩니다. 따라서 citations.size()-i-1의 형식이 나오게됩니다. -1을 해주는이유는 for문에서는citiation-1지점까지만 순회하기때문에 이에 따라 -1을 붙여준것입니다. 어디서부터 시작하고 어디서부터 끝내는지에 대해서 한번더 고민해보시면 되겠습니다. Data = 5, Index = 3의 지점이 H-index에 해당하는값 입니다. index&gt;data의 지점에 index는 3의 값을 반환하게 됩니다. 이 값은 결국 h-index의 값을 나타내는것이며 총 5편의 논문과 3회이상의 인용된 논문 3편, 3회 이하 인용된 논문 2편이 되게 됩니다. 따라서 h-index의 값을 정확하게 도출해냈다고 할 수 있습니다. 문제들을 너무 어렵게 생각하여 풀었는데, index에 대해 유연하게 접근하면 쉽게 풀 수 있었던 문제라고 생각합니다. 4. 풀이 4.1. 1. 정렬 풀이 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 오름차순 정렬, 내림차순은 그 반대 v1 &gt; v2bool compare(int v1,int v2)&#123; return v1 &lt; v2;&#125;int main(void)&#123; vector&lt;int&gt; citations; citations.push_back(3); citations.push_back(0); citations.push_back(6); citations.push_back(1); citations.push_back(5); sort(citations.begin(),citations.end(),compare); for(int i=0; i&lt;citations.size(); i++)&#123; if(i &gt;= citations[citations.size()-i-1])&#123; cout &lt;&lt; i; break; &#125; &#125; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io/tags/%EB%A0%88%EB%B2%A82/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"H-INDEX","slug":"h-index","permalink":"http://gwanhyeon.github.io/tags/h-index/"},{"name":"정렬","slug":"정렬","permalink":"http://gwanhyeon.github.io/tags/%EC%A0%95%EB%A0%AC/"}]},{"title":"프로그래머스 위장","slug":"프로그래머스위장","date":"2019-11-15T11:02:11.000Z","updated":"2020-09-07T21:02:40.473Z","comments":true,"path":"2019/11/15/프로그래머스위장/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%9C%84%EC%9E%A5/","excerpt":"","text":"프로그래머스 위장문제 컴퓨팅적 스킬 옷 종류 = KEY, 옷 이름= VALUE를 두고 문제를 해결해야 한다고 생각하였습니다. #include&lt;unordered_map&gt; 헤더에 포함된 unordered_map&lt;string,int&gt; 형태로 사용하려고 하였습니다. unordered와 map중 unordered 자료구조를 사용한 이유는 map은 balanced tree의 형태를 가지고 있고, unordered_map는 hash형태로 이루어져있기 때문에 성능차이의 이슈로 특별한 이유가 없는 한 unordered_map을 사용하려고 합니다. 주어진 파라미터 vector&lt;vector&gt; clothes; 의 형태가 주어졌는데요. 헷갈리는 부분이 있어서 설명하고 넘어가겠습니다. vector&lt;vector 2차원 벡터는 2차원 배열과 형태가 같습니다. 그리고, 2차원 벡터에 값을 넣게 될경우 주의해야할 점이 한가지 있습니다. 직접 접근해서 벡터값을 넣지 못하게 되어있다는것입니다. clothes[0].push_back(“yellow_hat”) 처럼 값을 넣으려고 하였지만, Xcode에서 Invalid operands to binary expression 에러가 나타났습니다. 직접적으로 2차원벡터에 값을 바로 접근하기가 불가능한 모양입니다. 그래서 1차원 벡터를 생성시킨 후 값을 넣어준 다음, 2차원 벡터에 값이 들어간 벡터를 넣었습니다. 프로그래머스에서 테스트케이스로 바로 Input을 주기 때문에 이러한 과정이 필요없지만, 직접 소스코드를 Xcode에 작성하면서 디버깅도 해보는편이라 저런형식으로 넣어주게 되었습니다. 123456789101112vector&lt;vector&lt;string&gt;&gt; clothes;vector&lt;string&gt; v1;vector&lt;string&gt; v2;vector&lt;string&gt; v3;v1.push_back(\"yellow_hat\"); v1.push_back(\"headgear\");v2.push_back(\"blue_sunglasses\"); v2.push_back(\"eyewear\");v3.push_back(\"green_turban\"); v3.push_back(\"headgear\");clothes.push_back(v1);clothes.push_back(v2);clothes.push_back(v3); 1차원 행부분에서 열부분을 참고하시면 모든값들을 가져올 수 있겠습니다. 그리고, auto를 사용하셔서 값들을 가져올 수도 있습니다. 아래와 같은 3가지 형식으로 사용하시면 됩니다. 12345678910111213141516for(int i=0; i&lt;clothes.size(); i++)&#123; m[clothes[i][1]]++;&#125;or for(auto p : clothes)&#123; cout&lt;&lt; p.at(0); cout&lt;&lt; p[0];&#125;or for(vector&lt;string&gt; s : clothes)&#123; cout&lt;&lt; s[0];&#125; map에 있는 값들을 모두 확인하기 위해서는iterator 를 사용하셔야 합니다. 사용하실 방식은 다음과 같습니다. map과 map::iterator를 선언시켜줍니다. 그리고 iter 변수를 사용해서 unordered_map에 있는 모든 값들을 탐색을 시작하게 됩니다. iter-&gt;first, iter-&gt;second로 참조하여 접근하게 되면 해당 맵의 &lt;string,int&gt;형태로 저장된 값을 가져올 수 있습니다. 12345unordered_map&lt;string,int&gt; m;unordered_map&lt;string,int&gt;::iterator iter;for(iter=m.begin(); iter != m.end(); iter++)&#123; answer *= (iter-&gt;second+1);&#125; – 1. 컴퓨팅적 사고 첫번째 테스트 케이스를 예시로 설명해보겠습니다. [headergear, eyewear] 의 두가지 종류가 있습니다. headgear를 입거나 안입는 경우 headgear = 2가지 경우, eyewear를 입거나 안입는 경우 1가지 경우입니다. 이것을 경우의 수로 적용시켜보겠습니다. (headgear +1)* (eyewear + 1)로 적용시키면 (2+1) * (1+1) = 6 - 1 = 5가지가 됩니다. 이때 +1을 왜 더하는거야? 라고 생각하실분이 있으실 것입니다. 그 이유는 의상을 입을까? 말까? 라는 경우를 고려해주어야하기 때문입니다. 그래서 +1을 해주게 되는것입니다. 마지막에 -1은 또 왜해주나요? 적어도 하나의 의상을 입어야하므로 모두 입지않는 경우의 수인 1가지 경우를 빼주어야 결국 모든 경우의 수의 조합이 나오게 될 것입니다. 모든 원소는 문자열로 이루어져있고, clothes는 [의상의 이름, 의상의 종류]의 형태를 가지고 있다. 따라서 해시 자료구조형을 사용해서 접근하면 된다. 처음에는 조합개념으로 dfs를 진행하려고 하였지만, 선택한 개수가 매번달라지는 경우때문에 dfs를 사용하지 않았습니다. 2. 풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// 위장문제.cpp// algorithm-level-up//// Created by kgh on 15/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main(void)&#123; unordered_map&lt;string,int&gt; m; vector&lt;vector&lt;string&gt;&gt; clothes; vector&lt;string&gt; v1; vector&lt;string&gt; v2; vector&lt;string&gt; v3; v1.push_back(\"yellow_hat\"); v1.push_back(\"headgear\"); v2.push_back(\"blue_sunglasses\"); v2.push_back(\"eyewear\"); v3.push_back(\"green_turban\"); v3.push_back(\"headgear\"); clothes.push_back(v1); clothes.push_back(v2); clothes.push_back(v3); for(int i=0; i&lt;clothes.size(); i++)&#123; m[clothes[i][1]]++; &#125; int answer = 1; unordered_map&lt;string,int&gt;::iterator iter; for(iter=m.begin(); iter != m.end(); iter++)&#123; answer *= (iter-&gt;second+1); &#125; cout &lt;&lt; answer-1; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io/tags/%EB%A0%88%EB%B2%A82/"},{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"위장","slug":"위장","permalink":"http://gwanhyeon.github.io/tags/%EC%9C%84%EC%9E%A5/"},{"name":"해시","slug":"해시","permalink":"http://gwanhyeon.github.io/tags/%ED%95%B4%EC%8B%9C/"}]},{"title":"Hexo 명령어","slug":"hexo- command","date":"2019-11-09T16:29:33.000Z","updated":"2020-09-07T21:02:27.353Z","comments":true,"path":"2019/11/10/hexo- command/","link":"","permalink":"http://gwanhyeon.github.io/2019/11/10/hexo-%20command/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start 1. front formatter 123456# post.md 머리말---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 123456tags:- 태그명 #(예) 헥소- 깃허브# 또는 아래와 같이 사용 할수 있다.tags: [헥소, 깃허브] 123456categories:- 카테고리명 #(예) 깃허브- 서브카테고리명 #(예) 헥소# 또는 아래 처럼 사용 할수 있다.categories: [깃허브, 헥소] 2. 3. Create a new post 123$ hexo new post \"My New Post\"$ hexo new draft \"My new Draft\"$ hexo new layout \"My New layout\" More info: Writing 4. Run server 123$ hexo server post$ hexo server draft$ hexo server layout More info: Server 5. Generate static files 12$ hexo generate$ hexo g More info: Generating 6. Deploy to remote sites 12$ hexo deploy$ hexo d More info: Deployment 7. Generate static files and Deploy to remote sites 12$ hexo clean$ hexo g -d 8. image files path 1source/images/image file path","categories":[{"name":"HEXO","slug":"hexo","permalink":"http://gwanhyeon.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://gwanhyeon.github.io/tags/hexo/"},{"name":"command","slug":"command","permalink":"http://gwanhyeon.github.io/tags/command/"}]}]}