{"meta":{"title":"KGH IT LOG","subtitle":"KGH IT LOG","description":"#BACK-END #SPRING #ALGORITHM","author":"Gwan-Hyeon Kim","url":"http://gwanhyeon.github.io.com","root":"/"},"pages":[{"title":"KGH IT Blog","date":"2019-11-04T17:19:11.000Z","updated":"2019-11-15T14:24:04.489Z","comments":true,"path":"about.html","permalink":"http://gwanhyeon.github.io.com/about.html","excerpt":"","text":"블로그 이전 작업중입니다. Tistory Github"}],"posts":[{"title":"프로그래머스 가장 큰 수","slug":"프로그래머스큰수","date":"2019-11-16T00:14:41.000Z","updated":"2019-11-16T01:25:11.422Z","comments":true,"path":"2019/11/16/프로그래머스큰수/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%ED%81%B0%EC%88%98/","excerpt":"","text":"프로그래머스 가장 큰 수 문제 컴퓨팅적 스킬 0 또는 양의 정수 1 &lt;= numbers_length &lt;= 100,000, 0 &lt;= numbers &lt;= 1000 를 보고 O(N^2) 복잡도 불가할 것이라 예측하였습니다. 왜냐하면 (100,000)^ = 약 100억 String to int 변환 함수 atoi(str.c_str()), int to String 변환함수 to_string(number) “String&quot; - ‘0’ =&gt; 숫자로 변경이 가능합니다. 단, 범위는 0~9까지 Number + ‘0’ =&gt; 문자로 변경이 가능합니다. 단, 범위는 0~9까지 숫자가 10이 나왔을 경우에는 dec = dec * 10 + str[i] - '0'의 형식으로 해주어야합니다. 유사문제로는 카카오 셔틀버스 문제가 있습니다. 1234567891011bool compare(const string &amp;s1, const string &amp;s2)&#123; return s1 + s2 &gt; s2 + s1 ? true : false;&#125;bool compare(const string &amp;s1, const string &amp;s2)&#123; if(s1 &gt; s2)&#123; return true; &#125;else &#123; return false; &#125;&#125; 컴퓨팅적 사고 string기준으로 문제를 해결해야한다. 맨 처음 순열과 같이 DFS로 완전탐색을 하였지만 시간초과 가 나서 sort()함수 사용해봤지만 테스트케이스는 맞지만 시간초과는 그대로여서 시간복잡도에 고민을 한번 더 하였습니다. Sort Compare로 비교 후 정렬값들을 가지고 문자열끼리 append시켜주었으면 쉽게 해결하였을 문제였습니다. compare 함수 기본 형식(기본적으로 오름차순을 적용시킵니다.) 굳이 if문을 쓰지 않고 바로 return s1 &gt; s2형식으로 해주어도 됩니다. 풀이 1. DFS풀이(시간초과) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 가장큰수.cpp// algorithm-level-up//// Created by kgh on 14/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;bool check[100001];int ans = 0;int arr[100001];vector&lt;int&gt; value_v;bool compare(const string &amp;a, const string b)&#123; if(b.size() &gt; a.size())&#123; return b &gt; a; &#125;else &#123; return b &lt; a; &#125; &#125;void dfs(int idx,vector&lt;int&gt; v,int len)&#123; //len개를 모두 선택하였을 경우 if(idx == len)&#123; string str = \"\"; for(int i=0; i&lt;len; i++)&#123; str += to_string(value_v[i]); &#125; int comp = atoi(str.c_str()); if(comp &gt; ans)&#123; ans = comp; &#125; return; &#125; for(int i=0; i&lt;len; i++)&#123; if(check[i])&#123; continue; &#125; check[i] = true; value_v.push_back(v[i]); dfs(idx+1, v, len); value_v.pop_back(); check[i] = false; &#125;&#125;int main(void)&#123; vector&lt;string&gt; s; s.push_back(\"3\"); s.push_back(\"30\"); s.push_back(\"34\");s.push_back(\"5\");s.push_back(\"9\"); int len = s.size(); vector&lt;int&gt; v(len); sort(s.begin(), s.end(), compare); for(int i=0; i&lt;s.size(); i++)&#123; v[i] = atoi(s[i].c_str()); &#125; dfs(0,v,len); cout &lt;&lt; to_string(ans); return 0; &#125; String 정렬 비교(시간초과 X 정답) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;bool compare(const string &amp;s1, const string &amp;s2)&#123; cout &lt;&lt; s1 + s2; cout &lt;&lt; s2 + s1 &lt;&lt; '\\n'; return s1 + s2 &gt; s2 + s1 ? true : false;&#125;int main(void)&#123; string ans = \"\"; vector&lt;int&gt; numbers; vector&lt;string&gt; s; numbers.push_back(3); numbers.push_back(30); numbers.push_back(34);numbers.push_back(5);numbers.push_back(9); int numbers_len = numbers.size(); for(int i=0; i&lt;numbers_len; i++)&#123; s.push_back(to_string(numbers[i])); &#125; sort(s.begin(), s.end(), compare); int s_len = s.size(); for(int i=0; i&lt;s_len; i++)&#123; ans += s[i]; &#125; if(ans[0] == '0') return \"0\"; cout&lt;&lt; ans; return 0; &#125; 유사문제: 백준 1422 숫자의 신","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io.com/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io.com/tags/%EB%A0%88%EB%B2%A82/"}]},{"title":"프로그래머스 H-index","slug":"프로그래머스H-INDEX","date":"2019-11-15T23:11:02.000Z","updated":"2019-11-16T01:26:32.062Z","comments":true,"path":"2019/11/16/프로그래머스H-INDEX/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4H-INDEX/","excerpt":"","text":"프로그래머스 H-index 문제 컴퓨팅적 스킬 정렬문제인 만큼 #include &lt;algorithm&gt; 헤더에 있는 sort를 이용하면 됩니다. sort는 기본적으로 오름차순 정렬로 되어있습니다. 별 다른 옵션을 주지 않아도 오름차순 정렬을 하게 됩니다. 그리고 내림차순정렬을 이용 할 때는 다음과 같은 두가지 방법을 사용할 수 있습니다. 1.compare함수를 이용한 내림차순 방법 1234bool compare(int v1,int v2)&#123; return v1 &lt; v2;&#125;sort(citations.begin(),citations.end(),compare); greater() 함수 옵션을 사용한 내림차순 정렬 1sort(citations.begin(),citations.end(),compare); 컴퓨팅적 사고 H-index의 개념을 알고가셔야 합니다. 논문 n편중 h번이상 인용된 논문이 h편이상이고 h번 이하 인용되었다면 h가 H-index가 됩니다. 첫번째 테스트 케이스인 [3,0,6,1,5]로 예를 들어 설명하겠습니다. 내림차순 정렬 전 DATA INDEX 3 0 0 1 6 2 1 3 5 4 내림차순 정렬 후 DATA INDEX 6 0 5 1 3 2 1 3 0 4 정렬전과 정렬후의 과정입니다.H-index라는것을 맨처음에 모든 값의 합을 나눈 평균의 값이 H-Index라고 생각을 하여 아주 단순하게 생각했습니다. 당연히 틀린것이였습니다. index를 가지고 생각했어야 했는데, 값을 가지고 생각을 하였습니다. 위의 테스트케이스는 총 5편의 논문이 쓰여졌으며 인덱스값이 DATA의 값보다 커지는 시점 index &gt; data을 찾아야 합니다. 그 시점이 H-index지점입니다. 오름차순의 경우에는 인덱스가 정확하지 않다고 생각하는데, 테스트케이스는 돌아가는것을 보고 의문이 조금 남긴했습니다만, 진행하겠습니다. index&gt;data의 지점에 index는 3의 값을 반환하게 됩니다. 이 값은 결국 h-index의 값을 나타내는것이며 총 5편의 논문과 3회이상의 인용된 논문 3편, 3회 이하 인용된 논문 2편이 되게 됩니다. 따라서 h-index의 값을 정확하게 도출해냈다고 할 수 있습니다. 문제들을 너무 어렵게 생각하여 풀었는데, index에 대해 유연하게 접근하면 쉽게 풀 수 있었던 문제라고 생각합니다. 풀이 1. 정렬 풀이 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool compare(int v1,int v2)&#123; return v1 &lt; v2;&#125;int main(void)&#123; vector&lt;int&gt; citations; citations.push_back(3); citations.push_back(0); citations.push_back(6); citations.push_back(1); citations.push_back(5); sort(citations.begin(),citations.end(),compare); for(int i=0; i&lt;citations.size(); i++)&#123; if(i &gt; citations[citations.size()-i-1])&#123; cout &lt;&lt; i; break; &#125; &#125; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io.com/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io.com/tags/%EB%A0%88%EB%B2%A82/"},{"name":"H-INDEX","slug":"h-index","permalink":"http://gwanhyeon.github.io.com/tags/h-index/"},{"name":"정렬","slug":"정렬","permalink":"http://gwanhyeon.github.io.com/tags/%EC%A0%95%EB%A0%AC/"}]},{"title":"프로그래머스 위장","slug":"프로그래머스위장","date":"2019-11-15T11:02:11.000Z","updated":"2019-11-16T00:17:20.101Z","comments":true,"path":"2019/11/15/프로그래머스위장/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%EC%9C%84%EC%9E%A5/","excerpt":"","text":"프로그래머스 위장문제 컴퓨팅적 스킬 옷 종류 = KEY, 옷 이름= VALUE를 두고 문제를 해결해야 한다고 생각하였습니다. #include&lt;unordered_map&gt; 헤더에 포함된 unordered_map&lt;string,int&gt; 형태로 사용하려고 하였습니다. unordered와 map중 unordered 자료구조를 사용한 이유는 map은 balanced tree의 형태를 가지고 있고, unordered_map는 hash형태로 이루어져있기 때문에 성능차이의 이슈로 특별한 이유가 없는 한 unordered_map을 사용하려고 합니다. 주어진 파라미터 vector&lt;vector&gt; clothes; 의 형태가 주어졌는데요. 헷갈리는 부분이 있어서 설명하고 넘어가겠습니다. vector&lt;vector 2차원 벡터는 2차원 배열과 형태가 같습니다. 그리고, 2차원 벡터에 값을 넣게 될경우 주의해야할 점이 한가지 있습니다. 직접 접근해서 벡터값을 넣지 못하게 되어있다는것입니다. clothes[0].push_back(“yellow_hat”) 처럼 값을 넣으려고 하였지만, Xcode에서 Invalid operands to binary expression 에러가 나타났습니다. 직접적으로 2차원벡터에 값을 바로 접근하기가 불가능한 모양입니다. 그래서 1차원 벡터를 생성시킨 후 값을 넣어준 다음, 2차원 벡터에 값이 들어간 벡터를 넣었습니다. 프로그래머스에서 테스트케이스로 바로 Input을 주기 때문에 이러한 과정이 필요없지만, 직접 소스코드를 Xcode에 작성하면서 디버깅도 해보는편이라 저런형식으로 넣어주게 되었습니다. 123456789101112vector&lt;vector&lt;string&gt;&gt; clothes;vector&lt;string&gt; v1;vector&lt;string&gt; v2;vector&lt;string&gt; v3;v1.push_back(\"yellow_hat\"); v1.push_back(\"headgear\");v2.push_back(\"blue_sunglasses\"); v2.push_back(\"eyewear\");v3.push_back(\"green_turban\"); v3.push_back(\"headgear\");clothes.push_back(v1);clothes.push_back(v2);clothes.push_back(v3); 1차원 행부분에서 열부분을 참고하시면 모든값들을 가져올 수 있겠습니다. 그리고, auto를 사용하셔서 값들을 가져올 수도 있습니다. 아래와 같은 3가지 형식으로 사용하시면 됩니다. 12345678910111213141516for(int i=0; i&lt;clothes.size(); i++)&#123; m[clothes[i][1]]++;&#125;or for(auto p : clothes)&#123; cout&lt;&lt; p.at(0); cout&lt;&lt; p[0];&#125;or for(vector&lt;string&gt; s : clothes)&#123; cout&lt;&lt; s[0];&#125; map에 있는 값들을 모두 확인하기 위해서는iterator 를 사용하셔야 합니다. 사용하실 방식은 다음과 같습니다. map과 map::iterator를 선언시켜줍니다. 그리고 iter 변수를 사용해서 unordered_map에 있는 모든 값들을 탐색을 시작하게 됩니다. iter-&gt;first, iter-&gt;second로 참조하여 접근하게 되면 해당 맵의 &lt;string,int&gt;형태로 저장된 값을 가져올 수 있습니다. 12345unordered_map&lt;string,int&gt; m;unordered_map&lt;string,int&gt;::iterator iter;for(iter=m.begin(); iter != m.end(); iter++)&#123; answer *= (iter-&gt;second+1);&#125; – 컴퓨팅적 사고 첫번째 테스트 케이스를 예시로 설명해보겠습니다. [headergear, eyewear] 의 두가지 종류가 있습니다. headgear를 입거나 안입는 경우 headgear = 2가지 경우, eyewear를 입거나 안입는 경우 1가지 경우입니다. 이것을 경우의 수로 적용시켜보겠습니다. (headgear +1)* (eyewear + 1)로 적용시키면 (2+1) * (1+1) = 6 - 1 = 5가지가 됩니다. 이때 +1을 왜 더하는거야? 라고 생각하실분이 있으실 것입니다. 그 이유는 의상을 입을까? 말까? 라는 경우를 고려해주어야하기 때문입니다. 그래서 +1을 해주게 되는것입니다. 마지막에 -1은 또 왜해주나요? 적어도 하나의 의상을 입어야하므로 모두 입지않는 경우의 수인 1가지 경우를 빼주어야 결국 모든 경우의 수의 조합이 나오게 될 것입니다. 모든 원소는 문자열로 이루어져있고, clothes는 [의상의 이름, 의상의 종류]의 형태를 가지고 있다. 따라서 해시 자료구조형을 사용해서 접근하면 된다. 처음에는 조합개념으로 dfs를 진행하려고 하였지만, 선택한 개수가 매번달라지는 경우때문에 dfs를 사용하지 않았습니다. 풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// 위장문제.cpp// algorithm-level-up//// Created by kgh on 15/11/2019.// Copyright © 2019 kgh. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main(void)&#123; unordered_map&lt;string,int&gt; m; vector&lt;vector&lt;string&gt;&gt; clothes; vector&lt;string&gt; v1; vector&lt;string&gt; v2; vector&lt;string&gt; v3; v1.push_back(\"yellow_hat\"); v1.push_back(\"headgear\"); v2.push_back(\"blue_sunglasses\"); v2.push_back(\"eyewear\"); v3.push_back(\"green_turban\"); v3.push_back(\"headgear\"); clothes.push_back(v1); clothes.push_back(v2); clothes.push_back(v3); for(int i=0; i&lt;clothes.size(); i++)&#123; m[clothes[i][1]]++; &#125; int answer = 1; unordered_map&lt;string,int&gt;::iterator iter; for(iter=m.begin(); iter != m.end(); iter++)&#123; answer *= (iter-&gt;second+1); &#125; cout &lt;&lt; answer-1; return 0;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}],"tags":[{"name":"프로그래머스","slug":"프로그래머스","permalink":"http://gwanhyeon.github.io.com/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://gwanhyeon.github.io.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"레벨2","slug":"레벨2","permalink":"http://gwanhyeon.github.io.com/tags/%EB%A0%88%EB%B2%A82/"},{"name":"위장","slug":"위장","permalink":"http://gwanhyeon.github.io.com/tags/%EC%9C%84%EC%9E%A5/"},{"name":"해시","slug":"해시","permalink":"http://gwanhyeon.github.io.com/tags/%ED%95%B4%EC%8B%9C/"}]},{"title":"Hexo 명령어","slug":"hexo- command","date":"2019-11-09T16:29:33.000Z","updated":"2019-11-16T00:17:45.614Z","comments":true,"path":"2019/11/10/hexo- command/","link":"","permalink":"http://gwanhyeon.github.io.com/2019/11/10/hexo-%20command/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start front formatter 123456# post.md 머리말---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 123456tags:- 태그명 #(예) 헥소- 깃허브# 또는 아래와 같이 사용 할수 있다.tags: [헥소, 깃허브] 123456categories:- 카테고리명 #(예) 깃허브- 서브카테고리명 #(예) 헥소# 또는 아래 처럼 사용 할수 있다.categories: [깃허브, 헥소] Create a new post 123$ hexo new post \"My New Post\"$ hexo new draft \"My new Draft\"$ hexo new layout \"My New layout\" More info: Writing Run server 123$ hexo server post$ hexo server draft$ hexo server layout More info: Server Generate static files 12$ hexo generate$ hexo g More info: Generating Deploy to remote sites 12$ hexo deploy$ hexo d More info: Deployment Generate static files and Deploy to remote sites 12$ hexo clean$ hexo g -d image files path 1source/images/image file path","categories":[{"name":"HEXO","slug":"hexo","permalink":"http://gwanhyeon.github.io.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://gwanhyeon.github.io.com/tags/hexo/"},{"name":"command","slug":"command","permalink":"http://gwanhyeon.github.io.com/tags/command/"}]}]}